name: Podcast RSS Generator

# 書き込み権限を明示的に要求
permissions:
  contents: write

on:
  schedule:
    - cron: '38 9 * * *'  # 6時38分に実行
    - cron: '8 21 * * *'  # 18時08分に実行
  workflow_dispatch:  # 手動実行用
  push:
    paths:
      - 'docs/podcast/**'  # podcast フォルダに変更があった場合に実行
      - 'output/voicy_episodes.json'  # JSONファイルが更新された場合も実行

jobs:
  generate-rss:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true
          
      - name: Checkout gh-pages branch
        uses: actions/checkout@v3
        with:
          ref: gh-pages
          path: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install feedgen requests
          
      - name: Create scripts directory
        run: mkdir -p .github/scripts
        
      - name: Create Python script
        run: |
          cat > .github/scripts/generate_podcast_rss.py << 'EOF'
          #!/usr/bin/env python
          # -*- coding: utf-8 -*-

          import os
          import glob
          import datetime
          import time
          import re
          import json
          import xml.etree.ElementTree as ET
          import urllib.parse
          import urllib.request
          import sys
          from xml.sax.saxutils import escape

          # 基本設定
          PODCAST_DIR = 'gh-pages/docs/podcast'  # gh-pagesブランチのパス
          OUTPUT_DIR = 'gh-pages/docs'  # 出力先
          OUTPUT_FILE = os.path.join(OUTPUT_DIR, 'feed.rss')  # RSSファイル
          BASE_URL = 'https://paji.github.io/Spotify'
          MP3_BASE_URL = 'https://raw.githubusercontent.com/paji/Spotify/gh-pages/docs/podcast'
          SELF_URL = 'https://paji.github.io/Spotify/feed.rss'
          
          # JSONファイルのURL
          VOICY_EPISODES_URL = "https://raw.githubusercontent.com/paji/Spotify/main/output/voicy_episodes.json"
          # ローカルにvoicy_episodes.jsonが存在する場合のパス
          LOCAL_JSON_PATH = "output/voicy_episodes.json"

          # ポッドキャスト情報
          PODCAST_TITLE = '裏・パジちゃんねる'
          PODCAST_DESCRIPTION = 'ブロックチェーンやAIなど最新テクノロジーについての考察を毎日配信、濃密情報はプレミアムへ→ https://voicy.jp/channel/2834/all?premium=1  パジの日々の挑戦を記録していきます'
          PODCAST_AUTHOR = 'パジ'
          PODCAST_LINK = 'https://voicy.jp/channel/2834/all?premium=1'
          PODCAST_LANGUAGE = 'ja'
          PODCAST_COPYRIGHT = '(C) 2025 パジ'
          PODCAST_WEBMASTER = 'パジ <hajimeataka@gmail.com>'
          PODCAST_TTL = '60'
          PODCAST_EXPLICIT = 'false'
          PODCAST_OWNER_NAME = 'パジ'
          PODCAST_OWNER_EMAIL = 'hajimeataka@gmail.com'
          PODCAST_CATEGORY = 'Technology'
          PODCAST_IMAGE_URL = 'https://paji.github.io/Spotify/profile1600.jpeg'

          def log(message):
              """ログメッセージを出力する"""
              timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              print(f"[{timestamp}] {message}")
              sys.stdout.flush()  # 即時出力を保証

          def get_mp3_files():
              """MP3ファイルのリストを取得する（無料配信のみ）"""
              all_files = glob.glob(os.path.join(PODCAST_DIR, '*.mp3'))
              free_files = [f for f in all_files if not os.path.basename(f).startswith('_')]
              log(f"MP3ファイル: 全{len(all_files)}件、無料配信{len(free_files)}件")
              return free_files

          def extract_id_from_filename(filename):
              """ファイル名からVoicy IDを抽出する"""
              parts = filename.split('_')
              for part in parts:
                  if part.isdigit() and len(part) > 4:  # 数字のみでかつ4桁以上の場合はIDと見なす
                      return part
              return None

          def get_basic_metadata(filepath):
              """ファイルから基本的なメタデータを抽出する"""
              filename = os.path.basename(filepath)
              file_size = os.path.getsize(filepath)
              
              # タイトルはファイル名から取得（拡張子なし、アンダースコアをスペースに）
              title = os.path.splitext(filename)[0].replace('_', ' ')
              
              # ID抽出を試行
              episode_id = extract_id_from_filename(filename)
              
              return {
                  'filename': filename,
                  'file_size': file_size,
                  'title': title,
                  'id': episode_id,
                  'file_path': filepath
              }

          def get_voicy_episodes():
              """VoicyエピソードのJSONデータを取得する"""
              # まずローカルファイルを試す
              if os.path.exists(LOCAL_JSON_PATH):
                  try:
                      log(f"ローカルJSONファイルを読み込み中: {LOCAL_JSON_PATH}")
                      with open(LOCAL_JSON_PATH, 'r', encoding='utf-8') as f:
                          data = json.load(f)
                      log(f"ローカルJSONデータ読み込み成功: {len(data)}件のエピソード情報")
                      return data
                  except Exception as e:
                      log(f"ローカルJSONデータ読み込みエラー: {e}")
              
              # ローカルファイルが存在しない、または読み込みに失敗した場合はGitHubから取得
              try:
                  # キャッシュを回避するためにタイムスタンプを付加
                  url = f"{VOICY_EPISODES_URL}?t={int(time.time())}"
                  log(f"リモートJSONデータをダウンロード中: {url}")
                  
                  with urllib.request.urlopen(url) as response:
                      data = json.loads(response.read().decode())
                  
                  log(f"リモートJSONデータ取得成功: {len(data)}件のエピソード情報")
                  return data
              except Exception as e:
                  log(f"リモートJSONデータ取得エラー: {e}")
                  return []

          def format_rfc822_date(date_str):
              """日付文字列をRFC 822形式にフォーマットする（JSTとして）"""
              try:
                  # 日付文字列をdatetimeオブジェクトに変換
                  dt = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
                  
                  # JSTタイムゾーン（+9時間）として扱う
                  weekday = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"][dt.weekday()]
                  month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.month - 1]
                  return f"{weekday}, {dt.day:02d} {month} {dt.year} {dt.hour:02d}:{dt.minute:02d}:{dt.second:02d} +0900"
              except Exception as e:
                  log(f"日付変換エラー: {e}, date_str: {date_str}")
                  # エラー時には現在時刻を使用
                  now = datetime.datetime.now()
                  weekday = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"][now.weekday()]
                  month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][now.month - 1]
                  return f"{weekday}, {now.day:02d} {month} {now.year} {now.hour:02d}:{now.minute:02d}:{now.second:02d} +0900"

          def generate_rss():
              # mp3ファイルのリストを取得（無料配信のみ）
              mp3_files = get_mp3_files()
              
              # 各ファイルの基本メタデータを取得
              episodes = [get_basic_metadata(f) for f in mp3_files]
              
              # Voicy JSONデータを取得
              voicy_episodes = get_voicy_episodes()
              
              # IDでインデックス化
              voicy_episodes_by_id = {str(episode["id"]): episode for episode in voicy_episodes}
              log(f"JSONデータをIDでインデックス化: {len(voicy_episodes_by_id)}件")
              
              # JSONデータでエピソード情報を補完
              enriched_episodes = []
              for episode in episodes:
                  episode_id = episode['id']
                  if episode_id and episode_id in voicy_episodes_by_id:
                      voicy_data = voicy_episodes_by_id[episode_id]
                      
                      # JSON情報でエピソードを補完
                      episode['voicy_title'] = voicy_data.get('title', episode['title'])
                      episode['voicy_date'] = voicy_data.get('date', '')
                      episode['voicy_url'] = voicy_data.get('url', '')
                      episode['voicy_is_premium'] = voicy_data.get('is_premium', False)
                      
                      log(f"エピソードID {episode_id} を補完: {episode['voicy_title']} ({episode['voicy_date']})")
                      enriched_episodes.append(episode)
                  else:
                      log(f"ID '{episode_id}' に対応するJSON情報が見つかりません: {episode['title']}")
                      # IDがない場合でもエピソードは含める
                      enriched_episodes.append(episode)
              
              # 日付でソート（JSONデータの日付を優先）
              def get_sort_date(ep):
                  return ep.get('voicy_date', '1970-01-01 00:00:00')
              
              enriched_episodes.sort(key=get_sort_date, reverse=True)
              log(f"エピソードを日付順にソートしました: {len(enriched_episodes)}件")
              
              # RSS XMLを生成
              rss = ET.Element("rss", {
                  "xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd",
                  "xmlns:atom": "http://www.w3.org/2005/Atom",
                  "version": "2.0"
              })
              
              channel = ET.SubElement(rss, "channel")
              
              # atom:link要素を追加（self参照）
              ET.SubElement(channel, "atom:link", {
                  "href": SELF_URL,
                  "rel": "self",
                  "type": "application/rss+xml"
              })
              
              # チャンネル基本情報
              add_simple_element(channel, "title", PODCAST_TITLE)
              add_simple_element(channel, "description", PODCAST_DESCRIPTION)
              add_simple_element(channel, "link", PODCAST_LINK)
              add_simple_element(channel, "language", PODCAST_LANGUAGE)
              add_simple_element(channel, "copyright", PODCAST_COPYRIGHT)
              add_simple_element(channel, "webMaster", PODCAST_WEBMASTER)
              add_simple_element(channel, "ttl", PODCAST_TTL)
              add_simple_element(channel, "itunes:explicit", PODCAST_EXPLICIT)
              add_simple_element(channel, "itunes:author", PODCAST_AUTHOR)
              
              # オーナー情報
              owner = ET.SubElement(channel, "itunes:owner")
              add_simple_element(owner, "itunes:name", PODCAST_OWNER_NAME)
              add_simple_element(owner, "itunes:email", PODCAST_OWNER_EMAIL)
              
              # カテゴリ
              ET.SubElement(channel, "itunes:category", {"text": PODCAST_CATEGORY})
              
              # イメージ
              image = ET.SubElement(channel, "image")
              add_simple_element(image, "url", PODCAST_IMAGE_URL)
              add_simple_element(image, "title", PODCAST_TITLE)
              add_simple_element(image, "link", PODCAST_LINK)
              
              ET.SubElement(channel, "itunes:image", {"href": PODCAST_IMAGE_URL})
              
              # エピソードアイテムを追加
              for episode in enriched_episodes:
                  # URLエンコードされたファイル名
                  encoded_filename = urllib.parse.quote(episode['filename'])
                  file_url = f"{MP3_BASE_URL}/{encoded_filename}"
                  
                  # タイトル（JSONデータを優先）
                  title = episode.get('voicy_title', episode['title'])
                  
                  # 説明文
                  description = f"Episode: {title}"
                  if 'voicy_url' in episode and episode['voicy_url']:
                      description += f"\n配信元URL: {episode['voicy_url']}"
                  
                  # アイテム要素
                  item = ET.SubElement(channel, "item")
                  
                  add_simple_element(item, "title", title)
                  add_simple_element(item, "description", description)
                  
                  # 配信日時（JSONからの日付を優先）
                  if 'voicy_date' in episode and episode['voicy_date']:
                      pub_date = format_rfc822_date(episode['voicy_date'])
                      log(f"エピソード '{title}' の日付: {episode['voicy_date']} → {pub_date}")
                  else:
                      # JSONに日付がない場合は現在時刻を使用
                      now_str = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                      pub_date = format_rfc822_date(now_str)
                      log(f"エピソード '{title}' の日付が見つからないため現在時刻を使用: {now_str} → {pub_date}")
                  
                  add_simple_element(item, "pubDate", pub_date)
                  
                  # エンクロージャー（mp3ファイル情報）
                  ET.SubElement(item, "enclosure", {
                      "url": file_url,
                      "length": str(episode['file_size']),
                      "type": "audio/mpeg"
                  })
                  
                  # podcast追加情報
                  add_simple_element(item, "itunes:duration", "00:30:00")
                  add_simple_element(item, "itunes:author", PODCAST_AUTHOR)
                  add_simple_element(item, "itunes:summary", description)
                  
                  # GUID
                  guid = ET.SubElement(item, "guid", {"isPermaLink": "false"})
                  guid.text = file_url
              
              # XMLを保存
              save_xml(rss)
              
              # 補助ファイルを作成
              create_support_files()
              
              log("RSS生成完了")

          def add_simple_element(parent, name, text):
              """単純な要素を追加するヘルパー関数"""
              element = ET.SubElement(parent, name)
              element.text = text
              return element

          def save_xml(root):
              """XMLを保存する"""
              # XML宣言
              xml_declaration = '<?xml version="1.0" encoding="UTF-8"?>\n'
              
              # ElementTreeをXML文字列に変換
              tree = ET.ElementTree(root)
              xml_str = ET.tostring(root, encoding='utf-8', method='xml').decode('utf-8')
              
              # 最終的なXML
              final_xml = xml_declaration + xml_str
              
              # 文字化け防止のためUTF-8で明示的に保存
              with open(OUTPUT_FILE, 'wb') as f:
                  f.write(final_xml.encode('utf-8'))
              
              log(f"XMLを保存しました: {OUTPUT_FILE}")
              
              # デバッグ用に日付情報をファイルに出力
              debug_file = os.path.join(OUTPUT_DIR, 'rss_debug.log')
              with open(debug_file, 'w', encoding='utf-8') as f:
                  f.write(f"RSS生成日時: {datetime.datetime.now().isoformat()}\n")
                  f.write(f"RSSファイル: {OUTPUT_FILE}\n")
                  f.write("各エピソードのpubDate情報:\n")
                  
                  # XMLから全エピソードの日付情報を抽出
                  tree = ET.ElementTree(root)
                  items = tree.findall('.//item')
                  for item in items:
                      title = item.find('title')
                      pubdate = item.find('pubDate')
                      if title is not None and pubdate is not None:
                          f.write(f"- {title.text}: {pubdate.text}\n")
              
              log(f"デバッグログを保存しました: {debug_file}")

          def create_support_files():
              """補助ファイルを作成する"""
              # 更新フラグファイル
              flag_file = os.path.join(OUTPUT_DIR, '.feed_updated')
              with open(flag_file, 'w') as f:
                  f.write(f"Last updated: {datetime.datetime.now().isoformat()} - {time.time()}")
              
              # .nojekyllファイル（Jekyllの処理を無効化）
              nojekyll_path = os.path.join(OUTPUT_DIR, '.nojekyll')
              with open(nojekyll_path, 'w') as f:
                  f.write('# このファイルはJekyllの処理を無効化します')
              
              # HTMLリダイレクトファイル（rss.xmlからfeed.rssへのリダイレクト）
              redirect_path = os.path.join(OUTPUT_DIR, 'rss.xml')
              with open(redirect_path, 'w') as f:
                  f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
                  f.write('<!DOCTYPE html>\n')
                  f.write('<html>\n')
                  f.write('<head>\n')
                  f.write('  <meta http-equiv="refresh" content="0;URL=\'feed.rss\'" />\n')
                  f.write('  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n')
                  f.write('  <title>Redirecting to feed.rss</title>\n')
                  f.write('</head>\n')
                  f.write('<body>\n')
                  f.write('  <p>このページは<a href="feed.rss">feed.rss</a>にリダイレクトされます。</p>\n')
                  f.write('</body>\n')
                  f.write('</html>\n')
              
              log("補助ファイルを作成しました")

          if __name__ == "__main__":
              log("Podcast RSS生成処理を開始します")
              generate_rss()
              log("処理完了")
          EOF
          
      - name: Generate RSS feed
        run: |
          chmod +x .github/scripts/generate_podcast_rss.py
          python .github/scripts/generate_podcast_rss.py
        
      - name: Commit and push changes to gh-pages branch
        run: |
          cd gh-pages
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git add docs/feed.rss docs/rss.xml docs/.nojekyll docs/.feed_updated docs/rss_debug.log
          
          # 常に変更をコミットして強制的に更新する
          git commit -m "自動更新: Podcast RSS feed $(date +'%Y-%m-%d %H:%M:%S')"
          git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/paji/Spotify.git gh-pages
          echo "gh-pagesブランチに変更をプッシュしました"
