name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_to_mp3(m3u8_url, output_mp3_path, episode_id):
              """
              m3u8ファイルをダウンロードしてMP3に変換する関数
              
              Args:
                  m3u8_url: m3u8ファイルのURL
                  output_mp3_path: 出力先のMP3ファイルパス
                  episode_id: エピソードID
              
              Returns:
                  str: 成功した場合はMP3ファイルのパス、失敗した場合はNone
              """
              print(f"::group::m3u8ダウンロード")
              print(f"m3u8 URL: {m3u8_url}")
              print(f"出力MP3パス: {output_mp3_path}")
              
              try:
                  # 出力ディレクトリが存在することを確認
                  os.makedirs(os.path.dirname(os.path.abspath(output_mp3_path)), exist_ok=True)
                  
                  # 一時ディレクトリをクリア
                  for file in os.listdir(TEMP_DIR):
                      file_path = os.path.join(TEMP_DIR, file)
                      try:
                          if os.path.isfile(file_path):
                              os.unlink(file_path)
                      except Exception as e:
                          print(f"一時ファイルの削除中にエラーが発生しました: {e}")
                  
                  # ファイル拡張子を確認
                  if m3u8_url.endswith('.m3u8'):
                      # m3u8ファイルの場合
                      print(f"m3u8ファイルを処理します")
                      
                      # m3u8ファイルをダウンロード
                      m3u8_content = requests.get(m3u8_url).text
                      m3u8_path = os.path.join(TEMP_DIR, f"playlist_{episode_id}.m3u8")
                      with open(m3u8_path, 'w') as f:
                          f.write(m3u8_content)
                      
                      print(f"m3u8ファイルをダウンロードしました: {m3u8_path}")
                      
                      # m3u8ファイルを解析してセグメントURLを取得
                      segment_urls = []
                      base_url = m3u8_url.rsplit('/', 1)[0] + '/'
                      
                      for line in m3u8_content.splitlines():
                          if not line.startswith('#') and line.strip():
                              if line.startswith('http'):
                                  segment_urls.append(line)
                              else:
                                  segment_urls.append(base_url + line)
                      
                      print(f"セグメント数: {len(segment_urls)}")
                      
                      # セグメントをダウンロード
                      mp3_segments = []
                      for i, segment_url in enumerate(segment_urls):
                          # セグメントファイルのパスを作成する際に、ファイル名のみを指定
                          segment_filename = f"segment_{episode_id}_{i:03d}.ts"
                          segment_path = os.path.join(TEMP_DIR, segment_filename)
                          try:
                              segment_content = requests.get(segment_url).content
                              with open(segment_path, 'wb') as f:
                                  f.write(segment_content)
                              mp3_segments.append(segment_path)
                              print(f"セグメント {i+1}/{len(segment_urls)} をダウンロードしました")
                          except Exception as e:
                              print(f"セグメント {i+1} のダウンロード中にエラーが発生しました: {str(e)}")
                      
                      # セグメントを結合してMP3に変換
                      if mp3_segments:
                          # 一時的なTSファイルを作成
                          ts_path = os.path.join(TEMP_DIR, f"combined_{episode_id}.ts")
                          
                          # TSファイルを結合
                          with open(ts_path, 'wb') as outfile:
                              for segment_path in mp3_segments:
                                  if os.path.exists(segment_path):
                                      with open(segment_path, 'rb') as infile:
                                          outfile.write(infile.read())
                          
                          print(f"TSファイルを結合しました: {ts_path}")
                          
                          # TSファイルをMP3に変換
                          cmd = [
                              'ffmpeg',
                              '-i', ts_path,
                              '-c:a', 'libmp3lame',
                              '-q:a', '2',
                              '-y',
                              output_mp3_path
                          ]
                          
                          print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                          result = subprocess.run(cmd, capture_output=True, text=True)
                          
                          if result.returncode == 0:
                              print(f"MP3ファイルの変換に成功しました: {output_mp3_path}")
                              if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                                  file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                                  print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                  print(f"::endgroup::")
                                  return output_mp3_path
                              else:
                                  print(f"MP3ファイルが正常に作成されませんでした")
                          else:
                              print(f"MP3ファイルの変換に失敗しました: {result.stderr}")
                      else:
                          print(f"ダウンロードされたセグメントがありません")
                  elif m3u8_url.endswith('.mp3'):
                      # 直接MP3ファイルの場合
                      print(f"直接MP3ファイルをダウンロードします")
                      
                      try:
                          mp3_content = requests.get(m3u8_url).content
                          with open(output_mp3_path, 'wb') as f:
                              f.write(mp3_content)
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"MP3ファイルのダウンロードに成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              print(f"::endgroup::")
                              return output_mp3_path
                          else:
                              print(f"MP3ファイルが正常にダウンロードされませんでした")
                      except Exception as e:
                          print(f"MP3ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                          traceback.print_exc()
                  elif m3u8_url.endswith('.aac'):
                      # AACファイルの場合
                      print(f"AACファイルをダウンロードしてMP3に変換します")
                      
                      try:
                          aac_path = os.path.join(TEMP_DIR, f"audio_{episode_id}.aac")
                          aac_content = requests.get(m3u8_url).content
                          with open(aac_path, 'wb') as f:
                              f.write(aac_content)
                          
                          # AACファイルをMP3に変換
                          cmd = [
                              'ffmpeg',
                              '-i', aac_path,
                              '-c:a', 'libmp3lame',
                              '-q:a', '2',
                              '-y',
                              output_mp3_path
                          ]
                          
                          print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                          result = subprocess.run(cmd, capture_output=True, text=True)
                          
                          if result.returncode == 0:
                              print(f"MP3ファイルの変換に成功しました: {output_mp3_path}")
                              if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                                  file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                                  print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                  print(f"::endgroup::")
                                  return output_mp3_path
                              else:
                                  print(f"MP3ファイルが正常に作成されませんでした")
                          else:
                              print(f"MP3ファイルの変換に失敗しました: {result.stderr}")
                      except Exception as e:
                          print(f"AACファイルの処理中にエラーが発生しました: {str(e)}")
                          traceback.print_exc()
                  else:
                      print(f"未対応のファイル形式です: {m3u8_url}")
              except Exception as e:
                  print(f"MP3ダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def get_episode_list():
              """エピソード一覧を取得"""
              print(f"::group::エピソード一覧取得")
              print(f"GitHubからエピソード情報を取得します")
              
              try:
                  # GitHubからJSONファイルを取得
                  json_url = "https://raw.githubusercontent.com/paji/Spotify/main/output/voicy_episodes.json"
                  response = requests.get(json_url)
                  response.raise_for_status()  # エラーがあれば例外を発生させる
                  
                  episodes_data = response.json()
                  
                  # channel/2834のエピソードのみをフィルタリング
                  filtered_episodes = []
                  for episode in episodes_data:
                      if f"/channel/{CHANNEL_ID}/" in episode["url"]:
                          # is_premium情報を追加（実際の判定はcheck_if_premium関数で行われる）
                          filtered_episodes.append(episode)
                  
                  if not filtered_episodes:
                      print(f"チャンネルID {CHANNEL_ID} のエピソードが見つかりませんでした")
                      print(f"::endgroup::")
                      return []
                  
                  print(f"取得したエピソード数: {len(filtered_episodes)}")
                  print(f"::endgroup::")
                  return filtered_episodes
              except Exception as e:
                  print(f"エピソード一覧の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def check_if_premium(episode_id):
              """
              エピソードが有料放送かどうかを判定する関数
              
              Args:
                  episode_id: エピソードID
              
              Returns:
                  bool: 有料放送の場合はTrue、無料放送の場合はFalse
              """
              print(f"::group::有料放送判定")
              episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}"
              print(f"エピソードURL: {episode_url}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  
                  # WebDriverを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # ページを読み込む
                  driver.get(episode_url)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # 方法1: "P"アイコンを探す
                  premium_icons = driver.find_elements(By.XPATH, "//*[contains(@class, 'premium') or contains(@class, 'Premium')]")
                  if premium_icons:
                      print(f"「P」アイコンが見つかりました。有料放送と判定します。")
                      driver.quit()
                      print(f"::endgroup::")
                      return True
                  
                  # 方法2: "プレミアム"の文言を探す
                  page_source = driver.page_source
                  if "プレミアム" in page_source or "Premium" in page_source or "premium" in page_source:
                      print(f"「プレミアム」の文言が見つかりました。有料放送と判定します。")
                      driver.quit()
                      print(f"::endgroup::")
                      return True
                  
                  # 方法3: scriptタグ内のJSONデータから判定
                  try:
                      script_elements = driver.find_elements(By.TAG_NAME, "script")
                      for script in script_elements:
                          script_content = script.get_attribute("innerHTML")
                          if script_content and "window.__NUXT__" in script_content:
                              # JSONデータを抽出
                              json_str = script_content.split('window.__NUXT__=')[1].strip()
                              # 最後のセミコロンを削除
                              if json_str.endswith(';'):
                                  json_str = json_str[:-1]
                              
                              # JSONデータをパース
                              data = json.loads(json_str)
                              
                              # premium情報を探索
                              if 'state' in data and 'episode' in data['state']:
                                  episode_data = data['state']['episode']
                                  if 'isPremium' in episode_data and episode_data['isPremium']:
                                      print(f"JSONデータから有料放送と判定しました。")
                                      driver.quit()
                                      print(f"::endgroup::")
                                      return True
                  except Exception as e:
                      print(f"JSONデータからの判定中にエラーが発生しました: {str(e)}")
                  
                  print(f"有料放送の特徴が見つかりませんでした。無料放送と判定します。")
                  driver.quit()
                  print(f"::endgroup::")
                  return False
              except Exception as e:
                  print(f"有料放送判定中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  # エラーが発生した場合は安全のため有料放送と判定
                  return True

          def get_audio_url(episode_id, expected_title):
              """エピソードのオーディオURLを取得（修正版）"""
              print(f"::group::オーディオURL取得")
              episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}"
              print(f"エピソードURL: {episode_url}")
              print(f"期待されるタイトル: {expected_title}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  
                  # WebDriverを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # ページを読み込む
                  driver.get(episode_url)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # タイトルを取得して確認
                  try:
                      title_element = driver.find_element(By.CSS_SELECTOR, "h1")
                      actual_title = title_element.text.strip()
                      print(f"実際のタイトル: {actual_title}")
                      
                      # タイトルが一致するか確認
                      if expected_title not in actual_title and actual_title not in expected_title:
                          print(f"警告: タイトルが一致しません")
                  except Exception as e:
                      print(f"タイトル取得中にエラーが発生しました: {str(e)}")
                  
                  # JavaScriptからJSONデータを抽出
                  script_elements = driver.find_elements(By.TAG_NAME, "script")
                  audio_url = None
                  
                  for script in script_elements:
                      script_content = script.get_attribute("innerHTML")
                      if script_content and "window.__NUXT__" in script_content:
                          # JSONデータを抽出
                          json_str = script_content.split('window.__NUXT__=')[1].strip()
                          # 最後のセミコロンを削除
                          if json_str.endswith(';'):
                              json_str = json_str[:-1]
                          
                          try:
                              # JSONデータをパース
                              data = json.loads(json_str)
                              
                              # 音声URLを取得
                              if 'state' in data and 'episode' in data['state']:
                                  episode_data = data['state']['episode']
                                  if 'media' in episode_data and 'url' in episode_data['media']:
                                      audio_url = episode_data['media']['url']
                                      print(f"音声URL: {audio_url}")
                                      break
                          except json.JSONDecodeError as e:
                              print(f"JSONデータの解析中にエラーが発生しました: {str(e)}")
                              continue
                  
                  driver.quit()
                  
                  if not audio_url:
                      print(f"音声URLが見つかりませんでした")
                  
                  print(f"::endgroup::")
                  return audio_url
              except Exception as e:
                  print(f"オーディオURLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              
              try:
                  # 有料放送かどうかを判定
                  is_premium = check_if_premium(episode_id)
                  print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
                  
                  # 有料放送の場合はスキップ
                  if is_premium:
                      print(f"エピソード {episode_id} は有料放送のためスキップします")
                      print(f"::endgroup::")
                      return None
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_path
                  
                  # オーディオURLを取得（タイトルを渡して正しいエピソードを特定）
                  audio_url = get_audio_url(episode_id, episode_title)
                  if not audio_url:
                      print(f"エピソード {episode_id} のオーディオURLが取得できませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  # MP3をダウンロード
                  mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
                  
                  if mp3_file:
                      print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_path}")
                      print(f"::endgroup::")
                      return mp3_path
                  else:
                      print(f"エピソード {episode_id} のダウンロードに失敗しました")
              except Exception as e:
                  print(f"エピソード {episode_id} のダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def main():
              """メイン関数"""
              print(f"Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード一覧を取得
              episodes = get_episode_list()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードを処理します")
              
              downloaded_count = 0
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
                      downloaded_count += 1
                  
                  # MAX_EPISODESの無料エピソードをダウンロードしたら終了
                  if downloaded_count >= MAX_EPISODES:
                      print(f"{MAX_EPISODES}件の無料エピソードをダウンロードしました。処理を終了します。")
                      break
              
              # ダウンロード結果を表示
              print("\nダウンロード結果:")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出
                  if mp3_file.startswith('_'):
                      # 有料放送: _日付_タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 有料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイルサイズ: {file_size_mb:.2f}MB")
                  else:
                      # 無料放送: 日付_タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 無料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイルサイズ: {file_size_mb:.2f}MB")
              
              print(f"\n合計: {len(mp3_files)}個のMP3ファイル")
              print(f"今回のダウンロード: {len(downloaded_files)}個のMP3ファイル")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルをコミット
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add mp3_downloads/*.mp3
          git diff --staged --quiet || git commit -m "Add new MP3 files"
          git push
