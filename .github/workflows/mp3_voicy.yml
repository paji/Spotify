name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
        with:
          ref: gh-pages  # gh-pagesブランチを使用
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
          mkdir -p docs/podcast
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v4.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ
          CHANNEL_ALL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # すべての放送ページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"
          PODCAST_DIR = "docs/podcast"  # GitHub Pagesで公開するディレクトリ

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR, PODCAST_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          # ACCファイルをMP3に変換する関数
          def convert_acc_to_mp3(acc_file, mp3_file):
              """
              ACCファイルをMP3に変換する関数
              
              Args:
                  acc_file: 入力ACCファイルパス
                  mp3_file: 出力MP3ファイルパス
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              try:
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-i', acc_file,
                      '-acodec', 'libmp3lame',
                      '-ab', '192k',
                      '-y',
                      mp3_file
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"ACCファイルをMP3に変換しました: {mp3_file}")
                      return True
                  else:
                      print(f"ACCファイルの変換に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"ACCファイルの変換中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          # ファイルをダウンロードする関数
          def download_file(url, output_path, chunk_size=8192):
              """
              ファイルをダウンロードする関数
              
              Args:
                  url: ダウンロードするファイルのURL
                  output_path: 保存先のパス
                  chunk_size: ダウンロードチャンクサイズ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              try:
                  response = requests.get(url, stream=True)
                  response.raise_for_status()
                  
                  with open(output_path, 'wb') as f:
                      for chunk in response.iter_content(chunk_size=chunk_size):
                          if chunk:
                              f.write(chunk)
                  
                  if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                      file_size_mb = os.path.getsize(output_path) / (1024 * 1024)
                      print(f"ファイルをダウンロードしました: {output_path} (サイズ: {file_size_mb:.2f}MB)")
                      return True
                  else:
                      print(f"ダウンロードしたファイルが正常に保存されませんでした: {output_path}")
                      return False
              except Exception as e:
                  print(f"ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def get_episode_list():
              """エピソード一覧を取得"""
              print(f"::group::エピソード一覧取得")
              print(f"チャンネルURL: {CHANNEL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # ページ読み込みのタイムアウトを設定
                  driver.set_page_load_timeout(30)
                  
                  try:
                      # まずチャンネルのメインページにアクセス
                      print(f"チャンネルメインページにアクセスします: {CHANNEL_URL}")
                      driver.get(CHANNEL_URL)
                      print(f"チャンネルメインページにアクセスしました: {CHANNEL_URL}")
                      
                      # ページが完全に読み込まれるまで待機
                      WebDriverWait(driver, 10).until(
                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                      )
                      
                      # 「すべての放送を見る」ボタンを探して押す
                      print("「すべての放送を見る」ボタンを探しています...")
                      try:
                          # 複数の可能性のあるセレクタを試す
                          selectors = [
                              "a[href*='/all']", 
                              "button:contains('すべての放送')", 
                              "a:contains('すべての放送')",
                              ".see-all-button",
                              "//a[contains(text(), 'すべての放送')]",
                              "//button[contains(text(), 'すべての放送')]"
                          ]
                          
                          view_all_button = None
                          for selector in selectors:
                              try:
                                  if selector.startswith("//"):
                                      # XPathの場合
                                      elements = driver.find_elements(By.XPATH, selector)
                                  elif ":contains" in selector:
                                      # jQuery風のセレクタは直接サポートされていないので、JavaScriptで処理
                                      js_code = f"""
                                      return Array.from(document.querySelectorAll('{selector.split(':contains')[0]}')).filter(el => 
                                          el.textContent.includes('すべての放送')
                                      )[0];
                                      """
                                      elements = [driver.execute_script(js_code)]
                                  else:
                                      # 通常のCSSセレクタ
                                      elements = driver.find_elements(By.CSS_SELECTOR, selector)
                                  
                                  if elements and elements[0]:
                                      view_all_button = elements[0]
                                      print(f"「すべての放送を見る」ボタンが見つかりました: {selector}")
                                      break
                              except Exception as e:
                                  print(f"セレクタ {selector} の検索中にエラー: {str(e)}")
                          
                          # ボタンが見つからない場合はJavaScriptで直接検索
                          if not view_all_button:
                              print("JavaScriptを使用してボタンを検索します...")
                              js_code = """
                              return Array.from(document.querySelectorAll('a, button')).find(el => 
                                  el.textContent.includes('すべての放送') || 
                                  (el.getAttribute('href') && el.getAttribute('href').includes('/all'))
                              );
                              """
                              view_all_button = driver.execute_script(js_code)
                          
                          if view_all_button:
                              # ボタンをクリック
                              print("「すべての放送を見る」ボタンをクリックします...")
                              driver.execute_script("arguments[0].click();", view_all_button)
                              print("「すべての放送を見る」ボタンをクリックしました")
                              
                              # ページが完全に読み込まれるまで待機
                              WebDriverWait(driver, 10).until(
                                  EC.presence_of_element_located((By.TAG_NAME, "body"))
                              )
                              
                              # 現在のURLを確認
                              current_url = driver.current_url
                              print(f"現在のURL: {current_url}")
                              
                              # URLが/allで終わっていない場合は直接アクセス
                              if not current_url.endswith('/all'):
                                  print(f"URLが/allで終わっていないため、直接アクセスします: {CHANNEL_ALL_URL}")
                                  driver.get(CHANNEL_ALL_URL)
                                  print(f"チャンネルの全放送ページにアクセスしました: {CHANNEL_ALL_URL}")
                          else:
                              # ボタンが見つからない場合は直接アクセス
                              print(f"「すべての放送を見る」ボタンが見つからないため、直接アクセスします: {CHANNEL_ALL_URL}")
                              driver.get(CHANNEL_ALL_URL)
                              print(f"チャンネルの全放送ページにアクセスしました: {CHANNEL_ALL_URL}")
                      except Exception as e:
                          print(f"「すべての放送を見る」ボタンの検索中にエラーが発生しました: {str(e)}")
                          traceback.print_exc()
                          # エラーが発生した場合は直接アクセス
                          print(f"直接アクセスします: {CHANNEL_ALL_URL}")
                          driver.get(CHANNEL_ALL_URL)
                          print(f"チャンネルの全放送ページにアクセスしました: {CHANNEL_ALL_URL}")
                      
                      # ページが完全に読み込まれるまで待機
                      WebDriverWait(driver, 10).until(
                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                      )
                      
                      # JavaScriptが実行完了するまで少し待機
                      time.sleep(3)
                      
                      # ページのHTMLを取得
                      html_content = driver.page_source
                      debug_html_path = os.path.join(DEBUG_DIR, "episode_list.html")
                      with open(debug_html_path, "w", encoding="utf-8") as f:
                          f.write(html_content)
                      print(f"デバッグ用にHTMLを保存しました: {debug_html_path}")
                      
                      # 複数の方法でエピソード要素を取得
                      print("複数の方法でエピソード要素を取得します...")
                      
                      # 方法1: 直接リンクを探す
                      episode_elements = driver.find_elements(By.CSS_SELECTOR, "a[href*='/episode/'], a[href*='/channel/2834/']")
                      print(f"方法1 - 直接リンク検索: {len(episode_elements)}件")
                      
                      # 方法2: より広範なセレクタを使用
                      if len(episode_elements) < 3:
                          broader_elements = driver.find_elements(By.CSS_SELECTOR, "a[href*='/episode/'], a[href*='/channel/'], div[class*='episode'], div[class*='broadcast'], article, .card, .item")
                          print(f"方法2 - 広範なセレクタ: {len(broader_elements)}件")
                          if len(broader_elements) > len(episode_elements):
                              episode_elements = broader_elements
                      
                      # 方法3: JavaScriptを使用して全てのリンクから探す
                      if len(episode_elements) < 3:
                          print("方法3 - JavaScriptを使用してエピソード要素を探します...")
                          js_code = """
                          return Array.from(document.querySelectorAll('a')).filter(a => 
                              a.href && (
                                  a.href.includes('/episode/') || 
                                  a.href.includes('/channel/2834/') ||
                                  (a.parentElement && a.parentElement.className && 
                                   (a.parentElement.className.includes('episode') || 
                                    a.parentElement.className.includes('broadcast')))
                              )
                          );
                          """
                          js_episode_elements = driver.execute_script(js_code)
                          print(f"方法3 - JavaScript検索: {len(js_episode_elements) if js_episode_elements else 0}件")
                          if js_episode_elements and len(js_episode_elements) > len(episode_elements):
                              episode_elements = js_episode_elements
                      
                      # 方法4: ページ内の全ての要素を調査
                      if len(episode_elements) < 3:
                          print("方法4 - ページ構造を詳細に分析します...")
                          # ページ内の全てのdiv要素を取得
                          all_divs = driver.find_elements(By.TAG_NAME, "div")
                          print(f"ページ内のdiv要素数: {len(all_divs)}")
                          
                          # 特定のクラス名やパターンを持つ要素を探す
                          potential_containers = []
                          for div in all_divs:
                              try:
                                  class_name = div.get_attribute("class") or ""
                                  if ("card" in class_name.lower() or 
                                      "item" in class_name.lower() or 
                                      "episode" in class_name.lower() or 
                                      "broadcast" in class_name.lower() or
                                      "content" in class_name.lower()):
                                      potential_containers.append(div)
                              except:
                                  pass
                          
                          print(f"潜在的なコンテナ要素数: {len(potential_containers)}")
                          
                          # 各コンテナからリンクを探す
                          container_links = []
                          for container in potential_containers:
                              try:
                                  links = container.find_elements(By.TAG_NAME, "a")
                                  for link in links:
                                      href = link.get_attribute("href")
                                      if href and ("/episode/" in href or f"/channel/{CHANNEL_ID}" in href):
                                          container_links.append(link)
                              except:
                                  pass
                          
                          print(f"コンテナから見つかったリンク数: {len(container_links)}")
                          if len(container_links) > len(episode_elements):
                              episode_elements = container_links
                      
                      # 最終的なエピソード要素数を表示
                      print(f"最終的なエピソード要素数: {len(episode_elements)}")
                      
                      # エピソード要素が見つからない場合のデバッグ情報
                      if not episode_elements:
                          print("エピソード要素が見つかりません。詳細なデバッグ情報:")
                          print(f"現在のURL: {driver.current_url}")
                          print(f"ページタイトル: {driver.title}")
                          print(f"ページソースの一部: {html_content[:500]}...")
                      
                      # エピソード情報を収集
                      episodes = []
                      for i, element in enumerate(episode_elements):
                          try:
                              print(f"エピソード要素 {i+1} を処理中...")
                              
                              # エピソードのURLを取得（複数の方法を試す）
                              href = None
                              
                              # 方法1: 直接href属性を取得
                              try:
                                  if hasattr(element, 'get_attribute'):
                                      href = element.get_attribute("href")
                                      print(f"方法1 - 直接href属性: {href}")
                              except Exception as e:
                                  print(f"方法1でのURL取得中にエラー: {str(e)}")
                              
                              # 方法2: 子要素のaタグからhrefを取得
                              if not href:
                                  try:
                                      if hasattr(element, 'find_elements'):
                                          links = element.find_elements(By.TAG_NAME, "a")
                                          for link in links:
                                              link_href = link.get_attribute("href")
                                              if link_href and ("/episode/" in link_href or f"/channel/{CHANNEL_ID}/" in link_href):
                                                  href = link_href
                                                  print(f"方法2 - 子要素のaタグ: {href}")
                                                  break
                                  except Exception as e:
                                      print(f"方法2でのURL取得中にエラー: {str(e)}")
                              
                              # 方法3: JavaScriptを使用
                              if not href:
                                  try:
                                      js_code = """
                                      let el = arguments[0];
                                      if (el.href) return el.href;
                                      let links = el.querySelectorAll('a');
                                      for (let link of links) {
                                          if (link.href && (link.href.includes('/episode/') || link.href.includes('/channel/2834/'))) {
                                              return link.href;
                                          }
                                      }
                                      return null;
                                      """
                                      href = driver.execute_script(js_code, element)
                                      print(f"方法3 - JavaScript: {href}")
                                  except Exception as e:
                                      print(f"方法3でのURL取得中にエラー: {str(e)}")
                              
                              # URLが見つからない場合はスキップ
                              if not href or (not "/episode/" in href and not f"/channel/{CHANNEL_ID}/" in href):
                                  print(f"有効なURLが見つからないためスキップします")
                                  continue
                              
                              # エピソードIDを抽出
                              episode_id = None
                              
                              # 方法1: /episode/パターン
                              if "/episode/" in href:
                                  match = re.search(r"/episode/(\d+)", href)
                                  if match:
                                      episode_id = match.group(1)
                                      print(f"方法1 - /episode/パターンからID抽出: {episode_id}")
                              
                              # 方法2: /channel/ID/パターン
                              if not episode_id and f"/channel/{CHANNEL_ID}/" in href:
                                  match = re.search(r"/channel/\d+/(\d+)", href)
                                  if match:
                                      episode_id = match.group(1)
                                      print(f"方法2 - /channel/パターンからID抽出: {episode_id}")
                              
                              # 方法3: 他のパターンを試す
                              if not episode_id:
                                  # 数字のみのパターンを探す
                                  match = re.search(r"[^0-9](\d{5,})[^0-9]", href)
                                  if match:
                                      episode_id = match.group(1)
                                      print(f"方法3 - 数字パターンからID抽出: {episode_id}")
                              
                              if not episode_id:
                                  print(f"エピソードIDが抽出できないためスキップします")
                                  continue
                              
                              # エピソードのタイトルを取得（複数の方法を試す）
                              title = None
                              
                              # 方法1: 直接テキストを取得
                              try:
                                  if hasattr(element, 'text'):
                                      title = element.text.strip()
                                      print(f"方法1 - 直接テキスト: {title[:30]}...")
                              except Exception as e:
                                  print(f"方法1でのタイトル取得中にエラー: {str(e)}")
                              
                              # 方法2: 親要素からタイトルを取得
                              if not title or len(title) < 3:
                                  try:
                                      if hasattr(element, 'find_element'):
                                          parent = element.find_element(By.XPATH, "..")
                                          title = parent.text.strip()
                                          print(f"方法2 - 親要素のテキスト: {title[:30]}...")
                                  except Exception as e:
                                      print(f"方法2でのタイトル取得中にエラー: {str(e)}")
                              
                              # 方法3: タイトル要素を探す
                              if not title or len(title) < 3:
                                  try:
                                      title_selectors = ["h1", "h2", "h3", "h4", ".title", ".episode-title", "[class*='title']", ".name", ".episode-name"]
                                      for selector in title_selectors:
                                          try:
                                              if hasattr(element, 'find_element'):
                                                  title_element = element.find_element(By.CSS_SELECTOR, selector)
                                                  title = title_element.text.strip()
                                                  if title and len(title) >= 3:
                                                      print(f"方法3 - セレクタ {selector}: {title[:30]}...")
                                                      break
                                          except:
                                              pass
                                  except Exception as e:
                                      print(f"方法3でのタイトル取得中にエラー: {str(e)}")
                              
                              # 方法4: JavaScriptを使用
                              if not title or len(title) < 3:
                                  try:
                                      js_code = """
                                      let el = arguments[0];
                                      let text = el.textContent.trim();
                                      if (text.length >= 3) return text;
                                      
                                      // タイトル要素を探す
                                      let titleElements = el.querySelectorAll('h1, h2, h3, h4, .title, .episode-title, [class*="title"], .name, .episode-name');
                                      for (let titleEl of titleElements) {
                                          let titleText = titleEl.textContent.trim();
                                          if (titleText.length >= 3) return titleText;
                                      }
                                      
                                      // 親要素のテキストを取得
                                      if (el.parentElement) {
                                          return el.parentElement.textContent.trim();
                                      }
                                      
                                      return null;
                                      """
                                      js_title = driver.execute_script(js_code, element)
                                      if js_title and len(js_title) >= 3:
                                          title = js_title
                                          print(f"方法4 - JavaScript: {title[:30]}...")
                                  except Exception as e:
                                      print(f"方法4でのタイトル取得中にエラー: {str(e)}")
                              
                              # タイトルが見つからない場合はエピソードIDを使用
                              if not title or len(title) < 3:
                                  title = f"エピソード {episode_id}"
                                  print(f"タイトルが見つからないため、デフォルトタイトルを使用: {title}")
                              
                              # 有料放送かどうかを判定
                              is_premium = False
                              
                              # 方法1: プレミアムアイコンを探す
                              try:
                                  if hasattr(element, 'find_elements'):
                                      premium_icons = element.find_elements(By.CSS_SELECTOR, ".premium-icon, img[src*='premium'], [class*='premium']")
                                      if premium_icons:
                                          is_premium = True
                                          print(f"方法1 - プレミアムアイコン検出: 有料放送")
                              except Exception as e:
                                  print(f"方法1での有料判定中にエラー: {str(e)}")
                              
                              # 方法2: 親要素のHTMLに'premium'が含まれているか確認
                              if not is_premium:
                                  try:
                                      if hasattr(element, 'find_element'):
                                          parent = element.find_element(By.XPATH, "..")
                                          parent_html = parent.get_attribute("outerHTML")
                                          if parent_html and "premium" in parent_html.lower():
                                              is_premium = True
                                              print(f"方法2 - 親要素のHTML: 有料放送")
                                  except Exception as e:
                                      print(f"方法2での有料判定中にエラー: {str(e)}")
                              
                              # 方法3: 要素自体のクラスに'premium'が含まれているか確認
                              if not is_premium:
                                  try:
                                      if hasattr(element, 'get_attribute'):
                                          element_class = element.get_attribute("class")
                                          if element_class and "premium" in element_class.lower():
                                              is_premium = True
                                              print(f"方法3 - 要素のクラス: 有料放送")
                                  except Exception as e:
                                      print(f"方法3での有料判定中にエラー: {str(e)}")
                              
                              # 方法4: JavaScriptを使用
                              if not is_premium:
                                  try:
                                      js_code = """
                                      let el = arguments[0];
                                      let html = el.outerHTML.toLowerCase();
                                      if (html.includes('premium')) return true;
                                      
                                      // 親要素のHTMLをチェック
                                      if (el.parentElement && el.parentElement.outerHTML.toLowerCase().includes('premium')) return true;
                                      
                                      // プレミアムアイコンを探す
                                      let premiumIcons = el.querySelectorAll('.premium-icon, img[src*="premium"], [class*="premium"]');
                                      if (premiumIcons.length > 0) return true;
                                      
                                      return false;
                                      """
                                      is_premium_js = driver.execute_script(js_code, element)
                                      if is_premium_js:
                                          is_premium = True
                                          print(f"方法4 - JavaScript: 有料放送")
                                  except Exception as e:
                                      print(f"方法4での有料判定中にエラー: {str(e)}")
                              
                              # 日付を取得（現在の日付を使用）
                              date = datetime.now().strftime("%Y%m%d")
                              
                              # エピソード情報を追加
                              episode = {
                                  "id": episode_id,
                                  "title": title,
                                  "date": date,
                                  "is_premium": is_premium,
                                  "url": href
                              }
                              
                              # 重複チェック
                              if not any(e["id"] == episode_id for e in episodes):
                                  episodes.append(episode)
                                  print(f"エピソード {i+1}: ID={episode_id}, タイトル={title[:30]}..., 有料={is_premium}")
                              
                              # 最大エピソード数に達したら終了
                              if len(episodes) >= MAX_EPISODES:
                                  break
                          except Exception as e:
                              print(f"エピソード要素 {i} の処理中にエラーが発生しました: {str(e)}")
                              traceback.print_exc()
                      
                      print(f"エピソード数: {len(episodes)}")
                      return episodes
                  finally:
                      # ブラウザを閉じる
                      driver.quit()
              except Exception as e:
                  print(f"エピソード一覧の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []
              
              print(f"::endgroup::")
              return []

          def get_direct_mp3_url(episode_id):
              """エピソードIDからMP3 URLを取得（v3互換）"""
              print(f"::group::MP3 URLを取得")
              print(f"エピソードID: {episode_id}")
              
              try:
                  # v3互換のURLパターン
                  # 複数のURLパターンを試す
                  url_patterns = [
                      # パターン1: 標準的なS3パス
                      f"https://voicy-prod.s3.amazonaws.com/uploads/broadcasting/{episode_id}/audio.mp3",
                      # パターン2: 別のS3パス形式
                      f"https://voicy-prod.s3.amazonaws.com/uploads/episode/{episode_id}/audio.mp3",
                      # パターン3: CDNパス
                      f"https://d2ybqfk9q8gh39.cloudfront.net/uploads/broadcasting/{episode_id}/audio.mp3",
                      # パターン4: 別のCDNパス
                      f"https://d2ybqfk9q8gh39.cloudfront.net/uploads/episode/{episode_id}/audio.mp3",
                      # パターン5: 新しいS3パス形式
                      f"https://voicy-prod.s3.amazonaws.com/uploads/channel/{CHANNEL_ID}/episode/{episode_id}/audio.mp3",
                      # パターン6: 別の新しいS3パス形式
                      f"https://voicy-prod.s3.amazonaws.com/uploads/channel/{CHANNEL_ID}/{episode_id}/audio.mp3"
                  ]
                  
                  # 各URLパターンを試す
                  for url in url_patterns:
                      print(f"URLパターンを試行中: {url}")
                      try:
                          # HEADリクエストでファイルの存在を確認
                          headers = {
                              "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                          }
                          head_response = requests.head(url, headers=headers, timeout=5)
                          if head_response.status_code == 200:
                              print(f"有効なMP3 URLが見つかりました: {url}")
                              print(f"::endgroup::")
                              return url
                      except Exception as e:
                          print(f"URLチェック中にエラー: {str(e)}")
                          continue
                  
                  # 直接エピソードページからURLを取得
                  try:
                      episode_url = f"https://voicy.jp/episode/{episode_id}"
                      print(f"エピソードページからURLを取得: {episode_url}")
                      
                      # User-Agentを設定
                      headers = {
                          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                      }
                      
                      # ページを取得
                      response = requests.get(episode_url, headers=headers, timeout=10)
                      if response.status_code == 200:
                          # ページのHTMLを解析
                          html_content = response.text
                          
                          # 正規表現でMP3/AACファイルのURLを探す（より広範なパターン）
                          mp3_patterns = [
                              # 標準的なMP3/AACファイルのURL
                              r'(https?://[^"\']+\.(mp3|aac))',
                              # JSON内のオーディオURL
                              r'"url":\s*"(https?://[^"]+\.(mp3|aac))"',
                              # src属性内のオーディオURL
                              r'src=["\'](https?://[^"\']+\.(mp3|aac))["\']',
                              # data-src属性内のオーディオURL
                              r'data-src=["\'](https?://[^"\']+\.(mp3|aac))["\']',
                              # audioタグ内のsourceタグのsrc属性
                              r'<audio[^>]*>.*?<source[^>]*src=["\'](https?://[^"\']+\.(mp3|aac))["\']'
                          ]
                          
                          for pattern in mp3_patterns:
                              matches = list(re.finditer(pattern, html_content, re.DOTALL))
                              if matches:
                                  # 最初のグループがURL全体、2番目のグループが拡張子の場合
                                  if '(' in pattern and ')' in pattern:
                                      audio_url = matches[0].group(1)
                                  else:
                                      audio_url = matches[0].group(0)
                                  print(f"ページから見つかったMP3 URL: {audio_url}")
                                  print(f"::endgroup::")
                                  return audio_url
                          
                          # JSON-LDからオーディオURLを探す
                          jsonld_pattern = r'<script type="application/ld\+json">(.*?)</script>'
                          jsonld_matches = list(re.finditer(jsonld_pattern, html_content, re.DOTALL))
                          for match in jsonld_matches:
                              try:
                                  jsonld_data = json.loads(match.group(1))
                                  if isinstance(jsonld_data, dict):
                                      # JSON-LDからオーディオURLを探す
                                      audio_url = None
                                      if 'audio' in jsonld_data:
                                          if isinstance(jsonld_data['audio'], dict) and 'contentUrl' in jsonld_data['audio']:
                                              audio_url = jsonld_data['audio']['contentUrl']
                                          elif isinstance(jsonld_data['audio'], list):
                                              for audio_item in jsonld_data['audio']:
                                                  if isinstance(audio_item, dict) and 'contentUrl' in audio_item:
                                                      audio_url = audio_item['contentUrl']
                                                      break
                                      
                                      if audio_url and (audio_url.endswith('.mp3') or audio_url.endswith('.aac')):
                                          print(f"JSON-LDから見つかったMP3 URL: {audio_url}")
                                          print(f"::endgroup::")
                                          return audio_url
                              except:
                                  pass
                  except Exception as e:
                      print(f"エピソードページからの取得中にエラー: {str(e)}")
                  
                  # チャンネルページからURLを取得
                  try:
                      channel_episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/episode/{episode_id}"
                      print(f"チャンネルエピソードページからURLを取得: {channel_episode_url}")
                      
                      # ページを取得
                      response = requests.get(channel_episode_url, headers=headers, timeout=10)
                      if response.status_code == 200:
                          # ページのHTMLを解析
                          html_content = response.text
                          
                          # 正規表現でMP3/AACファイルのURLを探す
                          mp3_pattern = re.compile(r'(https?://[^"\']+\.(mp3|aac))')
                          matches = list(mp3_pattern.finditer(html_content))
                          
                          if matches:
                              audio_url = matches[0].group(0)
                              print(f"チャンネルページから見つかったMP3 URL: {audio_url}")
                              print(f"::endgroup::")
                              return audio_url
                  except Exception as e:
                      print(f"チャンネルページからの取得中にエラー: {str(e)}")
                  
                  # v3互換のデフォルトURLを返す
                  default_url = f"https://voicy-prod.s3.amazonaws.com/uploads/broadcasting/{episode_id}/audio.mp3"
                  print(f"他の方法で見つからなかったため、デフォルトURLを使用: {default_url}")
                  print(f"::endgroup::")
                  return default_url
                  
              except Exception as e:
                  print(f"MP3 URL取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  # エラーが発生した場合はデフォルトのURLを返す
                  return f"https://voicy-prod.s3.amazonaws.com/uploads/broadcasting/{episode_id}/audio.mp3"

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # 直接MP3 URLを構築
                  audio_url = get_direct_mp3_url(episode_id)
                  print(f"オーディオURL: {audio_url}")
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"ファイルは既に存在します: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_filename
                  
                  # MP3ファイルをダウンロード
                  print(f"MP3ファイルをダウンロードします: {audio_url}")
                  if download_file(audio_url, mp3_path):
                      print(f"MP3ファイルのダウンロードに成功しました: {mp3_path}")
                      print(f"::endgroup::")
                      return mp3_filename
                  else:
                      print(f"MP3ファイルのダウンロードに失敗しました")
                      print(f"::endgroup::")
                      return None
              except Exception as e:
                  print(f"エピソードのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def save_episode_info_to_json(episodes, downloaded_files):
              """エピソード情報をJSONファイルに保存"""
              print(f"::group::エピソード情報のJSON保存")
              
              try:
                  # エピソード情報とダウンロードURLを含むデータを作成
                  episode_data = []
                  for episode, mp3_file in zip(episodes, downloaded_files):
                      if not mp3_file:
                          continue
                      
                      episode_info = {
                          "id": episode["id"],
                          "title": episode["title"],
                          "date": episode["date"],
                          "is_premium": episode["is_premium"],
                          "mp3_filename": mp3_file,
                          "mp3_url": f"https://paji.github.io/Spotify/podcast/{mp3_file}"
                      }
                      episode_data.append(episode_info)
                  
                  # JSONファイルに保存
                  json_path = os.path.join(DEBUG_DIR, "episode_info.json")
                  with open(json_path, "w", encoding="utf-8") as f:
                      json.dump(episode_data, f, ensure_ascii=False, indent=2)
                  
                  print(f"エピソード情報をJSONファイルに保存しました: {json_path}")
                  print(f"エピソード数: {len(episode_data)}")
                  print(f"::endgroup::")
                  return True
              except Exception as e:
                  print(f"エピソード情報のJSON保存中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return False

          def main():
              """メイン処理"""
              print(f"Voicy MP3ダウンローダー v4 開始")
              print(f"実行日時: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード一覧を取得
              episodes = get_episode_list()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードを処理します")
              
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # エピソード情報をJSONに保存
              save_episode_info_to_json(latest_episodes, downloaded_files)
              
              # ダウンロード結果を表示
              print("\nダウンロード結果:")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出
                  if mp3_file.startswith('_'):
                      # 有料放送: _タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 有料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 無料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                  
                  print(f"   ファイルサイズ: {file_size_mb:.2f}MB")
              
              # ダウンロードしたMP3ファイルをPodcastディレクトリにコピー
              for mp3_file in downloaded_files:
                  src_path = os.path.join(MP3_DIR, mp3_file)
                  dst_path = os.path.join(PODCAST_DIR, mp3_file)
                  
                  if os.path.exists(src_path):
                      try:
                          shutil.copy2(src_path, dst_path)
                          print(f"MP3ファイルをコピーしました: {src_path} -> {dst_path}")
                      except Exception as e:
                          print(f"MP3ファイルのコピー中にエラーが発生しました: {str(e)}")
                          traceback.print_exc()
              
              print(f"Voicy MP3ダウンローダー v4 終了")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v4.py
      
      - name: ダウンロードしたファイルを確認
        run: |
          echo "ダウンロードしたMP3ファイル:"
          ls -la mp3_downloads/
          echo "Podcastディレクトリのファイル:"
          ls -la docs/podcast/
          echo "デバッグファイル:"
          ls -la debug_files/
      
      - name: 変更をコミット
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git add docs/podcast/
          git commit -m "Update podcast files" || echo "No changes to commit"
          git push
