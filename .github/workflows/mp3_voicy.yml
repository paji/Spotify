name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
        with:
          repository: paji/Spotify
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p docs/podcast
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "docs/podcast"  # GitHubリポジトリのパス（gh-pagesブランチ内）
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegコマンドの実行に失敗しました")
                      print(f"標準出力: {result.stdout}")
                      print(f"標準エラー: {result.stderr}")
                      
                      # 方法2: 失敗した場合は、バイナリ結合を試みる
                      print("バイナリ結合を試みます...")
                      try:
                          with open(output_mp3_path, 'wb') as outfile:
                              for segment in mp3_segments:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          outfile.write(infile.read())
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"バイナリ結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              return True
                          else:
                              print("バイナリ結合に失敗しました")
                              return False
                      except Exception as e:
                          print(f"バイナリ結合中にエラーが発生しました: {str(e)}")
                          return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_segments(m3u8_url, episode_id, temp_dir=TEMP_DIR):
              """
              M3U8プレイリストからセグメントをダウンロードする関数
              
              Args:
                  m3u8_url: M3U8プレイリストのURL
                  episode_id: エピソードID
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  list: ダウンロードしたセグメントファイルのリスト
              """
              print(f"M3U8プレイリストをダウンロードします: {m3u8_url}")
              
              try:
                  # M3U8プレイリストをダウンロード
                  response = requests.get(m3u8_url, timeout=30)
                  if response.status_code != 200:
                      print(f"M3U8プレイリストのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      return []
                  
                  # M3U8プレイリストを解析
                  m3u8_content = response.text
                  
                  # デバッグ用にM3U8ファイルを保存
                  m3u8_debug_path = os.path.join(DEBUG_DIR, f"playlist_{episode_id}.m3u8")
                  with open(m3u8_debug_path, 'w') as f:
                      f.write(m3u8_content)
                  print(f"M3U8プレイリストをデバッグ用に保存しました: {m3u8_debug_path}")
                  
                  # セグメントURLを抽出
                  segment_urls = []
                  for line in m3u8_content.splitlines():
                      if line and not line.startswith('#'):
                          # 相対URLの場合は絶対URLに変換
                          if not line.startswith('http'):
                              base_url = m3u8_url.rsplit('/', 1)[0]
                              segment_url = f"{base_url}/{line}"
                          else:
                              segment_url = line
                          segment_urls.append(segment_url)
                  
                  print(f"セグメント数: {len(segment_urls)}")
                  if not segment_urls:
                      print("セグメントURLが見つかりませんでした")
                      return []
                  
                  # セグメントをダウンロード
                  mp3_segments = []
                  for i, segment_url in enumerate(segment_urls):
                      segment_path = os.path.join(temp_dir, f"segment_{episode_id}_{i:03d}.ts")
                      try:
                          print(f"セグメントをダウンロード中 ({i+1}/{len(segment_urls)}): {segment_url}")
                          segment_response = requests.get(segment_url, timeout=30)
                          if segment_response.status_code == 200:
                              with open(segment_path, 'wb') as f:
                                  f.write(segment_response.content)
                              mp3_segments.append(segment_path)
                          else:
                              print(f"セグメントのダウンロードに失敗しました: ステータスコード {segment_response.status_code}")
                      except Exception as e:
                          print(f"セグメントのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  print(f"ダウンロードしたセグメント数: {len(mp3_segments)}")
                  return mp3_segments
              
              except Exception as e:
                  print(f"M3U8セグメントのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return []

          def get_m3u8_url_from_episode(episode_url):
              """
              エピソードページからM3U8 URLを取得する関数
              
              Args:
                  episode_url: エピソードページのURL
              
              Returns:
                  tuple: (M3U8 URL, is_premium_content)
              """
              print(f"エピソードページにアクセスします: {episode_url}")
              is_premium_content = False
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  print(f"エピソードページにアクセスしました: {episode_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # ページのHTMLをデバッグ用に保存
                  episode_id = episode_url.split('/')[-1]
                  debug_html_path = f"{DEBUG_DIR}/episode_{episode_id}.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"エピソードページのHTMLを保存しました: {debug_html_path}")
                  
                  # JavaScriptを実行してネットワークリクエストを監視
                  driver.execute_script("""
                  // ネットワークリクエストを監視するための配列
                  window.m3u8Urls = [];
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXhrOpen = XMLHttpRequest.prototype.open;
                  XMLHttpRequest.prototype.open = function(method, url) {
                      if (url && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      }
                      return originalXhrOpen.apply(this, arguments);
                  };
                  
                  // fetchをオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function(url, options) {
                      if (url && typeof url === 'string' && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      } else if (url && typeof url === 'object' && url.url && url.url.includes('.m3u8')) {
                          window.m3u8Urls.push(url.url);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # 再生ボタンをクリック
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button.play-button, button[aria-label='再生'], [role='button'][aria-label='再生']"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                      time.sleep(5)  # リクエストが発生するのを待つ
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                  
                  # プレミアムコンテンツかどうかを確認（修正部分）
                  page_source = driver.page_source
                  if "こちらの放送はプレミアムリスナーの方のみ聴くことができます" in page_source or \
                     "※無料配信から1ヶ月が過ぎた過去配信は随時プレミアム放送となっています" in page_source or \
                     "premium=1" in episode_url:
                      print("これは有料配信（プレミアムコンテンツ）です")
                      is_premium_content = True
                  
                  # M3U8 URLを取得
                  m3u8_urls = driver.execute_script("return window.m3u8Urls;")
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  if m3u8_urls:
                      # 最後に検出されたM3U8 URLを使用
                      m3u8_url = m3u8_urls[-1]
                      print(f"M3U8 URLを見つけました: {m3u8_url}")
                      return m3u8_url, is_premium_content
                  else:
                      # ページソースからM3U8 URLを検索
                      print("JavaScriptによる検出に失敗しました。ページソースから検索します...")
                      
                      # Chromeドライバーを再初期化
                      driver = webdriver.Chrome(service=service, options=chrome_options)
                      driver.get(episode_url)
                      
                      # ページが完全に読み込まれるまで待機
                      WebDriverWait(driver, 10).until(
                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                      )
                      
                      # ページソースを取得
                      page_source = driver.page_source
                      
                      # プレミアムコンテンツかどうかを確認（修正部分）
                      if "こちらの放送はプレミアムリスナーの方のみ聴くことができます" in page_source or \
                         "※無料配信から1ヶ月が過ぎた過去配信は随時プレミアム放送となっています" in page_source or \
                         "premium=1" in episode_url:
                          print("これは有料配信（プレミアムコンテンツ）です")
                          is_premium_content = True
                      
                      driver.quit()
                      
                      # M3U8 URLを正規表現で検索
                      m3u8_pattern = r'https?://[^"\']+\.m3u8'
                      m3u8_matches = re.findall(m3u8_pattern, page_source)
                      
                      if m3u8_matches:
                          m3u8_url = m3u8_matches[0]
                          print(f"ページソースからM3U8 URLを見つけました: {m3u8_url}")
                          return m3u8_url, is_premium_content
                      else:
                          print("ページソースからM3U8 URLが見つかりませんでした")
                          return None, is_premium_content
              
              except Exception as e:
                  print(f"M3U8 URLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return None, is_premium_content

          def download_episode(episode_url, episode_id, episode_title, date_str):
              """
              エピソードをダウンロードする関数
              
              Args:
                  episode_url: エピソードページのURL
                  episode_id: エピソードID
                  episode_title: エピソードタイトル
                  date_str: 日付文字列
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              print(f"エピソードをダウンロードします: {episode_title} ({episode_id})")
              
              # ファイル名に使用できない文字を置換
              safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
              
              # M3U8 URLとプレミアムコンテンツ情報を取得
              m3u8_url, is_premium_content = get_m3u8_url_from_episode(episode_url)
              if not m3u8_url:
                  print(f"M3U8 URLの取得に失敗しました: {episode_url}")
                  return False
              
              # 有料配信の場合はファイル名の先頭にアンダースコアを付ける
              if is_premium_content:
                  output_mp3_path = f"{MP3_DIR}/_{date_str}_{safe_title}_{episode_id}.mp3"
                  print(f"有料配信のため、ファイル名の先頭にアンダースコアを付けました")
              else:
                  output_mp3_path = f"{MP3_DIR}/{date_str}_{safe_title}_{episode_id}.mp3"
              
              # 既に同じファイルが存在する場合はスキップ
              if os.path.exists(output_mp3_path):
                  print(f"ファイルが既に存在します。スキップします: {output_mp3_path}")
                  return True
              
              # M3U8セグメントをダウンロード
              mp3_segments = download_m3u8_segments(m3u8_url, episode_id)
              if not mp3_segments:
                  print(f"M3U8セグメントのダウンロードに失敗しました: {m3u8_url}")
                  return False
              
              # MP3ファイルを結合
              success = concat_mp3_files(mp3_segments, output_mp3_path)
              
              # 一時ファイルを削除
              for segment in mp3_segments:
                  if os.path.exists(segment):
                      os.remove(segment)
              
              return success

          def get_latest_episodes(channel_url, max_episodes=MAX_EPISODES):
              """
              チャンネルページから最新のエピソード情報を取得する関数
              
              Args:
                  channel_url: チャンネルページのURL
                  max_episodes: 取得する最大エピソード数
              
              Returns:
                  list: エピソード情報のリスト
              """
              print(f"チャンネルページから最新のエピソード情報を取得します: {channel_url}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(channel_url)
                  print(f"チャンネルページにアクセスしました: {channel_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # ページをスクロールして全てのエピソードを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # エピソード要素を取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, f"a[href*='/channel/{CHANNEL_ID}/']")
                  print(f"エピソード要素数: {len(episode_links)}")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and f"/channel/{CHANNEL_ID}/" in href:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title = link.text.strip()
                                  if not title:
                                      # リンクのテキストが空の場合は、親要素から探す
                                      try:
                                          parent_element = link.find_element(By.XPATH, "..")
                                          parent_parent_element = parent_element.find_element(By.XPATH, "..")
                                          title_elements = parent_parent_element.find_elements(By.TAG_NAME, "a")
                                          for elem in title_elements:
                                              if elem.text.strip():
                                                  title = elem.text.strip()
                                                  break
                                      except:
                                          pass
                                  
                                  # タイトルが見つからない場合はデフォルト値を使用
                                  if not title:
                                      title = f"エピソード {episode_id}"
                                  
                                  # 日付文字列を作成
                                  date_str = datetime.now().strftime('%Y%m%d')
                                  
                                  episodes.append({
                                      'episode_id': episode_id,
                                      'episode_url': href,
                                      'title': title,
                                      'date_str': date_str
                                  })
                                  print(f"エピソードを見つけました: ID={episode_id}, タイトル={title}")
                                  
                                  # 最大エピソード数に達したら終了
                                  if len(episodes) >= max_episodes:
                                      break
                  
                  driver.quit()
                  print(f"取得したエピソード数: {len(episodes)}")
                  return episodes
              
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  try:
                      driver.quit()
                  except:
                      pass
                  return []

          def main():
              """メイン関数"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # 最新のエピソード情報を取得
              episodes = get_latest_episodes(CHANNEL_URL)
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 各エピソードをダウンロード
              success_count = 0
              for episode in episodes:
                  try:
                      print(f"\n--- エピソード {episode['episode_id']} のダウンロードを開始します ---")
                      success = download_episode(
                          episode['episode_url'],
                          episode['episode_id'],
                          episode['title'],
                          episode['date_str']
                      )
                      
                      if success:
                          success_count += 1
                          print(f"エピソード {episode['episode_id']} のダウンロードに成功しました")
                      else:
                          print(f"エピソード {episode['episode_id']} のダウンロードに失敗しました")
                  
                  except Exception as e:
                      print(f"エピソード {episode['episode_id']} の処理中にエラーが発生しました: {str(e)}")
                      traceback.print_exc()
              
              print(f"\n合計: {len(episodes)}エピソード中{success_count}エピソードのダウンロードに成功しました")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: 変更をコミット
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add -A docs/podcast/
          git commit -m "Update Voicy MP3 files" || echo "No changes to commit"
          git push origin gh-pages
