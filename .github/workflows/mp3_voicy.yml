name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ
          CHANNEL_ALL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # 全エピソード一覧ページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_to_mp3(m3u8_url, mp3_path, episode_id):
              """m3u8からMP3をダウンロード"""
              print(f"::group::MP3ダウンロード")
              print(f"オーディオURLからMP3をダウンロード中: {m3u8_url}")
              print(f"出力先: {mp3_path}")
              
              try:
                  # URLの拡張子を確認
                  is_m3u8 = '.m3u8' in m3u8_url.lower()
                  is_mp3 = '.mp3' in m3u8_url.lower()
                  
                  # リクエストヘッダーを設定
                  headers = {
                      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                      "Referer": "https://voicy.jp/"
                  }
                  
                  # MP3の場合は直接ダウンロード
                  if is_mp3:
                      print(f"MP3ファイルを直接ダウンロードします")
                      try:
                          response = requests.get(m3u8_url, headers=headers, timeout=30)
                          if response.status_code == 200:
                              with open(mp3_path, 'wb') as f:
                                  f.write(response.content)
                              
                              if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                                  print(f"MP3ファイルのダウンロードに成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                  print(f"::endgroup::")
                                  return mp3_path
                              else:
                                  print(f"MP3ファイルが正常にダウンロードされませんでした")
                          else:
                              print(f"MP3ファイルのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      except Exception as e:
                          print(f"MP3ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  # m3u8ファイルの場合
                  if is_m3u8:
                      # m3u8ファイルの内容を取得
                      response = requests.get(m3u8_url, headers=headers, timeout=30)
                      if response.status_code != 200:
                          print(f"m3u8ファイルの取得に失敗しました: ステータスコード {response.status_code}")
                          print(f"::endgroup::")
                          return None
                      
                      m3u8_content = response.text
                      
                      # m3u8ファイルをデバッグ用に保存
                      m3u8_debug_path = f"{DEBUG_DIR}/playlist_{episode_id}.m3u8"
                      with open(m3u8_debug_path, 'w') as f:
                          f.write(m3u8_content)
                      print(f"m3u8ファイルを保存しました: {m3u8_debug_path}")
                      
                      # セグメントURLを抽出
                      segment_urls = []
                      base_url = '/'.join(m3u8_url.split('/')[:-1]) + '/'
                      
                      for line in m3u8_content.splitlines():
                          if not line.startswith('#') and line.strip():
                              if line.startswith('http'):
                                  segment_urls.append(line)
                              else:
                                  segment_urls.append(base_url + line)
                      
                      print(f"セグメント数: {len(segment_urls)}")
                      if not segment_urls:
                          print(f"セグメントURLが見つかりませんでした")
                          print(f"::endgroup::")
                          return None
                      
                      # セグメントをダウンロード - AACファイルとして保存（JSファイルの実装に合わせる）
                      segment_files = []
                      for i, url in enumerate(segment_urls):
                          segment_path = f"{TEMP_DIR}/segment_{i:03d}.aac"  # .ts から .aac に変更
                          try:
                              segment_response = requests.get(url, headers=headers, timeout=30)
                              if segment_response.status_code == 200:
                                  with open(segment_path, 'wb') as f:
                                      f.write(segment_response.content)
                                  segment_files.append(segment_path)
                              else:
                                  print(f"セグメント {i} のダウンロードに失敗: ステータスコード {segment_response.status_code}")
                          except Exception as e:
                              print(f"セグメント {i} のダウンロード中にエラー: {str(e)}")
                      
                      print(f"ダウンロードしたセグメント数: {len(segment_files)}")
                      
                      if not segment_files:
                          print(f"セグメントのダウンロードに失敗しました")
                          print(f"::endgroup::")
                          return None
                          
                      # JSファイルの実装に合わせて、直接バイナリ結合する方法を最初に試す
                      print("方法0: 直接バイナリ結合（JSファイルの実装に合わせる）")
                      try:
                          with open(mp3_path, 'wb') as outfile:
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          shutil.copyfileobj(infile, outfile)
                          
                          if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"方法0: MP3ファイルの作成に成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"方法0: MP3ファイルが正常に作成されませんでした")
                      except Exception as e:
                          print(f"方法0: MP3ファイルの作成中にエラーが発生しました: {str(e)}")
                      
                      # 方法1: FFmpegを使用してm3u8からMP3に直接変換
                      print("方法1: FFmpegを使用してm3u8からMP3に直接変換")
                      try:
                          cmd = [
                              'ffmpeg',
                              '-i', m3u8_url,
                              '-c:a', 'libmp3lame',
                              '-q:a', '2',
                              '-y',
                              mp3_path
                          ]
                          
                          print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                          result = subprocess.run(cmd, capture_output=True, text=True)
                          
                          if result.returncode == 0 and os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"方法1: MP3ファイルの作成に成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"方法1: MP3ファイルの作成に失敗しました: {result.stderr}")
                      except Exception as e:
                          print(f"方法1: MP3ファイルの作成中にエラーが発生しました: {str(e)}")
                      
                      # 方法2: FFmpegを使用してセグメントを結合
                      print("方法2: FFmpegを使用してセグメントを結合")
                      try:
                          # セグメントリストファイルを作成
                          segments_list = os.path.join(TEMP_DIR, "segments.txt")
                          with open(segments_list, 'w') as f:
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      # 絶対パスを使用し、エスケープ処理を追加
                                      segment_escaped = segment.replace('\\', '\\\\')
                                      segment_escaped = segment_escaped.replace("'", "\\'")
                                      segment_escaped = segment_escaped.replace(" ", "\\ ")
                                      f.write(f"file '{segment_escaped}'\n")
                          
                          cmd = [
                              'ffmpeg',
                              '-f', 'concat',
                              '-safe', '0',
                              '-i', segments_list,
                              '-c:a', 'libmp3lame',
                              '-q:a', '2',
                              '-y',
                              mp3_path
                          ]
                          
                          print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                          result = subprocess.run(cmd, capture_output=True, text=True)
                          
                          if result.returncode == 0 and os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"方法2: MP3ファイルの作成に成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"方法2: MP3ファイルの作成に失敗しました: {result.stderr}")
                      except Exception as e:
                          print(f"方法2: MP3ファイルの作成中にエラーが発生しました: {str(e)}")
                  
                  # URLが.m3u8や.mp3で終わらない場合（エピソードページURLなど）
                  if not is_m3u8 and not is_mp3:
                      print(f"URLが.m3u8や.mp3で終わらないため、m3u8 URLを推測します")
                      
                      # Voicyの一般的なパターンからm3u8 URLを推測
                      potential_urls = [
                          f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/episodes/{episode_id}/playlist.m3u8",
                          f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/episodes/{episode_id}/master.m3u8",
                          f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/{episode_id}/playlist.m3u8",
                          f"https://cdn-podcast.voicy.jp/episodes/{episode_id}/playlist.m3u8"
                      ]
                      
                      for url in potential_urls:
                          try:
                              print(f"推測したm3u8 URLを試行: {url}")
                              response = requests.head(url, headers=headers, timeout=5)
                              if response.status_code == 200:
                                  print(f"推測したm3u8 URLが有効です: {url}")
                                  # 有効なURLが見つかったら、再帰的に処理
                                  return download_m3u8_to_mp3(url, mp3_path, episode_id)
                          except Exception as e:
                              print(f"推測したURLの確認中にエラー: {str(e)}")
                      
                      print(f"有効なオーディオURLが見つかりませんでした")
                  
                  print(f"MP3ファイルの作成に失敗しました")
                  print(f"::endgroup::")
                  return None
              except Exception as e:
                  print(f"MP3ダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def get_episode_list():
              """エピソード一覧を取得"""
              print(f"::group::エピソード一覧取得")
              print(f"チャンネルURL: {CHANNEL_ALL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(CHANNEL_ALL_URL)
                  print(f"チャンネルページにアクセスしました: {CHANNEL_ALL_URL}")
                  
                  # ページが完全に読み込まれるまで待機（待機時間を20秒に増加）
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ページをスクロールして全てのコンテンツを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # ページのHTMLをデバッグ用に保存
                  debug_html_path = f"{DEBUG_DIR}/channel_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"チャンネルページのHTMLを保存しました: {debug_html_path}")
                  
                  # エピソードリンクを取得（CSSセレクタを修正）
                  episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and "/channel/" in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, "./..")
                                      title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  title = title_element.text if title_element else f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, "time, .date, .episode-date")
                                      date_str = date_element.text
                                  except:
                                      # 日付が見つからない場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  # 日付文字列から日付オブジェクトを作成
                                  try:
                                      # 様々な日付形式に対応
                                      date_formats = [
                                          "%Y-%m-%d",
                                          "%Y年%m月%d日",
                                          "%Y/%m/%d",
                                          "%m月%d日",  # 年がない場合は現在の年を使用
                                          "%m/%d",     # 年がない場合は現在の年を使用
                                      ]
                                      
                                      episode_date = None
                                      for date_format in date_formats:
                                          try:
                                              if "年" in date_str and date_format == "%m月%d日":
                                                  # 「2023年3月1日」のような形式
                                                  continue
                                              
                                              if "月" in date_str and "年" not in date_str and date_format == "%m月%d日":
                                                  # 「3月1日」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              elif "/" in date_str and len(date_str.split("/")) == 2 and date_format == "%m/%d":
                                                  # 「3/1」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              else:
                                                  episode_date = datetime.strptime(date_str, date_format)
                                                  break
                                          except ValueError:
                                              continue
                                      
                                      if episode_date is None:
                                          # どの形式にも合致しない場合は現在の日付を使用
                                          episode_date = datetime.now()
                                      
                                      # YYYYMMDD形式に変換
                                      episode_date_str = episode_date.strftime("%Y%m%d")
                                  except Exception as e:
                                      # 日付の解析に失敗した場合は現在の日付を使用
                                      episode_date_str = datetime.now().strftime("%Y%m%d")
                                  
                                  # 有料放送かどうかを判定（親要素内にpremiumクラスがあるか）
                                  is_premium = False
                                  try:
                                      premium_element = parent.find_element(By.CSS_SELECTOR, ".premium, .premiumEpisode, .premiumContent")
                                      is_premium = True
                                  except:
                                      pass
                                  
                                  episodes.append({
                                      "id": episode_id,
                                      "title": title,
                                      "date": episode_date_str,
                                      "is_premium": is_premium,
                                      "url": f"https://voicy.jp/episode/{episode_id}"
                                  })
                  
                  # ドライバーを閉じる
                  driver.quit()
                  
                  # エピソード情報をデバッグ用に保存
                  with open(f"{DEBUG_DIR}/episodes.json", 'w', encoding='utf-8') as f:
                      json.dump(episodes, f, ensure_ascii=False, indent=2)
                  
                  print(f"エピソード一覧を取得しました: {len(episodes)}件")
                  print(f"::endgroup::")
                  return episodes
              except Exception as e:
                  print(f"エピソード一覧の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def get_direct_mp3_url(episode_id):
              """エピソードの直接MP3 URLを取得"""
              print(f"エピソード {episode_id} のオーディオURLを推測します")
              
              # Voicyの一般的なパターンからm3u8 URLを推測
              potential_urls = [
                  f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/episodes/{episode_id}/playlist.m3u8",
                  f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/episodes/{episode_id}/master.m3u8",
                  f"https://cdn-podcast.voicy.jp/podcast/{CHANNEL_ID}/{episode_id}/playlist.m3u8",
                  f"https://cdn-podcast.voicy.jp/episodes/{episode_id}/playlist.m3u8"
              ]
              
              headers = {
                  "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                  "Referer": "https://voicy.jp/"
              }
              
              for url in potential_urls:
                  try:
                      print(f"推測したm3u8 URLを確認: {url}")
                      response = requests.head(url, headers=headers, timeout=5)
                      if response.status_code == 200:
                          print(f"有効なm3u8 URLを見つけました: {url}")
                          return url
                  except Exception as e:
                      print(f"URLの確認中にエラー: {str(e)}")
              
              # 推測したURLが見つからない場合は、エピソードページのURLを返す
              # download_m3u8_to_mp3関数内で別の方法を試行する
              return f"https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}"

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # 直接MP3 URLを取得
                  audio_url = get_direct_mp3_url(episode_id)
                  if not audio_url:
                      print(f"エピソード {episode_id} のオーディオURLが取得できませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_path
                  
                  # MP3をダウンロード
                  mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
                  
                  if mp3_file:
                      print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_path}")
                      print(f"::endgroup::")
                      return mp3_path
                  else:
                      print(f"エピソード {episode_id} のダウンロードに失敗しました")
              except Exception as e:
                  print(f"エピソード {episode_id} のダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def main():
              """メイン関数"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード一覧を取得
              episodes = get_episode_list()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードを処理します")
              
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # ダウンロード結果を表示
              print("\nダウンロード結果:")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出
                  if mp3_file.startswith('_'):
                      # 有料放送: _タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 有料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB")
                      else:
                          print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 無料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB")
                      else:
                          print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
              
              print(f"合計: {len(mp3_files)}個のMP3ファイル")
              print("Voicy MP3ダウンローダーを終了します")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルをdocsディレクトリにコピー
        run: |
          mkdir -p mp3_downloads
          find mp3_downloads -name "*.mp3" > mp3_files.txt
          
          echo "MP3ファイル一覧:"
          cat mp3_files.txt
          
          # docsディレクトリを作成
          mkdir -p docs/podcast
          
          # MP3ファイルをコピー
          if [ -s mp3_files.txt ]; then
            while IFS= read -r file
            do
              echo "コピー: $file -> docs/podcast/"
              cp -v "$file" docs/podcast/
            done < mp3_files.txt
          else
            echo "MP3ファイルが見つかりませんでした"
          fi
      
      - name: AAC形式からMP3形式への変換スクリプトを作成
        run: |
          cat > scripts/convert_aac_to_mp3.py << 'EOF'
          import os
          import subprocess
          import sys

          def convert_aac_to_mp3(aac_file, mp3_file):
              """AAC形式のファイルをMP3形式に変換する"""
              cmd = [
                  'ffmpeg',
                  '-i', aac_file,
                  '-c:a', 'libmp3lame',
                  '-q:a', '2',
                  '-y',
                  mp3_file
              ]
              
              print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
              result = subprocess.run(cmd, capture_output=True, text=True)
              
              if result.returncode == 0:
                  print(f"変換成功: {aac_file} -> {mp3_file}")
                  return True
              else:
                  print(f"変換失敗: {result.stderr}")
                  return False

          def main():
              if len(sys.argv) < 3:
                  print("使用方法: python convert_aac_to_mp3.py <AAC入力ファイル> <MP3出力ファイル>")
                  return
              
              aac_file = sys.argv[1]
              mp3_file = sys.argv[2]
              
              if not os.path.exists(aac_file):
                  print(f"入力ファイルが見つかりません: {aac_file}")
                  return
              
              convert_aac_to_mp3(aac_file, mp3_file)

          if __name__ == "__main__":
              main()
          EOF
      
      - name: GitHubリポジトリにMP3ファイルをプッシュ
        run: |
          # gh-pagesブランチをチェックアウト
          git checkout -b gh-pages
          
          # docsディレクトリの内容をコミット
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git add docs/podcast/*.mp3
          
          # 変更があるか確認してからコミット
          if git diff --staged --quiet; then
            echo "変更はありません"
          else
            git commit -m "MP3ファイルを更新 [skip ci]"
            git push -f origin gh-pages
          fi
