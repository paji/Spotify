name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
        with:
          ref: gh-pages  # gh-pagesブランチを使用
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
          mkdir -p docs/podcast
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v4.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ
          CHANNEL_ALL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # すべての放送ページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"
          PODCAST_DIR = "docs/podcast"  # GitHub Pagesで公開するディレクトリ

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR, PODCAST_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          # ACCファイルをMP3に変換する関数
          def convert_acc_to_mp3(acc_file, mp3_file):
              """
              ACCファイルをMP3に変換する関数
              
              Args:
                  acc_file: 入力ACCファイルパス
                  mp3_file: 出力MP3ファイルパス
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              try:
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-i', acc_file,
                      '-acodec', 'libmp3lame',
                      '-ab', '192k',
                      '-y',
                      mp3_file
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"ACCファイルをMP3に変換しました: {mp3_file}")
                      return True
                  else:
                      print(f"ACCファイルの変換に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"ACCファイルの変換中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          # ファイルをダウンロードする関数
          def download_file(url, output_path, chunk_size=8192):
              """
              ファイルをダウンロードする関数
              
              Args:
                  url: ダウンロードするファイルのURL
                  output_path: 保存先のパス
                  chunk_size: ダウンロードチャンクサイズ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              try:
                  response = requests.get(url, stream=True)
                  response.raise_for_status()
                  
                  with open(output_path, 'wb') as f:
                      for chunk in response.iter_content(chunk_size=chunk_size):
                          if chunk:
                              f.write(chunk)
                  
                  if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                      file_size_mb = os.path.getsize(output_path) / (1024 * 1024)
                      print(f"ファイルをダウンロードしました: {output_path} (サイズ: {file_size_mb:.2f}MB)")
                      return True
                  else:
                      print(f"ダウンロードしたファイルが正常に保存されませんでした: {output_path}")
                      return False
              except Exception as e:
                  print(f"ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def get_episode_list():
              """エピソード一覧を取得"""
              print(f"::group::エピソード一覧取得")
              print(f"チャンネルURL: {CHANNEL_ALL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # すべての放送ページに直接アクセス
                  driver.get(CHANNEL_ALL_URL)
                  print(f"チャンネルページにアクセスしました: {CHANNEL_ALL_URL}")
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # デバッグ用にHTMLを保存
                  html_content = driver.page_source
                  debug_html_path = os.path.join(DEBUG_DIR, "episode_list.html")
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(html_content)
                  print(f"デバッグ用にHTMLを保存しました: {debug_html_path}")
                  
                  # エピソード要素を取得
                  episode_elements = driver.find_elements(By.CSS_SELECTOR, "a[href*='/episode/']")
                  print(f"エピソード要素数: {len(episode_elements)}")
                  
                  if not episode_elements:
                      print("エピソード要素が見つかりません。詳細なデバッグ情報:")
                      print(f"現在のURL: {driver.current_url}")
                      print(f"ページタイトル: {driver.title}")
                      print(f"ページソースの一部: {html_content[:500]}...")
                      
                      # 別の方法でエピソード要素を探す
                      print("別の方法でエピソード要素を探します...")
                      broadcasting_items = driver.find_elements(By.CSS_SELECTOR, ".broadcasting-item")
                      print(f"放送アイテム数: {len(broadcasting_items)}")
                      
                      # 各放送アイテムからエピソードリンクを探す
                      for i, item in enumerate(broadcasting_items[:5]):  # 最初の5つだけ確認
                          print(f"放送アイテム {i+1}:")
                          print(f"HTML: {item.get_attribute('outerHTML')}")
                          links = item.find_elements(By.TAG_NAME, "a")
                          for link in links:
                              href = link.get_attribute("href")
                              if href and "/episode/" in href:
                                  print(f"エピソードリンク: {href}")
                  
                  # エピソード情報を収集
                  episodes = []
                  for i, element in enumerate(episode_elements[:MAX_EPISODES * 2]):  # 余分に取得して有料放送をフィルタリング
                      try:
                          href = element.get_attribute("href")
                          title = element.text.strip()
                          
                          # エピソードIDを抽出
                          episode_id_match = re.search(r"/episode/(\d+)", href)
                          if not episode_id_match:
                              continue
                          episode_id = episode_id_match.group(1)
                          
                          # 親要素を取得して有料放送かどうかを判定
                          parent_element = element
                          for _ in range(5):  # 最大5階層まで親を辿る
                              parent_element = driver.execute_script("return arguments[0].parentNode;", parent_element)
                              if parent_element.get_attribute("class") and "broadcasting-item" in parent_element.get_attribute("class"):
                                  break
                          
                          # 有料放送の判定（複数の方法を組み合わせる）
                          is_premium = False
                          
                          # 方法1: プレミアムアイコンの検出
                          premium_icon = parent_element.find_elements(By.CSS_SELECTOR, ".premium-icon, img[src*='premium']")
                          if premium_icon:
                              is_premium = True
                              print(f"プレミアムアイコンを検出: {title}")
                          
                          # 方法2: HTMLに'premium'文字列が含まれるか
                          html = parent_element.get_attribute("outerHTML")
                          if "premium" in html.lower():
                              is_premium = True
                              print(f"premium文字列を検出: {title}")
                          
                          # 日付情報を取得（存在する場合）
                          date_element = parent_element.find_elements(By.CSS_SELECTOR, ".date, .time")
                          date_str = date_element[0].text if date_element else datetime.now().strftime("%Y%m%d")
                          
                          # 日付を整形
                          date_str = re.sub(r'[年月日]', '', date_str)
                          date_str = re.sub(r'\s+', '_', date_str)
                          
                          episodes.append({
                              "id": episode_id,
                              "title": title,
                              "url": href,
                              "date": date_str,
                              "is_premium": is_premium
                          })
                          
                          print(f"エピソード {i+1}:")
                          print(f"  ID: {episode_id}")
                          print(f"  タイトル: {title}")
                          print(f"  URL: {href}")
                          print(f"  日付: {date_str}")
                          print(f"  有料放送: {'はい' if is_premium else 'いいえ'}")
                      except Exception as e:
                          print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                          traceback.print_exc()
                  
                  driver.quit()
                  
                  # エピソード数を確認
                  print(f"エピソード数: {len(episodes)}")
                  if not episodes:
                      print("エピソードが見つかりませんでした")
                      print(f"::endgroup::")
                      return []
                  
                  # 最新のエピソードを返す
                  return episodes[:MAX_EPISODES]
              except Exception as e:
                  print(f"エピソード一覧の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []
              finally:
                  print(f"::endgroup::")

          def get_direct_mp3_url(episode_id):
              """エピソードIDから直接MP3 URLを構築"""
              # Voicyの音声ファイルはS3バケットに保存されている
              # URLパターン: https://voicy-prod.s3.amazonaws.com/uploads/broadcasting/{episode_id}/audio.mp3
              return f"https://voicy-prod.s3.amazonaws.com/uploads/broadcasting/{episode_id}/audio.mp3"

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # 直接MP3 URLを構築
                  audio_url = get_direct_mp3_url(episode_id)
                  print(f"オーディオURL: {audio_url}")
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"ファイルは既に存在します: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_filename
                  
                  # MP3ファイルをダウンロード
                  if download_file(audio_url, mp3_path):
                      # ファイルサイズを確認
                      if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                          file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                          print(f"MP3ファイルをダウンロードしました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          print(f"::endgroup::")
                          return mp3_filename
                      else:
                          print(f"ダウンロードしたMP3ファイルが正常に保存されませんでした: {mp3_path}")
                  
                  print(f"MP3ファイルのダウンロードに失敗しました")
                  print(f"::endgroup::")
                  return None
              except Exception as e:
                  print(f"エピソードのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def save_episode_info_to_json(episodes, downloaded_files):
              """エピソード情報をJSONファイルに保存"""
              print(f"::group::エピソード情報のJSON保存")
              
              try:
                  # エピソード情報とダウンロードURLを含むデータを作成
                  episode_data = []
                  for episode, mp3_file in zip(episodes, downloaded_files):
                      if not mp3_file:
                          continue
                      
                      episode_info = {
                          "id": episode["id"],
                          "title": episode["title"],
                          "date": episode["date"],
                          "is_premium": episode["is_premium"],
                          "mp3_filename": mp3_file,
                          "mp3_url": f"https://paji.github.io/Spotify/podcast/{mp3_file}"
                      }
                      episode_data.append(episode_info)
                  
                  # JSONファイルに保存
                  json_path = os.path.join(DEBUG_DIR, "episode_info.json")
                  with open(json_path, "w", encoding="utf-8") as f:
                      json.dump(episode_data, f, ensure_ascii=False, indent=2)
                  
                  print(f"エピソード情報をJSONファイルに保存しました: {json_path}")
                  print(f"::endgroup::")
                  return True
              except Exception as e:
                  print(f"エピソード情報のJSON保存中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return False

          def main():
              """メイン処理"""
              print(f"Voicy MP3ダウンローダー v4 開始")
              start_time = time.time()
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード一覧を取得
              episodes = get_episode_list()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードを処理します")
              
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # エピソード情報をJSONに保存
              save_episode_info_to_json(latest_episodes, downloaded_files)
              
              # ダウンロード結果を表示
              print("\nダウンロード結果:")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出
                  if mp3_file.startswith('_'):
                      # 有料放送: _タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 有料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 無料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                  
                  print(f"   ファイルサイズ: {file_size_mb:.2f}MB")
              
              # ダウンロードしたMP3ファイルをPodcastディレクトリにコピー
              for mp3_file in downloaded_files:
                  src_path = os.path.join(MP3_DIR, mp3_file)
                  dst_path = os.path.join(PODCAST_DIR, mp3_file)
                  
                  if os.path.exists(src_path):
                      shutil.copy2(src_path, dst_path)
                      print(f"MP3ファイルをコピーしました: {dst_path}")
              
              # 処理時間を表示
              end_time = time.time()
              elapsed_time = end_time - start_time
              print(f"\n処理時間: {elapsed_time:.2f}秒")
              print(f"Voicy MP3ダウンローダー v4 終了")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v4.py
      
      - name: ダウンロードしたMP3ファイルを確認
        run: |
          echo "ダウンロードしたMP3ファイル:"
          ls -la mp3_downloads/
          
          echo "Podcastディレクトリ:"
          ls -la docs/podcast/
          
          echo "デバッグファイル:"
          ls -la debug_files/
          
          # JSONファイルの内容を表示
          if [ -f debug_files/episode_info.json ]; then
            echo "エピソード情報JSON:"
            cat debug_files/episode_info.json
          fi
      
      - name: 変更をコミット
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git add docs/podcast/
          git commit -m "Update podcast MP3 files" || echo "No changes to commit"
          git push origin gh-pages || echo "No changes to push"
