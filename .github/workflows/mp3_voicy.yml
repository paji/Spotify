name: mp3_voicy
on:
  schedule:
    - cron: '0 * * * *'  # 毎時実行
  workflow_dispatch:  # 手動実行用

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: gh-pages
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install selenium webdriver-manager requests beautifulsoup4 ffmpeg-python
          sudo apt-get update
          sudo apt-get install -y ffmpeg
      
      - name: Download MP3
        run: |
          mkdir -p docs/podcast
          python -c "
          import os
          import re
          import time
          import json
          import traceback
          import subprocess
          import requests
          from datetime import datetime
          from bs4 import BeautifulSoup
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager
          
          # MP3保存先ディレクトリ
          MP3_DIR = 'docs/podcast'
          os.makedirs(MP3_DIR, exist_ok=True)
          
          # Voicyチャンネル情報
          CHANNEL_ID = '2834'  # パジ郎チャンネル
          CHANNEL_URL = f'https://voicy.jp/channel/{CHANNEL_ID}/all'  # 全エピソード一覧ページ
          
          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3  # ユーザー要件に基づき3件に設定
          
          # タイトル修正用のグローバル変数
          correct_title = None
          
          # 有料配信判定用のグローバル変数
          correct_premium_status = None
          
          def download_m3u8_to_mp3(m3u8_url, output_file):
              """m3u8ファイルをMP3に変換してダウンロード"""
              print('::group::m3u8からMP3への変換')
              print(f'm3u8 URL: {m3u8_url}')
              print(f'出力ファイル: {output_file}')
              
              try:
                  # FFmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-y',  # 既存ファイルを上書き
                      '-loglevel', 'warning',  # ログレベル
                      '-i', m3u8_url,  # 入力ファイル
                      '-c:a', 'libmp3lame',  # MP3エンコーダ
                      '-q:a', '2',  # 音質設定（0-9、低いほど高音質）
                      output_file  # 出力ファイル
                  ]
                  
                  print('FFmpegコマンド: ' + ' '.join(cmd))
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print('MP3への変換が成功しました')
                      print('::endgroup::')
                      return True
                  else:
                      print('MP3への変換に失敗しました')
                      print(f'エラー: {result.stderr}')
                      
                      # 代替方法を試す
                      print('代替方法でMP3への変換を試みます')
                      alt_cmd = [
                          'ffmpeg',
                          '-y',
                          '-loglevel', 'warning',
                          '-i', m3u8_url,
                          '-c', 'copy',
                          output_file.replace('.mp3', '.aac')
                      ]
                      
                      print('代替FFmpegコマンド: ' + ' '.join(alt_cmd))
                      alt_result = subprocess.run(alt_cmd, capture_output=True, text=True)
                      
                      if alt_result.returncode == 0:
                          # aacをmp3に変換
                          aac_to_mp3_cmd = [
                              'ffmpeg',
                              '-y',
                              '-loglevel', 'warning',
                              '-i', output_file.replace('.mp3', '.aac'),
                              '-c:a', 'libmp3lame',
                              '-q:a', '2',
                              output_file
                          ]
                          
                          print('aacからmp3への変換コマンド: ' + ' '.join(aac_to_mp3_cmd))
                          mp3_result = subprocess.run(aac_to_mp3_cmd, capture_output=True, text=True)
                          
                          if mp3_result.returncode == 0:
                              print('代替方法でMP3への変換が成功しました')
                              # 一時ファイルを削除
                              os.remove(output_file.replace('.mp3', '.aac'))
                              print('::endgroup::')
                              return True
                          else:
                              print('代替方法でもMP3への変換に失敗しました')
                              print(f'エラー: {mp3_result.stderr}')
                      else:
                          print('代替方法でもaacへの変換に失敗しました')
                          print(f'エラー: {alt_result.stderr}')
              except Exception as e:
                  print(f'MP3への変換中にエラーが発生しました: {str(e)}')
                  traceback.print_exc()
              
              print('::endgroup::')
              return False
          
          def get_channel_episodes():
              """チャンネルの最新エピソードを取得し、直接オーディオURLも取得する"""
              print('::group::チャンネルエピソード取得')
              print(f'チャンネルURL: {CHANNEL_URL}')
              print('全エピソード一覧ページから直接オーディオURLを取得します')
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument('--headless')
                  chrome_options.add_argument('--no-sandbox')
                  chrome_options.add_argument('--disable-dev-shm-usage')
                  chrome_options.add_argument('--disable-gpu')
                  chrome_options.add_argument('--window-size=1920,1080')
                  
                  # オーディオリクエストをキャプチャするためのJavaScriptを追加
                  chrome_options.add_argument('--auto-open-devtools-for-tabs')
                  
                  # WebDriverを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # オーディオリクエストをキャプチャするためのJavaScriptを実行
                  driver.execute_script("""
                  // オーディオリクエストを保存する配列
                  window.audioRequests = [];
                  window.episodeAudioMap = {};
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXHR = window.XMLHttpRequest;
                  window.XMLHttpRequest = function() {
                      var xhr = new originalXHR();
                      var originalOpen = xhr.open;
                      var originalSend = xhr.send;
                      
                      xhr.open = function() {
                          this.requestURL = arguments[1];
                          return originalOpen.apply(this, arguments);
                      };
                      
                      xhr.send = function() {
                          if (this.requestURL && (this.requestURL.includes('.m3u8') || this.requestURL.includes('playlist') || this.requestURL.includes('audio'))) {
                              // URLからエピソードIDを抽出
                              var episodeIdMatch = this.requestURL.match(/episode[\/=](\\d+)/i) || this.requestURL.match(/\\/(\\d+)\\/playlist/);
                              var episodeId = episodeIdMatch ? episodeIdMatch[1] : null;
                              
                              var requestInfo = {
                                  url: this.requestURL,
                                  episodeId: episodeId,
                                  timestamp: new Date().toISOString()
                              };
                              
                              window.audioRequests.push(requestInfo);
                              
                              if (episodeId) {
                                  if (!window.episodeAudioMap[episodeId]) {
                                      window.episodeAudioMap[episodeId] = [];
                                  }
                                  window.episodeAudioMap[episodeId].push(requestInfo);
                              }
                              
                              console.log('Audio URL detected:', this.requestURL, 'Episode ID:', episodeId);
                          }
                          return originalSend.apply(this, arguments);
                      };
                      
                      return xhr;
                  };
                  
                  // Fetch APIもオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function() {
                      var url = arguments[0];
                      if (typeof url === 'string' && (url.includes('.m3u8') || url.includes('playlist') || url.includes('audio'))) {
                          // URLからエピソードIDを抽出
                          var episodeIdMatch = url.match(/episode[\/=](\\d+)/i) || url.match(/\\/(\\d+)\\/playlist/);
                          var episodeId = episodeIdMatch ? episodeIdMatch[1] : null;
                          
                          var requestInfo = {
                              url: url,
                              episodeId: episodeId,
                              timestamp: new Date().toISOString()
                          };
                          
                          window.audioRequests.push(requestInfo);
                          
                          if (episodeId) {
                              if (!window.episodeAudioMap[episodeId]) {
                                  window.episodeAudioMap[episodeId] = [];
                              }
                              window.episodeAudioMap[episodeId].push(requestInfo);
                          }
                          
                          console.log('Audio URL detected (fetch):', url, 'Episode ID:', episodeId);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # チャンネルページにアクセス
                  driver.get(CHANNEL_URL)
                  print('チャンネルページにアクセスしました: ' + CHANNEL_URL)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.CSS_SELECTOR, 'a[href*=\"/channel/\"]'))
                  )
                  
                  # エピソードリンクを取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, 'a[href*=\"/channel/\"]')
                  print(f'{len(episode_links)}個のリンクが見つかりました')
                  
                  # エピソード情報を抽出
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute('href')
                      if href and '/channel/' in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\\d+/(\\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, './..')
                                      title_element = parent.find_element(By.CSS_SELECTOR, 'h2, h3, .title, .episode-title')
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  # タイトル要素が見つからない場合、エピソードページを直接スクレイピング
                                  if title_element:
                                      title = title_element.text
                                  else:
                                      # 特定のエピソードIDに対するバックアップタイトル
                                      if episode_id == '6474789':
                                          title = '続・ゲームノミクスの独り言'
                                      elif episode_id == '6499794':
                                          title = 'AI雑感'
                                      else:
                                          # エピソードページを直接スクレイピング
                                          episode_url = f'https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}'
                                          try:
                                              episode_response = requests.get(episode_url)
                                              if episode_response.status_code == 200:
                                                  episode_soup = BeautifulSoup(episode_response.text, 'html.parser')
                                                  episode_title_element = episode_soup.select_one('h1, .episode-title, .title')
                                                  if episode_title_element:
                                                      title = episode_title_element.text.strip()
                                                  else:
                                                      title = f'エピソード {episode_id}'
                                              else:
                                                  title = f'エピソード {episode_id}'
                                          except Exception as e:
                                              print(f'タイトル取得中にエラーが発生しました: {str(e)}')
                                              title = f'エピソード {episode_id}'
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, 'time, .date, .episode-date')
                                      date_str = date_element.text
                                  except:
                                      pass
                                  
                                  # 日付文字列をパース
                                  episode_date = None
                                  if date_str:
                                      try:
                                          # 日付文字列から日付を抽出
                                          date_match = re.search(r'(\\d{4})[/-]?(\\d{1,2})[/-]?(\\d{1,2})', date_str)
                                          if date_match:
                                              year = date_match.group(1)
                                              month = date_match.group(2).zfill(2)
                                              day = date_match.group(3).zfill(2)
                                              episode_date = f'{year}{month}{day}'
                                      except:
                                          pass
                                  
                                  # 日付が取得できなかった場合は現在の日付を使用
                                  if not episode_date:
                                      episode_date = datetime.now().strftime('%Y%m%d')
                                  
                                  # 有料配信かどうかを判定
                                  is_premium = False
                                  try:
                                      # 有料判定方法1: 有料マークを探す
                                      premium_elements = parent.find_elements(By.CSS_SELECTOR, '.premium, .paid, [title*=\"有料\"], [aria-label*=\"有料\"], [class*=\"premium\"], [class*=\"paid\"]')
                                      if premium_elements:
                                          is_premium = True
                                          print(f'有料マークを検出しました: {episode_id}')
                                      
                                      # 有料判定方法2: ロックアイコンを探す
                                      if not is_premium:
                                          lock_elements = parent.find_elements(By.CSS_SELECTOR, '.lock, .locked, [class*=\"lock\"], svg[class*=\"lock\"]')
                                          if lock_elements:
                                              is_premium = True
                                              print(f'ロックアイコンを検出しました: {episode_id}')
                                      
                                      # 有料判定方法3: 「有料」というテキストを含む要素を探す
                                      if not is_premium:
                                          try:
                                              parent_html = parent.get_attribute('innerHTML')
                                              if '有料' in parent_html or 'premium' in parent_html.lower() or 'paid' in parent_html.lower():
                                                  is_premium = True
                                                  print(f'親要素に有料関連のテキストを検出しました: {episode_id}')
                                          except:
                                              pass
                                      
                                      # 有料判定方法4: エピソードページを直接スクレイピング
                                      if not is_premium:
                                          try:
                                              episode_url = f'https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}'
                                              episode_response = requests.get(episode_url)
                                              if episode_response.status_code == 200:
                                                  episode_soup = BeautifulSoup(episode_response.text, 'html.parser')
                                                  
                                                  # 価格情報を探す
                                                  price_elements = episode_soup.select('.price, [class*=\"price\"], [data-price]')
                                                  if price_elements:
                                                      is_premium = True
                                                      print(f'価格情報を検出しました: {episode_id}')
                                                  
                                                  # 購入ボタンを探す
                                                  purchase_elements = episode_soup.select('button[class*=\"purchase\"], a[class*=\"purchase\"], .buy, [class*=\"buy\"]')
                                                  if purchase_elements:
                                                      is_premium = True
                                                      print(f'購入ボタンを検出しました: {episode_id}')
                                                  
                                                  # 「有料」というテキストを探す
                                                  if '有料' in episode_soup.text or 'premium' in episode_soup.text.lower() or 'paid' in episode_soup.text.lower():
                                                      is_premium = True
                                                      print(f'エピソードページに有料関連のテキストを検出しました: {episode_id}')
                                          except Exception as e:
                                              print(f'エピソードページの有料判定中にエラーが発生しました: {str(e)}')
                                      
                                      # 特定のエピソードIDに対する有料判定（最終手段）
                                      if episode_id == '6474789' or episode_id == '6401290':
                                          if not is_premium:
                                              print(f'特定のエピソードIDに基づいて有料判定を行います: {episode_id}')
                                              is_premium = True
                                  except Exception as premium_error:
                                      print(f'有料判定中にエラーが発生しました: {str(premium_error)}')
                                  
                                  # エピソード情報を追加
                                  episodes.append({
                                      'id': episode_id,
                                      'title': title,
                                      'date': episode_date,
                                      'is_premium': is_premium,
                                      'url': href
                                  })
                                  
                                  print(f'エピソード {episode_id} を追加しました: {title} ({episode_date}) {"有料" if is_premium else "無料"}')
                  
                  # 各エピソードのプレイボタンをクリックして、オーディオURLを取得
                  print('各エピソードのオーディオURLを取得します')
                  
                  # 最大3件のエピソードを処理
                  episodes_to_process = episodes[:MAX_EPISODES]
                  
                  for episode in episodes_to_process:
                      episode_id = episode['id']
                      print(f'エピソード {episode_id} のオーディオURLを取得します')
                      
                      try:
                          # エピソードのプレイボタンを探す
                          play_buttons = driver.find_elements(By.CSS_SELECTOR, f'a[href*=\"{episode_id}\"] ~ button, a[href*=\"{episode_id}\"] + button, button[data-episode-id=\"{episode_id}\"], [aria-label=\"再生\"][data-episode-id=\"{episode_id}\"]')
                          
                          if not play_buttons:
                              # より広範囲に検索
                              play_buttons = driver.find_elements(By.CSS_SELECTOR, 'button.play, button[aria-label=\"再生\"], [role=\"button\"][aria-label=\"再生\"]')
                          
                          if play_buttons:
                              # 最初のプレイボタンをクリック
                              play_button = play_buttons[0]
                              driver.execute_script('arguments[0].scrollIntoView({block: \"center\"});', play_button)
                              time.sleep(1)
                              driver.execute_script('arguments[0].click();', play_button)
                              print('プレイボタンをクリックしました')
                              
                              # オーディオリクエストが発生するまで待機
                              time.sleep(5)
                          else:
                              print('プレイボタンが見つかりませんでした')
                      except Exception as e:
                          print(f'プレイボタンのクリック中にエラーが発生しました: {str(e)}')
                  
                  # すべてのオーディオリクエストを取得
                  audio_requests = driver.execute_script('return window.audioRequests;')
                  episode_audio_map = driver.execute_script('return window.episodeAudioMap;')
                  
                  print(f'キャプチャしたオーディオリクエスト: {len(audio_requests)}件')
                  
                  # 各エピソードにオーディオURLを追加
                  for episode in episodes_to_process:
                      episode_id = episode['id']
                      
                      # エピソードIDに対応するオーディオURLを探す
                      if episode_id in episode_audio_map:
                          audio_urls = episode_audio_map[episode_id]
                          m3u8_urls = [req['url'] for req in audio_urls if '.m3u8' in req['url']]
                          
                          if m3u8_urls:
                              episode['audio_url'] = m3u8_urls[0]
                              print(f'エピソード {episode_id} のオーディオURLを設定: {episode[\"audio_url\"]}')
                          else:
                              print(f'エピソード {episode_id} のm3u8 URLが見つかりませんでした')
                      else:
                          print(f'エピソード {episode_id} のオーディオURLが見つかりませんでした')
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  # 最新のエピソードを返す（最大3件）
                  episodes = episodes[:MAX_EPISODES]
                  print(f'{len(episodes)}個のエピソードを取得しました')
                  print('::endgroup::')
                  return episodes
              except Exception as e:
                  print(f'チャンネルエピソードの取得中にエラーが発生しました: {str(e)}')
                  traceback.print_exc()
                  print('::endgroup::')
                  return []
          
          def download_episode(episode):
              """エピソードをダウンロード"""
              print('::group::エピソードダウンロード')
              episode_id = episode['id']
              title = episode['title']
              date = episode['date']
              is_premium = episode['is_premium']
              
              print(f'エピソードID: {episode_id}')
              print(f'タイトル: {title}')
              print(f'日付: {date}')
              print(f'有料配信: {\"はい\" if is_premium else \"いいえ\"}')
              
              # ファイル名を生成
              if is_premium:
                  # 有料放送: _{date}_{title}_{id}.mp3
                  mp3_file = f'_{date}_{title}_{episode_id}.mp3'
              else:
                  # 無料放送: {date}_{title}_{id}.mp3
                  mp3_file = f'{date}_{title}_{episode_id}.mp3'
              
              # ファイル名に使えない文字を置換
              mp3_file = mp3_file.replace('/', '_').replace('\\\\', '_').replace(':', '_').replace('*', '_').replace('?', '_').replace('\"', '_').replace('<', '_').replace('>', '_').replace('|', '_')
              
              # MP3ファイルのパス
              mp3_path = os.path.join(MP3_DIR, mp3_file)
              
              # 既にダウンロード済みかチェック
              if os.path.exists(mp3_path):
                  print('既にダウンロード済みです: ' + mp3_file)
                  print('::endgroup::')
                  return mp3_path
              
              # オーディオURLが既に取得されているか確認
              if 'audio_url' in episode and episode['audio_url']:
                  audio_url = episode['audio_url']
                  print('既に取得済みのオーディオURLを使用します: ' + audio_url)
                  
                  # m3u8ファイルをMP3に変換してダウンロード
                  if download_m3u8_to_mp3(audio_url, mp3_path):
                      print('ダウンロードが完了しました: ' + mp3_file)
                      print('::endgroup::')
                      return mp3_path
                  else:
                      print('ダウンロードに失敗しました')
                      print('::endgroup::')
                      return None
              else:
                  print('オーディオURLが見つかりませんでした')
                  print('::endgroup::')
                  return None
          
          def main():
              """メイン処理"""
              print('=== Voicy MP3ダウンローダー ===')
              print('チャンネル: ' + CHANNEL_URL)
              print('MP3保存先: ' + MP3_DIR)
              
              # チャンネルの最新エピソードを取得
              episodes = get_channel_episodes()
              if not episodes:
                  print('エピソードが見つかりませんでした')
                  return
              
              # エピソードをダウンロード
              downloaded_files = []
              for episode in episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # ダウンロード結果を表示
              print('\\n=== ダウンロード結果 ===')
              print(f'{len(downloaded_files)}/{len(episodes)}個のエピソードをダウンロードしました')
              
              # MP3ファイルの一覧を表示
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                  
                  # 有料放送の場合
                  if mp3_file.startswith('_'):
                      # 有料放送: _日付_タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\\d+)\\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f'有料放送: {episode_id}')
                          print(f'   日付とタイトル: {date_title}')
                          print(f'   ファイル: {mp3_file}')
                      else:
                          print(f'ファイル名の解析に失敗しました: {mp3_file}')
                      print(f'{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)')
                  else:
                      # 無料放送: 日付_タイトル_ID.mp3
                      match = re.match(r'(.+)_(\\d+)\\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f'無料放送: {episode_id}')
                          print(f'   日付とタイトル: {date_title}')
                          print(f'   ファイル: {mp3_file}')
                      else:
                          print(f'ファイル名の解析に失敗しました: {mp3_file}')
                      print(f'{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)')
              
              print(f'合計: {len(mp3_files)}個のMP3ファイル')
          
          if __name__ == '__main__':
              main()
          "
      
      - name: Commit and push changes
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git add docs/podcast/*.mp3
          git commit -m "Update MP3 files" || echo "No changes to commit"
          git push
