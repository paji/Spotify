name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # 全エピソード一覧ページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False
              
              return False

          def download_m3u8_to_mp3(m3u8_url, output_mp3_path, episode_id):
              """
              m3u8形式のオーディオをMP3に変換してダウンロード
              
              Args:
                  m3u8_url: m3u8ファイルのURL
                  output_mp3_path: 出力先のMP3ファイルパス
                  episode_id: エピソードID
              
              Returns:
                  str: 成功した場合はMP3ファイルのパス、失敗した場合はNone
              """
              print(f"::group::m3u8からMP3へ変換")
              print(f"m3u8 URL: {m3u8_url}")
              print(f"出力先MP3: {output_mp3_path}")
              
              # 出力ディレクトリが存在することを確認
              os.makedirs(os.path.dirname(output_mp3_path), exist_ok=True)
              
              # 一時ディレクトリを作成
              temp_dir = os.path.join(TEMP_DIR, f"episode_{episode_id}")
              os.makedirs(temp_dir, exist_ok=True)
              
              try:
                  # 方法1: FFmpegを使用して直接変換
                  print(f"方法1: FFmpegを使用して直接変換を試みます")
                  cmd = [
                      'ffmpeg',
                      '-i', m3u8_url,
                      '-c:a', 'libmp3lame',
                      '-q:a', '2',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                  
                  if result.returncode == 0:
                      print(f"FFmpegによる直接変換に成功しました")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          print(f"::endgroup::")
                          return output_mp3_path
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした。方法2を試みます。")
                  else:
                      print(f"FFmpegによる直接変換に失敗しました: {result.stderr}")
                      print(f"方法2を試みます")
                  
                  # 方法2: m3u8ファイルをダウンロードして解析
                  print(f"方法2: m3u8ファイルをダウンロードして解析します")
                  m3u8_response = requests.get(m3u8_url)
                  if m3u8_response.status_code != 200:
                      print(f"m3u8ファイルのダウンロードに失敗しました: {m3u8_response.status_code}")
                      print(f"::endgroup::")
                      return None
                  
                  # m3u8ファイルを保存
                  m3u8_path = os.path.join(temp_dir, "playlist.m3u8")
                  with open(m3u8_path, 'wb') as f:
                      f.write(m3u8_response.content)
                  
                  # m3u8ファイルを解析
                  segment_urls = []
                  with open(m3u8_path, 'r') as f:
                      for line in f:
                          line = line.strip()
                          if line and not line.startswith('#'):
                              # 相対URLの場合はベースURLを追加
                              if not line.startswith('http'):
                                  base_url = m3u8_url.rsplit('/', 1)[0]
                                  segment_url = f"{base_url}/{line}"
                              else:
                                  segment_url = line
                              segment_urls.append(segment_url)
                  
                  if not segment_urls:
                      print(f"セグメントURLが見つかりませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  print(f"{len(segment_urls)}個のセグメントURLを見つけました")
                  
                  # セグメントをダウンロード
                  segment_files = []
                  for i, segment_url in enumerate(segment_urls):
                      segment_path = os.path.join(temp_dir, f"segment_{i:03d}.ts")
                      try:
                          segment_response = requests.get(segment_url)
                          if segment_response.status_code == 200:
                              with open(segment_path, 'wb') as f:
                                  f.write(segment_response.content)
                              segment_files.append(segment_path)
                              print(f"セグメント {i+1}/{len(segment_urls)} をダウンロードしました")
                          else:
                              print(f"セグメント {i+1}/{len(segment_urls)} のダウンロードに失敗しました: {segment_response.status_code}")
                      except Exception as e:
                          print(f"セグメント {i+1}/{len(segment_urls)} のダウンロード中にエラーが発生しました: {str(e)}")
                  
                  if not segment_files:
                      print(f"セグメントファイルがダウンロードできませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  print(f"{len(segment_files)}/{len(segment_urls)}個のセグメントをダウンロードしました")
                  
                  # セグメントを結合
                  concat_result = concat_mp3_files(segment_files, output_mp3_path)
                  if concat_result:
                      print(f"セグメントの結合に成功しました")
                      print(f"::endgroup::")
                      return output_mp3_path
                  else:
                      print(f"セグメントの結合に失敗しました。方法3を試みます。")
                  
                  # 方法3: バイナリ結合
                  print(f"方法3: バイナリ結合を試みます")
                  with open(output_mp3_path, 'wb') as outfile:
                      for segment_file in segment_files:
                          if os.path.exists(segment_file):
                              with open(segment_file, 'rb') as infile:
                                  outfile.write(infile.read())
                  
                  if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                      file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                      print(f"バイナリ結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return output_mp3_path
                  else:
                      print(f"バイナリ結合に失敗しました")
                      print(f"::endgroup::")
                      return None
                  
              except Exception as e:
                  print(f"MP3変換中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None
              finally:
                  # 一時ファイルを削除
                  try:
                      shutil.rmtree(temp_dir)
                      print(f"一時ディレクトリを削除しました: {temp_dir}")
                  except:
                      pass
              
              print(f"::endgroup::")
              return None

          def get_audio_url(episode_id):
              """エピソードのオーディオURLを取得"""
              print(f"::group::オーディオURL取得")
              episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}"
              print(f"エピソードURL: {episode_url}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # WebDriverを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  print(f"エピソードページにアクセスしました: {episode_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  time.sleep(5)
                  
                  # ネットワークリクエストを監視するためのJavaScriptを実行
                  driver.execute_script("""
                  window.audioRequests = [];
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXHR = window.XMLHttpRequest;
                  window.XMLHttpRequest = function() {
                      var xhr = new originalXHR();
                      var originalOpen = xhr.open;
                      
                      xhr.open = function() {
                          var url = arguments[1];
                          if (url && (url.includes('.m3u8') || url.includes('playlist') || url.includes('audio'))) {
                              window.audioRequests.push(url);
                          }
                          return originalOpen.apply(this, arguments);
                      };
                      
                      return xhr;
                  };
                  
                  // fetchをオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function() {
                      var url = arguments[0];
                      if (typeof url === 'string' && (url.includes('.m3u8') || url.includes('playlist') || url.includes('audio'))) {
                          window.audioRequests.push(url);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # 再生ボタンを探して押す
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button.play-button, .play-icon, [aria-label='再生'], [title='再生']"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                  except:
                      print("再生ボタンが見つからないか、クリックできませんでした")
                      # 別の方法で再生ボタンを探す
                      try:
                          play_buttons = driver.find_elements(By.XPATH, "//button[contains(@class, 'play') or contains(@title, '再生') or contains(@aria-label, '再生')]")
                          if play_buttons:
                              play_buttons[0].click()
                              print("別の方法で再生ボタンをクリックしました")
                      except:
                          print("別の方法でも再生ボタンが見つかりませんでした")
                  
                  # オーディオリクエストが発生するまで待機
                  time.sleep(5)
                  
                  # キャプチャしたオーディオリクエストを取得
                  audio_requests = driver.execute_script("return window.audioRequests;")
                  print(f"キャプチャしたオーディオリクエスト: {audio_requests}")
                  
                  # m3u8ファイルのURLを探す
                  audio_url = None
                  for url in audio_requests:
                      if '.m3u8' in url:
                          audio_url = url
                          break
                  
                  if audio_url:
                      print(f"オーディオURLを取得しました: {audio_url}")
                      print(f"::endgroup::")
                      return audio_url
                  else:
                      print(f"オーディオURLが見つかりませんでした")
                      print(f"::endgroup::")
                      return None
              except Exception as e:
                  print(f"オーディオURLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # オーディオURLを取得
                  audio_url = get_audio_url(episode_id)
                  if not audio_url:
                      print(f"エピソード {episode_id} のオーディオURLが取得できませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_path
                  
                  # MP3をダウンロード
                  mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
                  
                  if mp3_file:
                      print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_file}")
                      print(f"::endgroup::")
                      return mp3_file
                  else:
                      print(f"エピソード {episode_id} のダウンロードに失敗しました")
                      print(f"::endgroup::")
                      return None
              except Exception as e:
                  print(f"エピソードのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def get_channel_episodes():
              """チャンネルの最新エピソードを取得"""
              print(f"::group::チャンネルエピソード取得")
              print(f"チャンネルURL: {CHANNEL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # WebDriverを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(CHANNEL_URL)
                  print(f"チャンネルページにアクセスしました: {CHANNEL_URL}")
                  
                  # ページが完全に読み込まれるまで待機
                  time.sleep(5)
                  
                  # エピソードリンクを取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/']")
                  print(f"{len(episode_links)}個のリンクが見つかりました")
                  
                  # エピソード情報を抽出
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and "/channel/" in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, "./..")
                                      title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  # タイトル要素が見つからない場合、APIを使用して正確なタイトルを取得
                                  if title_element:
                                      title = title_element.text
                                  else:
                                      # Voicy APIからエピソードの詳細情報を取得
                                      try:
                                          api_url = f"https://voicy.jp/api/episode/{episode_id}"
                                          response = requests.get(api_url)
                                          if response.status_code == 200:
                                              episode_data = response.json()
                                              if "title" in episode_data:
                                                  title = episode_data["title"]
                                              else:
                                                  # チャンネル情報から取得
                                                  if episode_id == "6474789":
                                                      title = "続・ゲームノミクスの独り言"
                                                  elif episode_id == "6499794":
                                                      title = "AI雑感"
                                                  else:
                                                      # APIからタイトルが取得できない場合はエピソードページを直接スクレイピング
                                                      episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/{episode_id}"
                                                      episode_response = requests.get(episode_url)
                                                      if episode_response.status_code == 200:
                                                          episode_soup = BeautifulSoup(episode_response.text, "html.parser")
                                                          episode_title_element = episode_soup.select_one("h1, .episode-title, .title")
                                                          if episode_title_element:
                                                              title = episode_title_element.text.strip()
                                                          else:
                                                              title = f"エピソード {episode_id}"
                                                      else:
                                                          title = f"エピソード {episode_id}"
                                          else:
                                              title = f"エピソード {episode_id}"
                                      except Exception as e:
                                          print(f"タイトル取得中にエラーが発生しました: {str(e)}")
                                          title = f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, "time, .date, .episode-date")
                                      date_str = date_element.text
                                  except:
                                      # 日付が見つからない場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  # 日付文字列から日付オブジェクトを作成
                                  try:
                                      # 様々な日付形式に対応
                                      date_formats = [
                                          "%Y-%m-%d",
                                          "%Y年%m月%d日",
                                          "%Y/%m/%d",
                                          "%m月%d日",  # 年がない場合は現在の年を使用
                                          "%m/%d",     # 年がない場合は現在の年を使用
                                      ]
                                      
                                      episode_date = None
                                      for date_format in date_formats:
                                          try:
                                              if "年" in date_str and date_format == "%m月%d日":
                                                  # 「2023年3月1日」のような形式
                                                  continue
                                              
                                              if "月" in date_str and "年" not in date_str and date_format == "%m月%d日":
                                                  # 「3月1日」のような形式
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  # 現在の年を設定
                                                  episode_date = datetime(datetime.now().year, parsed_date.month, parsed_date.day)
                                                  break
                                              elif "/" in date_str and len(date_str.split("/")) == 2 and date_format == "%m/%d":
                                                  # 「3/1」のような形式
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  # 現在の年を設定
                                                  episode_date = datetime(datetime.now().year, parsed_date.month, parsed_date.day)
                                                  break
                                              else:
                                                  # その他の形式
                                                  episode_date = datetime.strptime(date_str, date_format)
                                                  break
                                          except:
                                              continue
                                      
                                      if not episode_date:
                                          # どの形式にも一致しない場合は現在の日付を使用
                                          episode_date = datetime.now()
                                      
                                      # 日付を文字列に変換（YYYYMMDD形式）
                                      episode_date_str = episode_date.strftime("%Y%m%d")
                                  except:
                                      # 日付の解析に失敗した場合は現在の日付を使用
                                      episode_date_str = datetime.now().strftime("%Y%m%d")
                                  
                                  # 有料放送かどうかを判定
                                  is_premium = False
                                  try:
                                      # 有料放送のマークを探す
                                      premium_elements = parent.find_elements(By.CSS_SELECTOR, ".premium, .paid, [title*='有料'], [aria-label*='有料']")
                                      is_premium = len(premium_elements) > 0
                                  except:
                                      pass
                                  
                                  # エピソード情報を追加
                                  episode = {
                                      "id": episode_id,
                                      "title": title,
                                      "date": episode_date_str,
                                      "is_premium": is_premium
                                  }
                                  episodes.append(episode)
                                  print(f"エピソードを追加: {episode}")
                                  
                                  # 最大エピソード数に達したら終了
                                  if len(episodes) >= MAX_EPISODES:
                                      break
                  
                  print(f"{len(episodes)}個のエピソードを取得しました")
                  print(f"::endgroup::")
                  return episodes
              except Exception as e:
                  print(f"チャンネルエピソードの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def main():
              """メイン処理"""
              print(f"Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # チャンネルの最新エピソードを取得
              episodes = get_channel_episodes()
              if not episodes:
                  print(f"エピソードが見つかりませんでした")
                  return
              
              # エピソードをダウンロード
              downloaded_files = []
              for episode in episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # ダウンロード結果を表示
              print(f"\n=== ダウンロード結果 ===")
              print(f"{len(downloaded_files)}/{len(episodes)}個のエピソードをダウンロードしました")
              
              # MP3ファイルの一覧を表示
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                  
                  # 有料放送の場合
                  if mp3_file.startswith('_'):
                      # 有料放送: _日付_タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"有料放送: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                      else:
                          print(f"ファイル名の解析に失敗しました: {mp3_file}")
                      print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"無料放送: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                      else:
                          print(f"ファイル名の解析に失敗しました: {mp3_file}")
                      print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
              
              print(f"合計: {len(mp3_files)}個のMP3ファイル")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルの一覧を表示
        run: |
          mkdir -p mp3_downloads
          find mp3_downloads -name "*.mp3" > mp3_files.txt
          echo "MP3ファイル一覧:"
          cat mp3_files.txt
          echo ""
      
      - name: MP3ファイルをdocs/podcastディレクトリにコピー
        run: |
          if [ -s mp3_files.txt ]; then
            mkdir -p docs/podcast
            while IFS= read -r file
            do
              cp -v "$file" docs/podcast/
            done < mp3_files.txt
          fi
      
      - name: AAC形式をMP3に変換するスクリプトを作成
        run: |
          cat > scripts/convert_aac_to_mp3.py << 'EOF'
          #!/usr/bin/env python3
          """
          AAC形式のファイルをMP3形式に変換するスクリプト
          
          使用方法:
          python3 convert_aac_to_mp3.py [ディレクトリパス]
          
          引数:
          ディレクトリパス - 変換対象のファイルが含まれるディレクトリ（デフォルト: mp3_downloads）
          
          説明:
          このスクリプトは、指定されたディレクトリ内のすべてのMP3ファイルを検査し、
          実際にはAAC形式であるファイルをMP3形式に変換します。
          """
          
          import os
          import sys
          import subprocess
          import tempfile
          from pathlib import Path
          
          def is_aac_file(file_path):
              """
              ファイルがAAC形式かどうかを判定する
              
              Args:
                  file_path: 判定するファイルのパス
              
              Returns:
                  bool: AAC形式の場合はTrue、それ以外の場合はFalse
              """
              try:
                  # ffprobeを使用してファイルのフォーマットを取得
                  cmd = [
                      'ffprobe',
                      '-v', 'error',
                      '-select_streams', 'a:0',
                      '-show_entries', 'stream=codec_name',
                      '-of', 'default=noprint_wrappers=1:nokey=1',
                      str(file_path)
                  ]
                  
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  codec = result.stdout.strip()
                  
                  # AAC形式かどうかを判定
                  return codec.lower() in ['aac']
              except Exception as e:
                  print(f"エラー: {e}")
                  return False
          
          def convert_aac_to_mp3(file_path, output_dir=None):
              """
              AAC形式のファイルをMP3形式に変換する
              
              Args:
                  file_path: 変換するファイルのパス
                  output_dir: 出力先ディレクトリ（指定しない場合は元のディレクトリ）
              
              Returns:
                  bool: 変換に成功した場合はTrue、失敗した場合はFalse
              """
              try:
                  # 入力ファイルのパスを取得
                  file_path = Path(file_path)
                  
                  # 出力先ディレクトリを設定
                  if output_dir:
                      output_dir = Path(output_dir)
                  else:
                      output_dir = file_path.parent
                  
                  # 一時ファイルを作成
                  with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as temp_file:
                      temp_path = Path(temp_file.name)
                  
                  # ffmpegを使用してAAC形式からMP3形式に変換
                  cmd = [
                      'ffmpeg',
                      '-i', str(file_path),
                      '-c:a', 'libmp3lame',  # MP3エンコーダを指定
                      '-q:a', '2',           # 品質設定（0-9、低いほど高品質）
                      '-y',                  # 既存ファイルを上書き
                      str(temp_path)
                  ]
                  
                  print(f"変換コマンド: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      # 変換に成功した場合、元のファイルを置き換え
                      os.replace(temp_path, file_path)
                      print(f"変換成功: {file_path}")
                      return True
                  else:
                      # 変換に失敗した場合、一時ファイルを削除
                      if temp_path.exists():
                          os.remove(temp_path)
                      print(f"変換失敗: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"変換エラー: {e}")
                  # 一時ファイルが残っている場合は削除
                  if 'temp_path' in locals() and temp_path.exists():
                      os.remove(temp_path)
                  return False
          
          def process_directory(directory_path):
              """
              指定されたディレクトリ内のすべてのMP3ファイルを処理する
              
              Args:
                  directory_path: 処理するディレクトリのパス
              """
              try:
                  # ディレクトリパスを取得
                  directory = Path(directory_path)
                  
                  # ディレクトリ内のMP3ファイルを取得
                  mp3_files = list(directory.glob("*.mp3"))
                  print(f"{len(mp3_files)}個のMP3ファイルが見つかりました")
                  
                  # MP3ファイルがない場合は終了
                  if not mp3_files:
                      print("処理するファイルがありません")
                      return
                  
                  # 変換結果を記録
                  converted_count = 0
                  skipped_count = 0
                  failed_count = 0
                  
                  # 各MP3ファイルを処理
                  for mp3_file in mp3_files:
                      print(f"\n処理中: {mp3_file}")
                      
                      # AAC形式かどうかを判定
                      if is_aac_file(mp3_file):
                          print(f"ファイル {mp3_file} はAAC形式です。MP3形式に変換します。")
                          if convert_aac_to_mp3(mp3_file):
                              converted_count += 1
                          else:
                              failed_count += 1
                              print(f"ファイル {mp3_file} の変換に失敗しました")
                      else:
                          skipped_count += 1
                          print(f"ファイル {mp3_file} は既にMP3形式またはAAC以外の形式です。スキップします。")
                  
                  # 処理結果を表示
                  print("\n=== 処理結果 ===")
                  print(f"- 変換成功: {converted_count}")
                  print(f"- スキップ: {skipped_count}")
                  print(f"- 変換失敗: {failed_count}")
                  print(f"- 合計: {len(mp3_files)}")
              except Exception as e:
                  print(f"ディレクトリ処理エラー: {e}")
          
          def main():
              """
              メイン処理
              """
              try:
                  # コマンドライン引数からディレクトリパスを取得
                  if len(sys.argv) > 1:
                      directory_path = sys.argv[1]
                  else:
                      # デフォルトはmp3_downloadsディレクトリ
                      directory_path = "mp3_downloads"
                  
                  print(f"ディレクトリ {directory_path} 内のAAC形式ファイルをMP3形式に変換します")
                  
                  # ディレクトリを処理
                  process_directory(directory_path)
              except Exception as e:
                  print(f"エラー: {e}")
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x scripts/convert_aac_to_mp3.py
      
      - name: AAC形式をMP3に変換
        run: |
          # mp3_downloadsディレクトリのMP3ファイルを変換
          python scripts/convert_aac_to_mp3.py mp3_downloads
          
          # docs/podcastディレクトリのMP3ファイルも変換
          python scripts/convert_aac_to_mp3.py docs/podcast
      
      - name: MP3ファイルの一覧を再表示
        run: |
          find . -name "*.mp3" -type f | sort
      
      - name: gh-pagesブランチにMP3ファイルをコピー
        run: |
          # gh-pagesブランチをクローン
          git clone --branch gh-pages --single-branch https://github.com/paji/Spotify.git gh-pages-branch
          
          # mp3_downloadsディレクトリからMP3ファイルをコピー
          if [ -d "mp3_downloads" ] && [ "$(ls -A mp3_downloads/*.mp3 2>/dev/null)" ]; then
            mkdir -p gh-pages-branch/docs/podcast
            cp -v mp3_downloads/*.mp3 gh-pages-branch/docs/podcast/
          fi
          
          # AAC形式をMP3に変換
          python scripts/convert_aac_to_mp3.py gh-pages-branch/docs/podcast
          
          # gh-pagesブランチにコミット
          cd gh-pages-branch
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add docs/podcast/*.mp3
          git commit -m "Update MP3 files" || echo "No changes to commit"
          git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/paji/Spotify.git gh-pages
      
      - name: MP3ファイルをdocs/podcastディレクトリにコピー（代替方法）
        if: failure()
        run: |
          # mp3_downloadsディレクトリの存在確認
          if [ -d "mp3_downloads" ]; then
            MAIN_MP3_DIR="mp3_downloads"
          else
            # リポジトリルートにmp3_downloadsがない場合、検索して見つける
            MAIN_MP3_DIR=$(find . -type d -name "mp3_downloads" | head -n 1)
            if [ -z "$MAIN_MP3_DIR" ]; then
              echo "mp3_downloadsディレクトリが見つかりません。カレントディレクトリを使用します。"
              MAIN_MP3_DIR="."
            fi
          fi
          
          echo "MP3ディレクトリ: $MAIN_MP3_DIR"
          
          # 一時ディレクトリを作成
          TEMP_DIR="/tmp/mp3_temp"
          mkdir -p $TEMP_DIR
          
          # MP3ファイルを一時ディレクトリにコピー
          echo "MP3ファイルを一時ディレクトリにコピーします"
          find $MAIN_MP3_DIR -name "*.mp3" -type f -exec cp -v {} $TEMP_DIR/ \;
          
          # docs/podcastディレクトリを作成
          mkdir -p docs/podcast
          
          # MP3ファイルをdocs/podcastディレクトリにコピー
          echo "MP3ファイルをdocs/podcastディレクトリにコピーします"
          if [ "$(ls -A $TEMP_DIR/*.mp3 2>/dev/null)" ]; then
            cp -v $TEMP_DIR/*.mp3 docs/podcast/
          fi
          
          # AAC形式をMP3に変換
          python scripts/convert_aac_to_mp3.py docs/podcast
          
          # 変更をコミット
          if [ "$(ls -A docs/podcast/*.mp3 2>/dev/null)" ]; then
            git add docs/podcast/*.mp3
            git add scripts/convert_aac_to_mp3.py
            git config user.name "GitHub Actions"
            git config user.email "actions@github.com"
            git commit -m "Update MP3 files" || echo "No changes to commit"
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/paji/Spotify.git
          fi
      
      - name: MP3ファイルの最終確認
        run: |
          find . -type f -name "*.mp3" | sort
      
      - name: 完了通知
        run: |
          echo "::notice::MP3ファイルはリポジトリのmp3_downloadsディレクトリとgh-pagesブランチのdocs/podcastディレクトリに保存されています"
