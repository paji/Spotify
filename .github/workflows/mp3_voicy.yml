name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 7

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_to_mp3(m3u8_url, output_mp3_path, episode_id):
              """
              m3u8ファイルをダウンロードしてMP3に変換する関数
              
              Args:
                  m3u8_url: m3u8ファイルのURL
                  output_mp3_path: 出力先のMP3ファイルパス
                  episode_id: エピソードID
              
              Returns:
                  str: 成功した場合はMP3ファイルのパス、失敗した場合はNone
              """
              print(f"::group::m3u8ダウンロード")
              print(f"m3u8 URL: {m3u8_url}")
              print(f"出力MP3パス: {output_mp3_path}")
              
              try:
                  # 出力ディレクトリが存在することを確認
                  os.makedirs(os.path.dirname(os.path.abspath(output_mp3_path)), exist_ok=True)
                  
                  # 一時ディレクトリをクリア
                  for file in os.listdir(TEMP_DIR):
                      file_path = os.path.join(TEMP_DIR, file)
                      try:
                          if os.path.isfile(file_path):
                              os.unlink(file_path)
                      except Exception as e:
                          print(f"一時ファイルの削除中にエラーが発生しました: {e}")
                  
                  # ファイル拡張子を確認
                  if m3u8_url.endswith('.m3u8'):
                      # m3u8ファイルの場合
                      print(f"m3u8ファイルを処理します")
                      
                      # m3u8ファイルをダウンロード
                      m3u8_content = requests.get(m3u8_url).text
                      m3u8_path = os.path.join(TEMP_DIR, f"playlist_{episode_id}.m3u8")
                      with open(m3u8_path, 'w') as f:
                          f.write(m3u8_content)
                      
                      print(f"m3u8ファイルをダウンロードしました: {m3u8_path}")
                      
                      # m3u8ファイルを解析してセグメントURLを取得
                      segment_urls = []
                      base_url = m3u8_url.rsplit('/', 1)[0] + '/'
                      
                      for line in m3u8_content.splitlines():
                          if not line.startswith('#') and line.strip():
                              # 相対パスの場合はベースURLを追加
                              if not line.startswith('http'):
                                  segment_url = base_url + line
                              else:
                                  segment_url = line
                              segment_urls.append(segment_url)
                      
                      print(f"セグメント数: {len(segment_urls)}")
                      
                      # セグメントをダウンロード
                      mp3_segments = []
                      for i, segment_url in enumerate(segment_urls):
                          segment_path = os.path.join(TEMP_DIR, f"segment_{episode_id}_{i:03d}.mp3")
                          try:
                              segment_content = requests.get(segment_url).content
                              with open(segment_path, 'wb') as f:
                                  f.write(segment_content)
                              mp3_segments.append(segment_path)
                              print(f"セグメント {i+1}/{len(segment_urls)} をダウンロードしました")
                          except Exception as e:
                              print(f"セグメント {i+1}/{len(segment_urls)} のダウンロード中にエラーが発生しました: {str(e)}")
                      
                      # MP3ファイルを結合
                      if concat_mp3_files(mp3_segments, output_mp3_path):
                          print(f"MP3ファイルの作成に成功しました: {output_mp3_path}")
                          print(f"::endgroup::")
                          return output_mp3_path
                      else:
                          print(f"MP3ファイルの作成に失敗しました")
                          print(f"::endgroup::")
                          return None
                  
                  elif m3u8_url.endswith('.aac'):
                      # aacファイルの場合
                      print(f"aacファイルを処理します")
                      
                      # aacファイルをダウンロード
                      aac_content = requests.get(m3u8_url).content
                      aac_path = os.path.join(TEMP_DIR, f"audio_{episode_id}.aac")
                      with open(aac_path, 'wb') as f:
                          f.write(aac_content)
                      
                      print(f"aacファイルをダウンロードしました: {aac_path}")
                      
                      # aacファイルをMP3に変換
                      cmd = [
                          'ffmpeg',
                          '-i', aac_path,
                          '-c:a', 'libmp3lame',
                          '-q:a', '2',
                          '-y',
                          output_mp3_path
                      ]
                      
                      print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                      result = subprocess.run(cmd, capture_output=True, text=True)
                      
                      if result.returncode == 0:
                          print(f"MP3ファイルの作成に成功しました: {output_mp3_path}")
                          print(f"::endgroup::")
                          return output_mp3_path
                      else:
                          print(f"MP3ファイルの作成に失敗しました: {result.stderr}")
                          print(f"::endgroup::")
                          return None
                  
                  else:
                      # その他の形式の場合
                      print(f"未対応のファイル形式です: {m3u8_url}")
                      print(f"::endgroup::")
                      return None
              
              except Exception as e:
                  print(f"MP3ファイルの作成中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def get_audio_url(episode_id, episode_title):
              """
              エピソードのオーディオURLを取得する関数
              
              Args:
                  episode_id: エピソードID
                  episode_title: エピソードタイトル
              
              Returns:
                  str: オーディオURL
              """
              print(f"::group::オーディオURL取得")
              print(f"エピソードID: {episode_id}")
              print(f"エピソードタイトル: {episode_title}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  episode_url = f"https://voicy.jp/channel/{CHANNEL_ID}/episode/{episode_id}"
                  print(f"エピソードURL: {episode_url}")
                  driver.get(episode_url)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptを実行してオーディオURLを取得
                  js_script = """
                  var audioElements = document.getElementsByTagName('audio');
                  if (audioElements.length > 0) {
                      return audioElements[0].src;
                  }
                  return '';
                  """
                  audio_url = driver.execute_script(js_script)
                  
                  # オーディオURLが取得できない場合は再試行
                  if not audio_url:
                      print("オーディオURLが取得できませんでした。再試行します...")
                      time.sleep(3)
                      
                      # 再生ボタンをクリック
                      try:
                          play_button = WebDriverWait(driver, 10).until(
                              EC.element_to_be_clickable((By.CSS_SELECTOR, "button.play-button"))
                          )
                          play_button.click()
                          print("再生ボタンをクリックしました")
                          
                          # 少し待機してからオーディオURLを再取得
                          time.sleep(2)
                          audio_url = driver.execute_script(js_script)
                      except Exception as e:
                          print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  print(f"オーディオURL: {audio_url}")
                  print(f"::endgroup::")
                  return audio_url
              
              except Exception as e:
                  print(f"オーディオURLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              # 日付フォーマットをyyyy-mm-ddに変換
              try:
                  date_obj = datetime.strptime(episode_date, "%Y年%m月%d日")
                  episode_date = date_obj.strftime("%Y-%m-%d")
              except:
                  try:
                      date_obj = datetime.strptime(episode_date, "%Y/%m/%d")
                      episode_date = date_obj.strftime("%Y-%m-%d")
                  except:
                      pass  # 既にyyyy-mm-dd形式か、変換できない場合はそのまま使用
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # オーディオURLを取得（タイトルを渡して正しいエピソードを特定）
                  audio_url = get_audio_url(episode_id, episode_title)
                  if not audio_url:
                      print(f"エピソード {episode_id} のオーディオURLが取得できませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_path
                  
                  # MP3をダウンロード
                  mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
                  
                  if mp3_file:
                      print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_path}")
                      print(f"::endgroup::")
                      return mp3_path
                  else:
                      print(f"エピソード {episode_id} のダウンロードに失敗しました")
              except Exception as e:
                  print(f"エピソード {episode_id} のダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def get_episodes():
              """
              Voicyチャンネルから最新エピソードのリストを取得する関数
              
              Returns:
                  list: エピソードのリスト
              """
              print(f"::group::エピソードリスト取得")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  print(f"チャンネルURL: {CHANNEL_URL}")
                  driver.get(CHANNEL_URL)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # スクロールして全てのエピソードを読み込む
                  last_height = driver.execute_script("return document.body.scrollHeight")
                  scroll_count = 0
                  max_scrolls = 5  # 最大スクロール回数を制限
                  
                  while scroll_count < max_scrolls:
                      # ページの最下部までスクロール
                      driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                      time.sleep(2)  # ページの読み込みを待機
                      
                      # 新しい高さを取得
                      new_height = driver.execute_script("return document.body.scrollHeight")
                      if new_height == last_height:
                          break  # 高さが変わらなければ全て読み込まれたと判断
                      
                      last_height = new_height
                      scroll_count += 1
                  
                  # ページのHTMLを取得
                  html = driver.page_source
                  
                  # HTMLをBeautifulSoupで解析
                  soup = BeautifulSoup(html, 'html.parser')
                  
                  # エピソードリストを取得
                  episodes = []
                  episode_elements = soup.select('div.episode-item')
                  
                  for element in episode_elements:
                      try:
                          # エピソードID
                          episode_link = element.select_one('a.episode-link')
                          if not episode_link:
                              continue
                          
                          href = episode_link.get('href', '')
                          episode_id = href.split('/')[-1] if href else None
                          
                          if not episode_id:
                              continue
                          
                          # タイトル
                          title_element = element.select_one('div.episode-title')
                          title = title_element.text.strip() if title_element else "不明なタイトル"
                          
                          # 日付
                          date_element = element.select_one('div.episode-date')
                          date = date_element.text.strip() if date_element else "不明な日付"
                          
                          # 有料放送かどうか
                          premium_element = element.select_one('div.premium-badge')
                          is_premium = bool(premium_element)
                          
                          episodes.append({
                              "id": episode_id,
                              "title": title,
                              "date": date,
                              "is_premium": is_premium
                          })
                      except Exception as e:
                          print(f"エピソード情報の解析中にエラーが発生しました: {str(e)}")
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  print(f"取得したエピソード数: {len(episodes)}")
                  for i, episode in enumerate(episodes[:5]):  # 最初の5件だけ表示
                      print(f"エピソード {i+1}: {episode['title']} ({episode['date']}) - ID: {episode['id']}")
                  
                  if len(episodes) > 5:
                      print(f"... 他 {len(episodes) - 5} 件")
                  
                  print(f"::endgroup::")
                  return episodes
              
              except Exception as e:
                  print(f"エピソードリストの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def main():
              """メイン関数"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソードリストを取得
              episodes = get_episodes()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードをダウンロードします")
              
              # 各エピソードをダウンロード
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              print(f"ダウンロード完了: {len(downloaded_files)}件")
              for file in downloaded_files:
                  print(f"- {file}")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルをコミット
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add mp3_downloads/*.mp3
          git commit -m "MP3ファイルを更新 $(date +'%Y-%m-%d %H:%M:%S')" || echo "No changes to commit"
          git push
