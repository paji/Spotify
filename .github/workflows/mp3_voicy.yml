name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
        with:
          repository: paji/Spotify
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p docs/podcast
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "docs/podcast"  # GitHubリポジトリのパス（gh-pagesブランチ内）
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegコマンドの実行に失敗しました")
                      print(f"標準出力: {result.stdout}")
                      print(f"標準エラー: {result.stderr}")
                      
                      # 方法2: 失敗した場合は、バイナリ結合を試みる
                      print("バイナリ結合を試みます...")
                      try:
                          with open(output_mp3_path, 'wb') as outfile:
                              for segment in mp3_segments:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          outfile.write(infile.read())
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"バイナリ結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              return True
                          else:
                              print("バイナリ結合に失敗しました")
                              return False
                      except Exception as e:
                          print(f"バイナリ結合中にエラーが発生しました: {str(e)}")
                          return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_segments(m3u8_url, episode_id, temp_dir=TEMP_DIR):
              """
              M3U8プレイリストからセグメントをダウンロードする関数
              
              Args:
                  m3u8_url: M3U8プレイリストのURL
                  episode_id: エピソードID
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  list: ダウンロードしたセグメントファイルのリスト
              """
              print(f"M3U8プレイリストをダウンロードします: {m3u8_url}")
              
              try:
                  # M3U8プレイリストをダウンロード
                  response = requests.get(m3u8_url, timeout=30)
                  if response.status_code != 200:
                      print(f"M3U8プレイリストのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      return []
                  
                  # M3U8プレイリストを解析
                  m3u8_content = response.text
                  
                  # デバッグ用にM3U8ファイルを保存
                  m3u8_file_path = f"{DEBUG_DIR}/playlist_{episode_id}.m3u8"
                  with open(m3u8_file_path, "w", encoding="utf-8") as f:
                      f.write(m3u8_content)
                  print(f"M3U8プレイリストを保存しました: {m3u8_file_path}")
                  
                  # セグメントURLを抽出
                  segment_urls = []
                  for line in m3u8_content.splitlines():
                      if line and not line.startswith('#'):
                          # 相対URLの場合は絶対URLに変換
                          if not line.startswith('http'):
                              base_url = m3u8_url.rsplit('/', 1)[0]
                              segment_url = f"{base_url}/{line}"
                          else:
                              segment_url = line
                          segment_urls.append(segment_url)
                  
                  print(f"セグメント数: {len(segment_urls)}")
                  
                  # セグメントをダウンロード
                  segment_files = []
                  for i, segment_url in enumerate(segment_urls):
                      segment_file = f"{temp_dir}/segment_{episode_id}_{i:03d}.ts"
                      try:
                          print(f"セグメントをダウンロード中 ({i+1}/{len(segment_urls)}): {segment_url}")
                          segment_response = requests.get(segment_url, timeout=30)
                          if segment_response.status_code == 200:
                              with open(segment_file, "wb") as f:
                                  f.write(segment_response.content)
                              segment_files.append(segment_file)
                          else:
                              print(f"セグメントのダウンロードに失敗しました: ステータスコード {segment_response.status_code}")
                      except Exception as e:
                          print(f"セグメントのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  print(f"ダウンロードしたセグメント数: {len(segment_files)}")
                  return segment_files
              
              except Exception as e:
                  print(f"M3U8プレイリストの処理中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return []

          def convert_ts_to_mp3(ts_files, output_mp3_path):
              """
              TSファイルをMP3に変換する関数
              
              Args:
                  ts_files: TSファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not ts_files:
                  print("変換するTSファイルがありません")
                  return False
              
              try:
                  # 入力ファイルリストを作成
                  input_list = []
                  for ts_file in ts_files:
                      if os.path.exists(ts_file) and os.path.getsize(ts_file) > 0:
                          input_list.extend(['-i', ts_file])
                      else:
                          print(f"無効なTSファイル: {ts_file}")
                  
                  if not input_list:
                      print("有効なTSファイルがありません")
                      return False
                  
                  # 一時的な結合TSファイルを作成
                  temp_ts = f"{os.path.splitext(output_mp3_path)[0]}_temp.ts"
                  
                  # TSファイルを結合
                  with open(temp_ts, 'wb') as outfile:
                      for ts_file in ts_files:
                          if os.path.exists(ts_file) and os.path.getsize(ts_file) > 0:
                              with open(ts_file, 'rb') as infile:
                                  outfile.write(infile.read())
                  
                  # 結合したTSファイルをMP3に変換
                  cmd = [
                      'ffmpeg',
                      '-i', temp_ts,
                      '-vn',  # ビデオストリームを無視
                      '-acodec', 'libmp3lame',  # MP3エンコーダを使用
                      '-q:a', '2',  # 音質設定（0-9、低いほど高品質）
                      '-y',  # 既存ファイルを上書き
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  # 一時ファイルを削除
                  if os.path.exists(temp_ts):
                      os.remove(temp_ts)
                  
                  if result.returncode == 0:
                      print(f"MP3への変換に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegコマンドの実行に失敗しました")
                      print(f"標準出力: {result.stdout}")
                      print(f"標準エラー: {result.stderr}")
                      return False
              
              except Exception as e:
                  print(f"TSファイルの変換中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def get_episodes_from_channel():
              """
              チャンネルページからエピソード情報を取得する関数
              
              Returns:
                  list: エピソード情報のリスト
              """
              print(f"チャンネルURL: {CHANNEL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(CHANNEL_URL)
                  print(f"チャンネルページにアクセスしました: {CHANNEL_URL}")
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # ページをスクロールして全てのエピソードを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # ページのHTMLをデバッグ用に保存
                  debug_html_path = f"{DEBUG_DIR}/channel_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"チャンネルページのHTMLを保存しました: {debug_html_path}")
                  
                  # 特定のチャンネル（ID:2834）のエピソードリンクのみを取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, f"a[href*='/channel/{CHANNEL_ID}/']")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and f"/channel/{CHANNEL_ID}/" in href:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # リンクの親要素から見出しを探す
                                      parent = link
                                      for _ in range(5):  # 最大5階層まで遡る
                                          parent = parent.find_element(By.XPATH, "..")
                                          h_elements = parent.find_elements(By.XPATH, ".//h2 | .//h3 | .//h4")
                                          if h_elements:
                                              title_element = h_elements[0]
                                              break
                                  except:
                                      pass
                                  
                                  # タイトルが見つからない場合はリンクのテキストを使用
                                  title = title_element.text if title_element else link.text
                                  title = title.strip() if title else f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得（存在する場合）
                                  date_text = ""
                                  try:
                                      # 日付要素を探す
                                      date_elements = parent.find_elements(By.XPATH, ".//time | .//span[contains(@class, 'date')]")
                                      if date_elements:
                                          date_text = date_elements[0].text.strip()
                                  except:
                                      pass
                                  
                                  episodes.append({
                                      "id": episode_id,
                                      "title": title,
                                      "url": href,
                                      "date": date_text
                                  })
                                  print(f"エピソードを見つけました: ID={episode_id}, タイトル={title}, 日付={date_text}")
                  
                  driver.quit()
                  print(f"合計 {len(episodes)} 件のエピソードを見つけました")
                  return episodes
              
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  try:
                      driver.quit()
                  except:
                      pass
                  return []

          def get_m3u8_url_from_episode(episode_url):
              """
              エピソードページからM3U8 URLを取得する関数
              
              Args:
                  episode_url: エピソードページのURL
              
              Returns:
                  tuple: (M3U8 URL, is_premium_content)
              """
              print(f"エピソードページにアクセスします: {episode_url}")
              is_premium_content = False
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  print(f"エピソードページにアクセスしました: {episode_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # ページのHTMLをデバッグ用に保存
                  episode_id = episode_url.split('/')[-1]
                  debug_html_path = f"{DEBUG_DIR}/episode_{episode_id}.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"エピソードページのHTMLを保存しました: {debug_html_path}")
                  
                  # JavaScriptを実行してネットワークリクエストを監視
                  driver.execute_script("""
                  // ネットワークリクエストを監視するための配列
                  window.m3u8Urls = [];
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXhrOpen = XMLHttpRequest.prototype.open;
                  XMLHttpRequest.prototype.open = function(method, url) {
                      if (url && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      }
                      return originalXhrOpen.apply(this, arguments);
                  };
                  
                  // fetchをオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function(url, options) {
                      if (url && typeof url === 'string' && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      } else if (url && typeof url === 'object' && url.url && url.url.includes('.m3u8')) {
                          window.m3u8Urls.push(url.url);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # 再生ボタンをクリック
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button.play-button, button[aria-label='再生'], [role='button'][aria-label='再生']"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                      time.sleep(5)  # リクエストが発生するのを待つ
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                  
                  # M3U8 URLを取得
                  m3u8_urls = driver.execute_script("return window.m3u8Urls;")
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  if m3u8_urls:
                      # 最後に検出されたM3U8 URLを使用
                      m3u8_url = m3u8_urls[-1]
                      print(f"M3U8 URLを見つけました: {m3u8_url}")
                      return m3u8_url, is_premium_content
                  else:
                      # ページソースからM3U8 URLを検索
                      print("JavaScriptによる検出に失敗しました。ページソースから検索します...")
                      
                      # Chromeドライバーを再初期化
                      driver = webdriver.Chrome(service=service, options=chrome_options)
                      driver.get(episode_url)
                      
                      # ページが完全に読み込まれるまで待機
                      WebDriverWait(driver, 10).until(
                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                      )
                      
                      # ページソースを取得
                      page_source = driver.page_source
                      driver.quit()
                      
                      # M3U8 URLを正規表現で検索
                      m3u8_pattern = r'https?://[^"\']+\.m3u8'
                      m3u8_matches = re.findall(m3u8_pattern, page_source)
                      
                      if m3u8_matches:
                          m3u8_url = m3u8_matches[0]
                          print(f"ページソースからM3U8 URLを見つけました: {m3u8_url}")
                          return m3u8_url, is_premium_content
                      else:
                          print("M3U8 URLが見つかりませんでした")
                          return None, is_premium_content
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # ページのHTMLをデバッグ用に保存
                  episode_id = episode_url.split('/')[-1]
                  debug_html_path = f"{DEBUG_DIR}/episode_{episode_id}.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"エピソードページのHTMLを保存しました: {debug_html_path}")
                  
                  # JavaScriptを実行してネットワークリクエストを監視
                  driver.execute_script("""
                  // ネットワークリクエストを監視するための配列
                  window.m3u8Urls = [];
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXhrOpen = XMLHttpRequest.prototype.open;
                  XMLHttpRequest.prototype.open = function(method, url) {
                      if (url && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      }
                      return originalXhrOpen.apply(this, arguments);
                  };
                  
                  // fetchをオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function(url, options) {
                      if (url && typeof url === 'string' && url.includes('.m3u8')) {
                          window.m3u8Urls.push(url);
                      } else if (url && typeof url === 'object' && url.url && url.url.includes('.m3u8')) {
                          window.m3u8Urls.push(url.url);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # 再生ボタンをクリック
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button.play-button, button[aria-label='再生'], [role='button'][aria-label='再生']"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                      time.sleep(5)  # リクエストが発生するのを待つ
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                  
                  # M3U8 URLを取得
                  m3u8_urls = driver.execute_script("return window.m3u8Urls;")
                  
                  # ブラウザを閉じる
                  driver.quit()
                  
                  if m3u8_urls:
                      # 最後に検出されたM3U8 URLを使用
                      m3u8_url = m3u8_urls[-1]
                      print(f"M3U8 URLを見つけました: {m3u8_url}")
                      return m3u8_url
                  else:
                      # ページソースからM3U8 URLを検索
                      print("JavaScriptによる検出に失敗しました。ページソースから検索します...")
                      
                      # Chromeドライバーを再初期化
                      driver = webdriver.Chrome(service=service, options=chrome_options)
                      driver.get(episode_url)
                      
                      # ページが完全に読み込まれるまで待機
                      WebDriverWait(driver, 10).until(
                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                      )
                      
                      # ページソースを取得
                      page_source = driver.page_source
                      
                      # プレミアムコンテンツかどうかを確認
                      if "こちらの放送はプレミアムリスナーの方のみ聴くことができます" in page_source:
                          print("これは有料配信（プレミアムコンテンツ）です")
                          is_premium_content = True
                      
                      driver.quit()
                      
                      # M3U8 URLを正規表現で検索
                      m3u8_pattern = r'https?://[^"\']+\.m3u8'
                      m3u8_matches = re.findall(m3u8_pattern, page_source)
                      
                      if m3u8_matches:
                          m3u8_url = m3u8_matches[0]
                          print(f"ページソースからM3U8 URLを見つけました: {m3u8_url}")
                          return m3u8_url, is_premium_content
                      else:
                          print("M3U8 URLが見つかりませんでした")
                          return None, is_premium_content
              
              except Exception as e:
                  print(f"M3U8 URLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  try:
                      driver.quit()
                  except:
                      pass
                  return None, False

          def process_episode(episode):
              """
              エピソードを処理する関数
              
              Args:
                  episode: エピソード情報
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_url = episode["url"]
              episode_date = episode["date"]
              
              print(f"\n===== エピソード処理開始: {episode_title} (ID: {episode_id}) =====")
              
              # ファイル名を生成（日付がある場合は含める）
              if episode_date:
                  # 日付文字列から数字のみを抽出
                  date_numbers = re.sub(r'[^\d]', '', episode_date)
                  if len(date_numbers) >= 8:  # YYYYMMDD形式と仮定
                      date_str = date_numbers[:8]
                  else:
                      date_str = datetime.now().strftime("%Y%m%d")
              else:
                  date_str = datetime.now().strftime("%Y%m%d")
              
              # ファイル名に使用できない文字を置換
              safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
              
              # M3U8 URLとプレミアムコンテンツ情報を取得
              m3u8_url, is_premium_content = get_m3u8_url_from_episode(episode_url)
              if not m3u8_url:
                  print(f"M3U8 URLの取得に失敗しました: {episode_url}")
                  return False
              
              # 有料配信の場合はファイル名の先頭にアンダースコアを付ける
              if is_premium_content:
                  output_mp3_path = f"{MP3_DIR}/_{date_str}_{safe_title}_{episode_id}.mp3"
                  print(f"有料配信のため、ファイル名の先頭にアンダースコアを付けました")
              else:
                  output_mp3_path = f"{MP3_DIR}/{date_str}_{safe_title}_{episode_id}.mp3"
              
              # 既にダウンロード済みかチェック
              if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                  file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                  print(f"既にダウンロード済みです: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                  return True
              
              # M3U8セグメントをダウンロード
              ts_files = download_m3u8_segments(m3u8_url, episode_id)
              if not ts_files:
                  print(f"M3U8セグメントのダウンロードに失敗しました: {m3u8_url}")
                  return False
              
              # TSファイルをMP3に変換
              success = convert_ts_to_mp3(ts_files, output_mp3_path)
              
              # 一時ファイルを削除
              for ts_file in ts_files:
                  if os.path.exists(ts_file):
                      os.remove(ts_file)
              
              if success:
                  print(f"エピソードの処理に成功しました: {episode_title}")
                  return True
              else:
                  print(f"エピソードの処理に失敗しました: {episode_title}")
                  return False

          def main():
              """メイン関数"""
              print(f"Voicy MP3ダウンローダーを開始します (チャンネル: {CHANNEL_URL})")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              try:
                  # エピソード情報を取得
                  episodes = get_episodes_from_channel()
                  if not episodes:
                      print("エピソードが見つかりませんでした")
                      return
                  
                  # 最新のエピソードを処理
                  latest_episodes = episodes[:MAX_EPISODES]
                  print(f"最新の {len(latest_episodes)} 件のエピソードを処理します")
                  
                  success_count = 0
                  for episode in latest_episodes:
                      if process_episode(episode):
                          success_count += 1
                  
                  print(f"\n処理完了: {success_count}/{len(latest_episodes)} 件のエピソードを正常に処理しました")
              
              except Exception as e:
                  print(f"実行中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルをアップロード
        uses: actions/upload-artifact@v4
        with:
          name: voicy-mp3-files
          path: docs/podcast/*.mp3
          retention-days: 7
          if-no-files-found: warn
      
      - name: デバッグファイルをアップロード
        uses: actions/upload-artifact@v4
        with:
          name: debug-files
          path: debug_files/
          retention-days: 1
          if-no-files-found: warn
      
      - name: 変更をコミット
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          mkdir -p docs/podcast
          git add docs/podcast/*.mp3 || true
          git commit -m "Add new MP3 files $(date +'%Y-%m-%d %H:%M:%S')" || true
          git push origin gh-pages || true
