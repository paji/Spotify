name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p mp3_downloads
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"MP3ファイルの結合に失敗しました: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_to_mp3(m3u8_url, mp3_path, episode_id):
              """m3u8からMP3をダウンロード"""
              print(f"::group::MP3ダウンロード")
              print(f"オーディオURLからMP3をダウンロード中: {m3u8_url}")
              print(f"出力先: {mp3_path}")
              
              try:
                  # URLの拡張子を確認
                  is_m3u8 = '.m3u8' in m3u8_url.lower()
                  is_mp3 = '.mp3' in m3u8_url.lower()
                  
                  # MP3の場合は直接ダウンロード
                  if is_mp3:
                      print(f"MP3ファイルを直接ダウンロードします")
                      try:
                          response = requests.get(m3u8_url, timeout=30)
                          if response.status_code == 200:
                              with open(mp3_path, 'wb') as f:
                                  f.write(response.content)
                              
                              if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                                  print(f"MP3ファイルのダウンロードに成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                  print(f"::endgroup::")
                                  return mp3_path
                              else:
                                  print(f"MP3ファイルが正常にダウンロードされませんでした")
                          else:
                              print(f"MP3ファイルのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      except Exception as e:
                          print(f"MP3ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  # m3u8ファイルの場合
                  if is_m3u8:
                      # m3u8ファイルの内容を取得
                      response = requests.get(m3u8_url, timeout=30)
                      if response.status_code != 200:
                          print(f"m3u8ファイルの取得に失敗しました: ステータスコード {response.status_code}")
                          print(f"::endgroup::")
                          return None
                      
                      m3u8_content = response.text
                      
                      # m3u8ファイルをデバッグ用に保存
                      m3u8_debug_path = f"{DEBUG_DIR}/playlist_{episode_id}.m3u8"
                      with open(m3u8_debug_path, 'w') as f:
                          f.write(m3u8_content)
                      print(f"m3u8ファイルを保存しました: {m3u8_debug_path}")
                      
                      # セグメントURLを抽出
                      segment_urls = []
                      base_url = '/'.join(m3u8_url.split('/')[:-1]) + '/'
                      
                      for line in m3u8_content.splitlines():
                          if not line.startswith('#') and line.strip():
                              if line.startswith('http'):
                                  segment_urls.append(line)
                              else:
                                  segment_urls.append(base_url + line)
                      
                      print(f"セグメント数: {len(segment_urls)}")
                      if not segment_urls:
                          print(f"セグメントURLが見つかりませんでした")
                          print(f"::endgroup::")
                          return None
                      
                      # セグメントをダウンロード - AACファイルとして保存（JSファイルの実装に合わせる）
                      segment_files = []
                      for i, url in enumerate(segment_urls):
                          segment_path = f"{TEMP_DIR}/segment_{i:03d}.aac"  # .ts から .aac に変更
                          try:
                              segment_response = requests.get(url, timeout=30)
                              if segment_response.status_code == 200:
                                  with open(segment_path, 'wb') as f:
                                      f.write(segment_response.content)
                                  segment_files.append(segment_path)
                              else:
                                  print(f"セグメント {i} のダウンロードに失敗: ステータスコード {segment_response.status_code}")
                          except Exception as e:
                              print(f"セグメント {i} のダウンロード中にエラー: {str(e)}")
                      
                      print(f"ダウンロードしたセグメント数: {len(segment_files)}")
                      
                      if not segment_files:
                          print(f"セグメントのダウンロードに失敗しました")
                          print(f"::endgroup::")
                          return None
                          
                      # JSファイルの実装に合わせて、直接バイナリ結合する方法を最初に試す
                      print("方法0: 直接バイナリ結合（JSファイルの実装に合わせる）")
                      try:
                          with open(mp3_path, 'wb') as outfile:
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          shutil.copyfileobj(infile, outfile)
                          
                          if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"バイナリ結合によるMP3ファイルの作成に成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              
                              # 一時ファイルを削除
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      os.remove(segment)
                              
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"バイナリ結合によるMP3ファイルの作成に失敗しました")
                      except Exception as e:
                          print(f"バイナリ結合中にエラーが発生しました: {str(e)}")
                  
                  # 以下は元の実装をフォールバックとして残す
                  
                  # 方法1: 直接FFmpegを使用してURLからMP3に変換
                  print("方法1: 直接FFmpegを使用してURLからMP3に変換")
                  try:
                      cmd1 = [
                          'ffmpeg',
                          '-i', m3u8_url,
                          '-c:a', 'libmp3lame',
                          '-q:a', '2',
                          '-y',
                          mp3_path
                      ]
                      print(f"FFmpegコマンド（方法1）を実行: {' '.join(cmd1)}")
                      result1 = subprocess.run(cmd1, capture_output=True, text=True)
                      
                      if result1.returncode == 0:
                          print(f"MP3ファイルの作成に成功しました: {mp3_path}")
                          if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"MP3ファイル: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              
                              # 一時ファイルを削除
                              if is_m3u8:
                                  for segment in segment_files:
                                      if os.path.exists(segment):
                                          os.remove(segment)
                              
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"MP3ファイルが正常に作成されませんでした")
                      else:
                          print(f"FFmpegコマンド（方法1）の実行に失敗しました: {result1.stderr}")
                  except Exception as e:
                      print(f"FFmpegコマンド（方法1）の実行中にエラーが発生しました: {str(e)}")
                  
                  # 方法2: セグメントをダウンロードしてから結合
                  print("方法2: セグメントをダウンロードしてから結合")
                  if segment_files:
                      try:
                          # FFmpegを使用してセグメントを結合
                          concat_result = concat_mp3_files(segment_files, mp3_path)
                          if concat_result:
                              print(f"セグメントの結合に成功しました: {mp3_path}")
                              
                              # 一時ファイルを削除
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      os.remove(segment)
                              
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"セグメントの結合に失敗しました")
                      except Exception as e:
                          print(f"セグメントの結合中にエラーが発生しました: {str(e)}")
              except Exception as e:
                  print(f"MP3ダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def get_episode_list():
              """エピソード一覧を取得"""
              print(f"::group::エピソード一覧取得")
              print(f"チャンネルURL: {CHANNEL_URL}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(CHANNEL_URL)
                  print(f"チャンネルページにアクセスしました: {CHANNEL_URL}")
                  
                  # ページが完全に読み込まれるまで待機（待機時間を20秒に増加）
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ページをスクロールして全てのコンテンツを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # ページのHTMLをデバッグ用に保存
                  debug_html_path = f"{DEBUG_DIR}/channel_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"チャンネルページのHTMLを保存しました: {debug_html_path}")
                  
                  # エピソードリンクを取得（CSSセレクタを修正）
                  episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and "/channel/" in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, "./..")
                                      title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  title = title_element.text if title_element else f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, "time, .date, .episode-date")
                                      date_str = date_element.text
                                  except:
                                      # 日付が見つからない場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  # 日付文字列から日付オブジェクトを作成
                                  try:
                                      # 様々な日付形式に対応
                                      date_formats = [
                                          "%Y-%m-%d",
                                          "%Y年%m月%d日",
                                          "%Y/%m/%d",
                                          "%m月%d日",  # 年がない場合は現在の年を使用
                                          "%m/%d",     # 年がない場合は現在の年を使用
                                      ]
                                      
                                      episode_date = None
                                      for date_format in date_formats:
                                          try:
                                              if "年" in date_str and date_format == "%m月%d日":
                                                  # 「2023年3月1日」のような形式
                                                  continue
                                              
                                              if "月" in date_str and "年" not in date_str and date_format == "%m月%d日":
                                                  # 「3月1日」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              elif "/" in date_str and len(date_str.split("/")) == 2 and date_format == "%m/%d":
                                                  # 「3/1」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              else:
                                                  episode_date = datetime.strptime(date_str, date_format)
                                                  break
                                          except ValueError:
                                              continue
                                      
                                      if episode_date is None:
                                          # どの形式にも合致しない場合は現在の日付を使用
                                          episode_date = datetime.now()
                                      
                                      # YYYYMMDD形式に変換
                                      episode_date_str = episode_date.strftime("%Y%m%d")
                                  except Exception as e:
                                      # 日付の解析に失敗した場合は現在の日付を使用
                                      episode_date_str = datetime.now().strftime("%Y%m%d")
                                  
                                  # 有料放送かどうかを判定
                                  is_premium = False
                                  
                                  # エピソードページにアクセスして有料放送かどうかを確認
                                  episode_url = f"https://voicy.jp/episode/{episode_id}"
                                  try:
                                      # 新しいタブでエピソードページを開く
                                      driver.execute_script(f"window.open('{episode_url}', '_blank');")
                                      
                                      # 新しいタブに切り替え
                                      driver.switch_to.window(driver.window_handles[-1])
                                      
                                      # ページが読み込まれるまで待機
                                      WebDriverWait(driver, 10).until(
                                          EC.presence_of_element_located((By.TAG_NAME, "body"))
                                      )
                                      
                                      # 有料放送の判定要素を確認
                                      # 1. 「購入する」ボタンがあるか
                                      purchase_buttons = driver.find_elements(By.XPATH, "//*[contains(text(), '購入する') or contains(text(), '¥') or contains(text(), '円で購入')]")
                                      
                                      # 2. 「プレミアム」という文字が含まれるか
                                      premium_elements = driver.find_elements(By.XPATH, "//*[contains(text(), 'プレミアム') or contains(@class, 'premium')]")
                                      
                                      # 3. 「バックナンバー聴き放題プラン」という文字が含まれるか
                                      backnumber_elements = driver.find_elements(By.XPATH, "//*[contains(text(), 'バックナンバー聴き放題')]")
                                      
                                      # いずれかの条件に合致する場合は有料放送と判定
                                      is_premium = len(purchase_buttons) > 0 or len(premium_elements) > 0 or len(backnumber_elements) > 0
                                      
                                      print(f"エピソード {episode_id} の有料判定: {is_premium}")
                                      print(f"- 購入ボタン: {len(purchase_buttons) > 0}")
                                      print(f"- プレミアム要素: {len(premium_elements) > 0}")
                                      print(f"- バックナンバー要素: {len(backnumber_elements) > 0}")
                                      
                                      # タブを閉じる
                                      driver.close()
                                      
                                      # 元のタブに戻る
                                      driver.switch_to.window(driver.window_handles[0])
                                      
                                  except Exception as e:
                                      print(f"エピソード {episode_id} の有料判定中にエラーが発生しました: {str(e)}")
                                      # エラーが発生した場合は元のタブに戻る
                                      if len(driver.window_handles) > 1:
                                          driver.close()
                                          driver.switch_to.window(driver.window_handles[0])
                                  
                                  episodes.append({
                                      "id": episode_id,
                                      "title": title,
                                      "date": episode_date_str,
                                      "is_premium": is_premium,
                                      "url": f"https://voicy.jp/episode/{episode_id}"
                                  })
                  
                  # ドライバーを閉じる
                  driver.quit()
                  
                  # エピソード情報をデバッグ用に保存
                  with open(f"{DEBUG_DIR}/episodes.json", 'w', encoding='utf-8') as f:
                      json.dump(episodes, f, ensure_ascii=False, indent=2)
                  
                  print(f"エピソード一覧を取得しました: {len(episodes)}件")
                  print(f"::endgroup::")
                  return episodes
              except Exception as e:
                  print(f"エピソード一覧の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def get_audio_url(episode_id):
              """エピソードのオーディオURLを取得"""
              print(f"::group::オーディオURL取得")
              episode_url = f"https://voicy.jp/episode/{episode_id}"
              print(f"エピソードURL: {episode_url}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  print(f"エピソードページにアクセスしました: {episode_url}")
                  
                  # ページが完全に読み込まれるまで待機（待機時間を20秒に増加）
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ネットワークリクエストを監視するためのJavaScriptを実行
                  driver.execute_script("""
                  window.audioRequests = [];
                  
                  // XMLHttpRequestをオーバーライド
                  var originalXHR = window.XMLHttpRequest;
                  window.XMLHttpRequest = function() {
                      var xhr = new originalXHR();
                      var originalOpen = xhr.open;
                      
                      xhr.open = function() {
                          var url = arguments[1];
                          if (url && (url.includes('.m3u8') || url.includes('.mp3'))) {
                              window.audioRequests.push(url);
                          }
                          return originalOpen.apply(this, arguments);
                      };
                      
                      return xhr;
                  };
                  
                  // fetchをオーバーライド
                  var originalFetch = window.fetch;
                  window.fetch = function() {
                      var url = arguments[0];
                      if (typeof url === 'string' && (url.includes('.m3u8') || url.includes('.mp3'))) {
                          window.audioRequests.push(url);
                      }
                      return originalFetch.apply(this, arguments);
                  };
                  """)
                  
                  # 再生ボタンをクリック
                  try:
                      # 再生ボタンのセレクタを複数試す
                      play_button_selectors = [
                          ".episodePlayer .playButton",
                          ".player .playButton",
                          ".player-controls .play-button",
                          "button[aria-label='再生']",
                          "button.play"
                      ]
                      
                      play_button = None
                      for selector in play_button_selectors:
                          try:
                              play_button = WebDriverWait(driver, 5).until(
                                  EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                              )
                              if play_button:
                                  break
                          except:
                              continue
                      
                      if play_button:
                          play_button.click()
                          print("再生ボタンをクリックしました")
                      else:
                          print("再生ボタンが見つかりませんでした")
                      
                      # オーディオリクエストが発生するまで待機
                      time.sleep(10)
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                  
                  # キャプチャしたオーディオリクエストを取得
                  audio_requests = driver.execute_script("return window.audioRequests;")
                  
                  # ページのHTMLを取得
                  html = driver.page_source
                  
                  # HTMLをデバッグ用に保存
                  with open(f"{DEBUG_DIR}/episode_{episode_id}.html", 'w', encoding='utf-8') as f:
                      f.write(html)
                  
                  # ドライバーを閉じる
                  driver.quit()
                  
                  print(f"キャプチャしたオーディオリクエスト: {audio_requests}")
                  
                  # オーディオURLを特定
                  audio_url = None
                  
                  # 方法1: キャプチャしたリクエストから取得
                  if audio_requests:
                      for url in audio_requests:
                          if '.m3u8' in url or '.mp3' in url:
                              audio_url = url
                              print(f"方法1: オーディオURLを見つけました: {audio_url}")
                              break
                  
                  # 方法2: HTMLから直接検索
                  if not audio_url:
                      soup = BeautifulSoup(html, 'html.parser')
                      
                      # scriptタグ内のJSONデータを検索
                      scripts = soup.find_all('script')
                      for script in scripts:
                          script_text = script.string
                          if script_text and ('m3u8' in script_text or 'mp3' in script_text):
                              # m3u8またはmp3のURLを正規表現で抽出
                              url_match = re.search(r'(https?://[^"\']+\.(?:m3u8|mp3))', script_text)
                              if url_match:
                                  audio_url = url_match.group(1)
                                  print(f"方法2: オーディオURLを見つけました: {audio_url}")
                                  break
                  
                  if audio_url:
                      print(f"オーディオURLを取得しました: {audio_url}")
                      print(f"::endgroup::")
                      return audio_url
                  else:
                      print(f"オーディオURLが見つかりませんでした")
                      print(f"::endgroup::")
                      return None
              except Exception as e:
                  print(f"オーディオURLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソードダウンロード")
              episode_id = episode["id"]
              episode_title = episode["title"]
              episode_date = episode["date"]
              is_premium = episode["is_premium"]
              
              print(f"エピソードID: {episode_id}")
              print(f"タイトル: {episode_title}")
              print(f"日付: {episode_date}")
              print(f"有料放送: {'はい' if is_premium else 'いいえ'}")
              
              try:
                  # オーディオURLを取得
                  audio_url = get_audio_url(episode_id)
                  if not audio_url:
                      print(f"エピソード {episode_id} のオーディオURLが取得できませんでした")
                      print(f"::endgroup::")
                      return None
                  
                  # ファイル名に使用できない文字を置換
                  safe_title = re.sub(r'[\\/:*?"<>|]', '_', episode_title)
                  safe_title = safe_title[:50]  # タイトルの長さを制限
                  
                  # ファイル名の作成（日付_タイトル_ID.mp3）
                  if is_premium:
                      mp3_filename = f"_{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"有料放送用ファイル名: {mp3_filename}")
                  else:
                      mp3_filename = f"{episode_date}_{safe_title}_{episode_id}.mp3"
                      print(f"無料放送用ファイル名: {mp3_filename}")
                  mp3_path = os.path.join(MP3_DIR, mp3_filename)
                  
                  # 既にダウンロード済みかチェック
                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                      print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                      print(f"::endgroup::")
                      return mp3_path
                  
                  # MP3をダウンロード
                  mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
                  
                  if mp3_file:
                      print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_path}")
                      print(f"::endgroup::")
                      return mp3_path
                  else:
                      print(f"エピソード {episode_id} のダウンロードに失敗しました")
              except Exception as e:
                  print(f"エピソード {episode_id} のダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
              
              print(f"::endgroup::")
              return None

          def main():
              """メイン関数"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード一覧を取得
              episodes = get_episode_list()
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 最新のエピソードを処理
              latest_episodes = episodes[:MAX_EPISODES]
              print(f"最新の{len(latest_episodes)}件のエピソードを処理します")
              
              downloaded_files = []
              for episode in latest_episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # ダウンロード結果を表示
              print("\nダウンロード結果:")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出
                  if mp3_file.startswith('_'):
                      # 有料放送: _タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 有料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB")
                      else:
                          print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          date_title = match.group(1)
                          episode_id = match.group(2)
                          print(f"{i}. 無料放送:")
                          print(f"   ID: {episode_id}")
                          print(f"   日付とタイトル: {date_title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB")
                      else:
                          print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
              
              print(f"合計: {len(mp3_files)}個のMP3ファイル")
              print("Voicy MP3ダウンローダーを終了します")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: MP3ファイルをdocsディレクトリにコピー
        run: |
          mkdir -p mp3_downloads
          find mp3_downloads -name "*.mp3" > mp3_files.txt
          
          echo "MP3ファイル一覧:"
          cat mp3_files.txt
          
          # docsディレクトリを作成
          mkdir -p docs/podcast
          
          # MP3ファイルをコピー
          if [ -s mp3_files.txt ]; then
            while IFS= read -r file
            do
              echo "コピー: $file -> docs/podcast/"
              cp -v "$file" docs/podcast/
            done < mp3_files.txt
          else
            echo "MP3ファイルが見つかりませんでした"
          fi
      
      - name: AAC形式からMP3形式への変換スクリプトを作成
        run: |
          cat > scripts/convert_aac_to_mp3.py << 'EOF'
          #!/usr/bin/env python3
          """
          AAC形式のファイル（MP3拡張子で保存されているもの）をMP3形式に変換するスクリプト

          使用方法:
          python3 convert_aac_to_mp3.py [ディレクトリパス]

          引数:
          ディレクトリパス - 変換対象のファイルが含まれるディレクトリ（デフォルト: mp3_downloads）
          """

          import os
          import sys
          import subprocess
          import shutil
          from pathlib import Path

          def check_ffmpeg():
              """FFmpegがインストールされているか確認"""
              try:
                  result = subprocess.run(['ffmpeg', '-version'], capture_output=True, text=True)
                  if result.returncode == 0:
                      print("FFmpegが利用可能です")
                      return True
                  else:
                      print("FFmpegが見つかりません")
                      return False
              except FileNotFoundError:
                  print("FFmpegがインストールされていません")
                  return False

          def install_ffmpeg():
              """FFmpegをインストール"""
              print("FFmpegをインストールしています...")
              try:
                  subprocess.run(['sudo', 'apt-get', 'update'], check=True)
                  subprocess.run(['sudo', 'apt-get', 'install', '-y', 'ffmpeg'], check=True)
                  print("FFmpegのインストールが完了しました")
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"FFmpegのインストールに失敗しました: {e}")
                  return False

          def is_aac_file(file_path):
              """ファイルがAAC形式かどうかを確認"""
              try:
                  # ffprobeを使用してファイルのフォーマットを確認
                  cmd = [
                      'ffprobe',
                      '-v', 'error',
                      '-select_streams', 'a:0',
                      '-show_entries', 'stream=codec_name',
                      '-of', 'default=noprint_wrappers=1:nokey=1',
                      file_path
                  ]
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  # 出力からコーデック名を取得
                  codec = result.stdout.strip()
                  print(f"ファイル {file_path} のコーデック: {codec}")
                  
                  # AACコーデックの場合はTrue
                  return codec.lower() in ['aac']
              except Exception as e:
                  print(f"ファイル {file_path} の形式確認中にエラーが発生しました: {e}")
                  return False

          def convert_aac_to_mp3(file_path, output_dir=None):
              """AAC形式のファイルをMP3形式に変換"""
              try:
                  # 入力ファイルのパスを解析
                  input_path = Path(file_path)
                  
                  # 出力ディレクトリが指定されていない場合は入力ファイルと同じディレクトリを使用
                  if output_dir is None:
                      output_dir = input_path.parent
                  else:
                      output_dir = Path(output_dir)
                      os.makedirs(output_dir, exist_ok=True)
                  
                  # 一時ファイル名を作成（元のファイル名に _converted を追加）
                  temp_output_path = output_dir / f"{input_path.stem}_converted{input_path.suffix}"
                  
                  # FFmpegを使用してAACからMP3に変換
                  cmd = [
                      'ffmpeg',
                      '-i', str(input_path),
                      '-c:a', 'libmp3lame',  # MP3エンコーダを指定
                      '-q:a', '2',           # 品質設定（0-9、低いほど高品質）
                      '-y',                  # 既存ファイルを上書き
                      str(temp_output_path)
                  ]
                  
                  print(f"変換コマンド: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      # 変換成功
                      print(f"ファイル {file_path} の変換に成功しました")
                      
                      # バックアップディレクトリを作成
                      backup_dir = output_dir / "aac_backup"
                      os.makedirs(backup_dir, exist_ok=True)
                      
                      # 元のファイルをバックアップ
                      backup_path = backup_dir / input_path.name
                      shutil.copy2(input_path, backup_path)
                      print(f"元のファイルをバックアップしました: {backup_path}")
                      
                      # 変換したファイルを元のファイル名に戻す
                      shutil.move(temp_output_path, input_path)
                      print(f"変換したファイルを元のパスに移動しました: {input_path}")
                      
                      return True
                  else:
                      # 変換失敗
                      print(f"ファイル {file_path} の変換に失敗しました")
                      print(f"エラー: {result.stderr}")
                      
                      # 一時ファイルが存在する場合は削除
                      if temp_output_path.exists():
                          os.remove(temp_output_path)
                      
                      return False
              except Exception as e:
                  print(f"ファイル {file_path} の変換中にエラーが発生しました: {e}")
                  return False

          def process_directory(directory_path):
              """指定されたディレクトリ内のMP3ファイルを処理"""
              directory = Path(directory_path)
              
              if not directory.exists():
                  print(f"ディレクトリ {directory} が存在しません")
                  return False
              
              # MP3ファイルを検索
              mp3_files = list(directory.glob("*.mp3"))
              print(f"{len(mp3_files)}個のMP3ファイルが見つかりました")
              
              if not mp3_files:
                  print(f"ディレクトリ {directory} にMP3ファイルが見つかりません")
                  return False
              
              converted_count = 0
              skipped_count = 0
              
              # 各ファイルを処理
              for mp3_file in mp3_files:
                  print(f"\n処理中: {mp3_file}")
                  
                  # ファイルがAAC形式かどうかを確認
                  if is_aac_file(mp3_file):
                      # AAC形式の場合はMP3に変換
                      if convert_aac_to_mp3(mp3_file):
                          converted_count += 1
                      else:
                          print(f"ファイル {mp3_file} の変換に失敗しました")
                  else:
                      print(f"ファイル {mp3_file} は既にMP3形式またはAAC以外の形式です。スキップします。")
                      skipped_count += 1
              
              print(f"\n処理完了:")
              print(f"- 変換されたファイル: {converted_count}")
              print(f"- スキップされたファイル: {skipped_count}")
              print(f"- 合計: {len(mp3_files)}")
              
              return True

          def main():
              """メイン関数"""
              # コマンドライン引数からディレクトリパスを取得
              if len(sys.argv) > 1:
                  directory_path = sys.argv[1]
              else:
                  # デフォルトはmp3_downloadsディレクトリ
                  directory_path = "mp3_downloads"
              
              print(f"ディレクトリ {directory_path} 内のMP3ファイルを処理します")
              
              # FFmpegが利用可能か確認
              if not check_ffmpeg():
                  # FFmpegがない場合はインストール
                  if not install_ffmpeg():
                      print("FFmpegのインストールに失敗しました。処理を中止します。")
                      return 1
              
              # ディレクトリ内のファイルを処理
              if process_directory(directory_path):
                  print("処理が完了しました")
                  return 0
              else:
                  print("処理に失敗しました")
                  return 1

          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          chmod +x scripts/convert_aac_to_mp3.py
      
      - name: AAC形式からMP3形式への変換を実行
        run: |
          # mp3_downloadsディレクトリのMP3ファイルを変換
          python scripts/convert_aac_to_mp3.py mp3_downloads
          
          # docsディレクトリのMP3ファイルも変換
          python scripts/convert_aac_to_mp3.py docs/podcast
      
      - name: ファイル一覧を表示
        run: |
          echo "ファイル一覧:"
          find . -name "*.mp3" -type f | sort
      
      - name: gh-pagesブランチにMP3ファイルをコピー
        run: |
          # gh-pagesブランチをクローン
          git clone --branch gh-pages --single-branch https://github.com/paji/Spotify.git gh-pages-branch
          
          # gh-pagesブランチのdocs/podcastディレクトリを作成
          mkdir -p gh-pages-branch/docs/podcast
          
          # MP3ファイルをコピー
          if [ -d "mp3_downloads" ] && [ "$(ls -A mp3_downloads/*.mp3 2>/dev/null)" ]; then
            echo "MP3ファイルをgh-pagesブランチにコピー:"
            cp -v mp3_downloads/*.mp3 gh-pages-branch/docs/podcast/
          else
            echo "コピーするMP3ファイルが見つかりません"
          fi
          
          # gh-pagesブランチのMP3ファイルも変換
          python scripts/convert_aac_to_mp3.py gh-pages-branch/docs/podcast
          
          # gh-pagesブランチの変更をコミット
          cd gh-pages-branch
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git add docs/podcast/*.mp3
          
          # 変更があるかチェック
          if git diff --staged --quiet; then
            echo "gh-pagesブランチにコミットする変更はありません"
          else
            git commit -m "MP3ファイルを更新 (gh-pages) $(date +'%Y-%m-%d %H:%M:%S')"
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/paji/Spotify.git gh-pages
            echo "gh-pagesブランチに変更をプッシュしました"
          fi
      
      - name: GitHubにコミット
        run: |
          # mp3_downloadsディレクトリの存在確認
          if [ -d "mp3_downloads" ]; then
            MAIN_MP3_DIR="mp3_downloads"
          else
            # リポジトリルートにmp3_downloadsがない場合、検索して見つける
            MAIN_MP3_DIR=$(find . -type d -name "mp3_downloads" | head -n 1)
            if [ -z "$MAIN_MP3_DIR" ]; then
              echo "mp3_downloadsディレクトリが見つかりません。カレントディレクトリを使用します。"
              MAIN_MP3_DIR="."
            fi
          fi
          
          echo "MP3ディレクトリ: $MAIN_MP3_DIR"
          
          # 一時ディレクトリを作成
          TEMP_DIR="/tmp/mp3_temp"
          mkdir -p $TEMP_DIR
          
          # MP3ファイルを一時ディレクトリにコピー
          echo "MP3ファイルを一時ディレクトリにコピー:"
          find $MAIN_MP3_DIR -name "*.mp3" -type f -exec cp -v {} $TEMP_DIR/ \;
          
          # docsディレクトリを作成
          mkdir -p docs/podcast
          
          # 一時ディレクトリからdocsディレクトリにMP3ファイルをコピー
          echo "MP3ファイルをdocsディレクトリにコピー:"
          if [ "$(ls -A $TEMP_DIR/*.mp3 2>/dev/null)" ]; then
            cp -v $TEMP_DIR/*.mp3 docs/podcast/
          else
            echo "コピーするMP3ファイルがありません"
          fi
          
          # Gitの設定
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # 変更をコミット
          echo "変更をコミット:"
          if [ "$(ls -A docs/podcast/*.mp3 2>/dev/null)" ]; then
            git add docs/podcast/*.mp3
            git add scripts/convert_aac_to_mp3.py
            
            # 変更があるかチェック
            if git diff --staged --quiet; then
              echo "コミットする変更はありません"
            else
              git commit -m "MP3ファイルを更新 $(date +'%Y-%m-%d %H:%M:%S')"
              git push
              echo "変更をプッシュしました"
            fi
          else
            echo "コミットするMP3ファイルがありません"
          fi
          
          # ファイル一覧を表示
          echo "最終的なファイル一覧:"
          find . -type f -name "*.mp3" | sort
      
      - name: 完了通知
        run: |
          echo "::notice::Voicy MP3ダウンロードが完了しました"
          echo "::notice::MP3ファイルはリポジトリのmp3_downloadsディレクトリとgh-pagesブランチのdocs/podcastディレクトリに保存されています"
