name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
        with:
          repository: paji/Spotify
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: 必要なディレクトリを作成
        run: |
          mkdir -p docs/podcast
          mkdir -p temp_segments
          mkdir -p debug_files
          mkdir -p scripts
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "docs/podcast"  # GitHubリポジトリのパス（gh-pagesブランチ内）
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"MP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegコマンドの実行に失敗しました")
                      print(f"標準出力: {result.stdout}")
                      print(f"標準エラー: {result.stderr}")
                      
                      # 方法2: 失敗した場合は、バイナリ結合を試みる
                      print("バイナリ結合を試みます...")
                      try:
                          with open(output_mp3_path, 'wb') as outfile:
                              for segment in mp3_segments:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          outfile.write(infile.read())
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"バイナリ結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              return True
                          else:
                              print("バイナリ結合に失敗しました")
                              return False
                      except Exception as e:
                          print(f"バイナリ結合中にエラーが発生しました: {str(e)}")
                          return False
              except Exception as e:
                  print(f"MP3ファイルの結合中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return False

          def download_m3u8_segments(m3u8_url, episode_id, temp_dir=TEMP_DIR):
              """
              M3U8プレイリストからセグメントをダウンロードする関数
              
              Args:
                  m3u8_url: M3U8プレイリストのURL
                  episode_id: エピソードID
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  list: ダウンロードしたセグメントファイルのリスト
              """
              print(f"M3U8プレイリストをダウンロードします: {m3u8_url}")
              
              try:
                  # M3U8プレイリストをダウンロード
                  response = requests.get(m3u8_url, timeout=30)
                  if response.status_code != 200:
                      print(f"M3U8プレイリストのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      return []
                  
                  # M3U8プレイリストを解析
                  m3u8_content = response.text
                  
                  # デバッグ用にM3U8ファイルを保存
                  m3u8_debug_path = os.path.join(DEBUG_DIR, f"playlist_{episode_id}.m3u8")
                  with open(m3u8_debug_path, 'w') as f:
                      f.write(m3u8_content)
                  print(f"M3U8プレイリストをデバッグ用に保存しました: {m3u8_debug_path}")
                  
                  # セグメントURLを抽出
                  segment_urls = []
                  for line in m3u8_content.splitlines():
                      if line and not line.startswith('#'):
                          # 相対URLの場合は絶対URLに変換
                          if not line.startswith('http'):
                              base_url = m3u8_url.rsplit('/', 1)[0]
                              segment_url = f"{base_url}/{line}"
                          else:
                              segment_url = line
                          segment_urls.append(segment_url)
                  
                  print(f"セグメント数: {len(segment_urls)}")
                  if not segment_urls:
                      print("セグメントURLが見つかりませんでした")
                      return []
                  
                  # セグメントをダウンロード
                  mp3_segments = []
                  for i, segment_url in enumerate(segment_urls):
                      segment_path = os.path.join(temp_dir, f"segment_{episode_id}_{i:03d}.ts")
                      try:
                          print(f"セグメントをダウンロード中 ({i+1}/{len(segment_urls)}): {segment_url}")
                          segment_response = requests.get(segment_url, timeout=30)
                          if segment_response.status_code == 200:
                              with open(segment_path, 'wb') as f:
                                  f.write(segment_response.content)
                              mp3_segments.append(segment_path)
                          else:
                              print(f"セグメントのダウンロードに失敗しました: ステータスコード {segment_response.status_code}")
                      except Exception as e:
                          print(f"セグメントのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  print(f"ダウンロードしたセグメント数: {len(mp3_segments)}")
                  return mp3_segments
              
              except Exception as e:
                  print(f"M3U8セグメントのダウンロード中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return []

          def get_m3u8_url_from_episode(episode_url):
              """
              エピソードページからM3U8 URLを取得する関数
              
              Args:
                  episode_url: エピソードページのURL
              
              Returns:
                  tuple: (M3U8 URL, is_premium_content)
              """
              print(f"エピソードページからM3U8 URLを取得します: {episode_url}")
              
              is_premium_content = False
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  print(f"エピソードページにアクセスしました: {episode_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  time.sleep(5)
                  
                  # JavaScriptを実行してM3U8 URLを取得
                  try:
                      # ネットワークリクエストを監視するスクリプトを実行
                      script = """
                      var m3u8Url = '';
                      var originalXHROpen = XMLHttpRequest.prototype.open;
                      XMLHttpRequest.prototype.open = function(method, url) {
                          if (url.includes('.m3u8')) {
                              m3u8Url = url;
                              console.log('M3U8 URL found:', m3u8Url);
                          }
                          return originalXHROpen.apply(this, arguments);
                      };
                      
                      // 再生ボタンをクリック
                      var playButtons = document.querySelectorAll('button[aria-label="再生"]');
                      if (playButtons.length > 0) {
                          playButtons[0].click();
                          console.log('Play button clicked');
                      } else {
                          console.log('Play button not found');
                      }
                      
                      // 5秒後にM3U8 URLを返す
                      setTimeout(function() {
                          return m3u8Url;
                      }, 5000);
                      """
                      
                      driver.execute_script(script)
                      print("再生ボタンをクリックするスクリプトを実行しました")
                      
                      # スクリプト実行後に少し待機
                      time.sleep(7)
                      
                      # コンソールログからM3U8 URLを取得
                      logs = driver.get_log('browser')
                      m3u8_url = None
                      
                      for log in logs:
                          if 'M3U8 URL found:' in log.get('message', ''):
                              m3u8_url_match = re.search(r'M3U8 URL found: (https?://[^"\']+\.m3u8)', log.get('message', ''))
                              if m3u8_url_match:
                                  m3u8_url = m3u8_url_match.group(1)
                                  print(f"コンソールログからM3U8 URLを見つけました: {m3u8_url}")
                                  break
                      
                      if m3u8_url:
                          driver.quit()
                          return m3u8_url, is_premium_content
                  
                  except Exception as e:
                      print(f"JavaScriptの実行中にエラーが発生しました: {str(e)}")
                  
                  # ページソースを取得
                  page_source = driver.page_source
                  
                  # プレミアムコンテンツかどうかを確認（修正部分）
                  if "こちらの放送はプレミアムリスナーの方のみ聴くことができます" in page_source or \
                     "※無料配信から1ヶ月が過ぎた過去配信は随時プレミアム放送となっています" in page_source or \
                     "premium=1" in episode_url:
                      print("これは有料配信（プレミアムコンテンツ）です")
                      is_premium_content = True
                  
                  driver.quit()
                  
                  # M3U8 URLを正規表現で検索
                  m3u8_pattern = r'https?://[^"\']+\.m3u8'
                  m3u8_matches = re.findall(m3u8_pattern, page_source)
                  
                  if m3u8_matches:
                      m3u8_url = m3u8_matches[0]
                      print(f"ページソースからM3U8 URLを見つけました: {m3u8_url}")
                      return m3u8_url, is_premium_content
                  else:
                      print("ページソースからM3U8 URLが見つかりませんでした")
                      return None, is_premium_content
              
              except Exception as e:
                  print(f"M3U8 URLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return None, is_premium_content

          def download_episode(episode_url, episode_id, title, date_str):
              """
              エピソードをダウンロードする関数
              
              Args:
                  episode_url: エピソードページのURL
                  episode_id: エピソードID
                  title: エピソードタイトル
                  date_str: 日付文字列
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              print(f"エピソードをダウンロードします: {title} ({episode_id})")
              
              # ファイル名に使用できない文字を置換
              safe_title = re.sub(r'[\\/*?:"<>|]', '_', title)
              safe_title = safe_title[:50]  # タイトルの長さを制限
              
              # M3U8 URLとプレミアムコンテンツ情報を取得
              m3u8_url, is_premium_content = get_m3u8_url_from_episode(episode_url)
              if not m3u8_url:
                  print(f"M3U8 URLの取得に失敗しました: {episode_url}")
                  return False
              
              # 有料配信の場合はファイル名の先頭にアンダースコアを付ける
              if is_premium_content:
                  output_mp3_path = f"{MP3_DIR}/_{date_str}_{safe_title}_{episode_id}.mp3"
                  print(f"有料配信のため、ファイル名の先頭にアンダースコアを付けました")
              else:
                  output_mp3_path = f"{MP3_DIR}/{date_str}_{safe_title}_{episode_id}.mp3"
              
              # 既に同じファイルが存在する場合はスキップ
              if os.path.exists(output_mp3_path):
                  print(f"ファイルが既に存在します。スキップします: {output_mp3_path}")
                  return True
              
              # M3U8セグメントをダウンロード
              mp3_segments = download_m3u8_segments(m3u8_url, episode_id)
              if not mp3_segments:
                  print(f"M3U8セグメントのダウンロードに失敗しました: {m3u8_url}")
                  return False
              
              # MP3ファイルを結合
              success = concat_mp3_files(mp3_segments, output_mp3_path)
              
              # 一時ファイルを削除
              for segment in mp3_segments:
                  if os.path.exists(segment):
                      os.remove(segment)
              
              return success

          def get_episode_info(episode_element):
              """
              エピソード要素から情報を抽出する関数
              
              Args:
                  episode_element: エピソード要素
              
              Returns:
                  dict: エピソード情報
              """
              try:
                  # エピソードURL
                  episode_url_element = episode_element.select_one('a.episodeLink')
                  if not episode_url_element:
                      return None
                  
                  episode_url = episode_url_element['href']
                  if not episode_url.startswith('http'):
                      episode_url = f"https://voicy.jp{episode_url}"
                  
                  # エピソードID
                  episode_id_match = re.search(r'/(\d+)$', episode_url)
                  if not episode_id_match:
                      return None
                  episode_id = episode_id_match.group(1)
                  
                  # タイトル
                  title_element = episode_element.select_one('div.title')
                  title = title_element.text.strip() if title_element else f"エピソード {episode_id}"
                  
                  # 日付
                  date_element = episode_element.select_one('div.date')
                  date_str = None
                  if date_element:
                      date_text = date_element.text.strip()
                      # 日付形式を解析
                      try:
                          if '年' in date_text and '月' in date_text and '日' in date_text:
                              # 「2023年3月1日」形式
                              date_match = re.search(r'(\d{4})年(\d{1,2})月(\d{1,2})日', date_text)
                              if date_match:
                                  year, month, day = map(int, date_match.groups())
                                  date_obj = datetime(year, month, day)
                                  date_str = date_obj.strftime('%Y%m%d')
                          else:
                              # その他の形式
                              date_str = datetime.now().strftime('%Y%m%d')
                      except Exception as e:
                          print(f"日付の解析に失敗しました: {date_text}, エラー: {str(e)}")
                          date_str = datetime.now().strftime('%Y%m%d')
                  
                  if not date_str:
                      date_str = datetime.now().strftime('%Y%m%d')
                  
                  return {
                      'episode_id': episode_id,
                      'episode_url': episode_url,
                      'title': title,
                      'date_str': date_str
                  }
              
              except Exception as e:
                  print(f"エピソード情報の抽出中にエラーが発生しました: {str(e)}")
                  return None

          def get_latest_episodes(channel_url, max_episodes=MAX_EPISODES):
              """
              チャンネルページから最新のエピソード情報を取得する関数
              
              Args:
                  channel_url: チャンネルページのURL
                  max_episodes: 取得する最大エピソード数
              
              Returns:
                  list: エピソード情報のリスト
              """
              print(f"チャンネルページから最新のエピソード情報を取得します: {channel_url}")
              
              try:
                  # Chromeオプションを設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  
                  # Chromeドライバーを初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # チャンネルページにアクセス
                  driver.get(channel_url)
                  print(f"チャンネルページにアクセスしました: {channel_url}")
                  
                  # ページが完全に読み込まれるまで待機
                  time.sleep(5)
                  
                  # ページソースを取得
                  page_source = driver.page_source
                  driver.quit()
                  
                  # BeautifulSoupでHTMLを解析
                  soup = BeautifulSoup(page_source, 'html.parser')
                  
                  # エピソード要素を取得
                  episode_elements = soup.select('div.episodeWrapper')
                  print(f"エピソード要素数: {len(episode_elements)}")
                  
                  # エピソード情報を抽出
                  episodes = []
                  for episode_element in episode_elements[:max_episodes]:
                      episode_info = get_episode_info(episode_element)
                      if episode_info:
                          episodes.append(episode_info)
                  
                  print(f"取得したエピソード数: {len(episodes)}")
                  return episodes
              
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  return []

          def main():
              """メイン関数"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # 最新のエピソード情報を取得
              episodes = get_latest_episodes(CHANNEL_URL)
              
              if not episodes:
                  print("エピソードが見つかりませんでした")
                  return
              
              # 各エピソードをダウンロード
              success_count = 0
              for episode in episodes:
                  try:
                      print(f"\n--- エピソード {episode['episode_id']} のダウンロードを開始します ---")
                      success = download_episode(
                          episode['episode_url'],
                          episode['episode_id'],
                          episode['title'],
                          episode['date_str']
                      )
                      
                      if success:
                          success_count += 1
                          print(f"エピソード {episode['episode_id']} のダウンロードに成功しました")
                      else:
                          print(f"エピソード {episode['episode_id']} のダウンロードに失敗しました")
                  
                  except Exception as e:
                      print(f"エピソード {episode['episode_id']} の処理中にエラーが発生しました: {str(e)}")
                      traceback.print_exc()
              
              print(f"\n合計: {len(episodes)}エピソード中{success_count}エピソードのダウンロードに成功しました")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードスクリプトを実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      - name: 変更をコミット
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add docs/podcast/*.mp3
          git commit -m "Update Voicy MP3 files" || echo "No changes to commit"
          git push
