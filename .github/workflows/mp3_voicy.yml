name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"結合されたMP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegエラー: {result.stderr}")
                      
                      # 方法2: 代替方法としてcatコマンドを使用
                      print("代替方法を試行: catコマンドを使用してMP3ファイルを結合")
                      try:
                          with open(output_mp3_path, 'wb') as outfile:
                              for segment in mp3_segments:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          shutil.copyfileobj(infile, outfile)
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"catコマンドによるMP3ファイルの結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              return True
                          else:
                              print(f"catコマンドによるMP3ファイルの結合に失敗しました")
                              return False
                      except Exception as e:
                          print(f"catコマンドによるMP3ファイル結合中にエラーが発生しました: {str(e)}")
                          return False
              
              except Exception as e:
                  print(f"MP3ファイル結合中にエラーが発生しました: {str(e)}")
                  return False
              finally:
                  # 一時ファイルの削除
                  if os.path.exists(mp3_segments_list):
                      os.remove(mp3_segments_list)
              
              return False

          def get_episodes_info_selenium():
              """Seleniumを使用してVoicyから最新のエピソード情報を取得"""
              print(f"::group::Voicyエピソード情報取得（Selenium）")
              print(f"Seleniumを使用してVoicyチャンネルから最新{MAX_EPISODES}件のエピソード情報を取得中...")
              print(f"URL: {CHANNEL_URL}")
              
              try:
                  # Chromeのオプション設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")  # ヘッドレスモード
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                  
                  # WebDriverの初期化 (webdriver_managerを使用)
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  driver.get(CHANNEL_URL)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ページをスクロールして全てのコンテンツを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # ページのHTMLをデバッグ用に保存
                  debug_html_path = f"{DEBUG_DIR}/channel_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"チャンネルページのHTMLを保存しました: {debug_html_path}")
                  
                  # エピソードリンクを取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and "/channel/" in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, "./..")
                                      title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  title = title_element.text if title_element else f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, "time, .date, .episode-date")
                                      date_str = date_element.text
                                  except:
                                      # 日付が見つからない場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  # 日付文字列から日付オブジェクトを作成
                                  try:
                                      # 様々な日付形式に対応
                                      date_formats = [
                                          "%Y-%m-%d",
                                          "%Y年%m月%d日",
                                          "%Y/%m/%d",
                                          "%m月%d日",  # 年がない場合は現在の年を使用
                                          "%m/%d",     # 年がない場合は現在の年を使用
                                      ]
                                      
                                      episode_date = None
                                      for date_format in date_formats:
                                          try:
                                              if "年" in date_str and date_format == "%m月%d日":
                                                  # 「2023年3月1日」のような形式
                                                  continue
                                              
                                              if "月" in date_str and "年" not in date_str and date_format == "%m月%d日":
                                                  # 「3月1日」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              elif "/" in date_str and len(date_str.split("/")) == 2 and date_format == "%m/%d":
                                                  # 「3/1」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              else:
                                                  episode_date = datetime.strptime(date_str, date_format)
                                                  break
                                          except ValueError:
                                              continue
                                      
                                      if episode_date is None:
                                          # どの形式にも合致しない場合は現在の日付を使用
                                          episode_date = datetime.now()
                                      
                                      date_str = episode_date.strftime("%Y-%m-%d")
                                  except Exception as e:
                                      # 日付の解析に失敗した場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  episodes.append({
                                      "id": episode_id,
                                      "title": title,
                                      "url": href,
                                      "date": date_str
                                  })
                                  
                                  if len(episodes) >= MAX_EPISODES:
                                      break
                  
                  driver.quit()
                  
                  if episodes:
                      print(f"{len(episodes)}件のエピソードを取得しました:")
                      for i, episode in enumerate(episodes, 1):
                          print(f"{i}. ID: {episode['id']}, タイトル: {episode['title']}, 日付: {episode['date']}, URL: {episode['url']}")
                      
                      print(f"::endgroup::")
                      return episodes
                  else:
                      print(f"エピソードが見つかりませんでした")
                      print(f"::endgroup::")
                      return []
                  
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def get_audio_url_selenium(episode_url):
              """Seleniumを使用してエピソードページから音声URLを取得"""
              print(f"::group::音声URL取得（Selenium）")
              print(f"エピソードページから音声URLを取得中: {episode_url}")
              
              try:
                  # Chromeのオプション設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")  # ヘッドレスモード
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                  
                  # ネットワークリクエストを監視するためのCDPセッションを設定
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # ネットワークリクエストを監視するためのJavaScriptを実行
                  driver.execute_cdp_cmd("Network.enable", {})
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ページのHTMLをデバッグ用に保存
                  episode_id = episode_url.split('/')[-1]
                  debug_html_path = f"{DEBUG_DIR}/episode_{episode_id}_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"エピソードページのHTMLを保存しました: {debug_html_path}")
                  
                  # 再生ボタンを探して押す
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='再生'], .play-button, .playButton"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                      time.sleep(3)  # 再生開始を待つ
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                      print("再生ボタンが見つからない場合は、既に再生中かもしれません")
                  
                  # 音声URLを探す方法を強化（JSファイルの実装を参考に）
                  audio_urls = []
                  m3u8_urls = []
                  
                  # 方法1: ネットワークリクエストを詳細に分析するためのコードを実行
                  print("ネットワークリクエストを分析中...")
                  audio_detection_script = """
                  // 既存のネットワークリクエストを確認
                  const resources = performance.getEntriesByType('resource');
                  const audioUrls = [];
                  const m3u8Urls = [];
                  
                  resources.forEach(resource => {
                      if (resource.name.includes('.mp3') || 
                          resource.name.includes('.m4a') || 
                          resource.name.includes('.aac') || 
                          resource.name.includes('.wav') || 
                          resource.name.includes('.m3u8') ||
                          resource.name.includes('audio') || 
                          resource.name.includes('media')) {
                          console.log('メディアリソース検出:', resource.name);
                          if (resource.name.includes('.m3u8')) {
                              m3u8Urls.push(resource.name);
                          } else if (resource.name.includes('.mp3') || 
                                     resource.name.includes('.m4a') || 
                                     resource.name.includes('.aac') || 
                                     resource.name.includes('.wav')) {
                              audioUrls.push(resource.name);
                          }
                      }
                  });
                  
                  // オーディオ要素を確認
                  const audioElements = document.querySelectorAll('audio');
                  audioElements.forEach((audio, index) => {
                      console.log('オーディオ要素:', {
                          src: audio.src,
                          currentSrc: audio.currentSrc,
                          paused: audio.paused
                      });
                      
                      if (audio.src) {
                          if (audio.src.includes('.m3u8')) {
                              m3u8Urls.push(audio.src);
                          } else if (audio.src.includes('.mp3') || 
                                     audio.src.includes('.m4a') || 
                                     audio.src.includes('.aac') || 
                                     audio.src.includes('.wav')) {
                              audioUrls.push(audio.src);
                          }
                      }
                      
                      if (audio.currentSrc) {
                          if (audio.currentSrc.includes('.m3u8')) {
                              m3u8Urls.push(audio.currentSrc);
                          } else if (audio.currentSrc.includes('.mp3') || 
                                     audio.currentSrc.includes('.m4a') || 
                                     audio.currentSrc.includes('.aac') || 
                                     audio.currentSrc.includes('.wav')) {
                              audioUrls.push(audio.currentSrc);
                          }
                      }
                  });
                  
                  // video要素も確認
                  const videoElements = document.querySelectorAll('video');
                  videoElements.forEach((video, index) => {
                      console.log('ビデオ要素:', {
                          src: video.src,
                          currentSrc: video.currentSrc,
                          paused: video.paused
                      });
                      
                      if (video.src) {
                          if (video.src.includes('.m3u8')) {
                              m3u8Urls.push(video.src);
                          }
                      }
                      
                      if (video.currentSrc) {
                          if (video.currentSrc.includes('.m3u8')) {
                              m3u8Urls.push(video.currentSrc);
                          }
                      }
                  });
                  
                  // source要素も確認
                  const sourceElements = document.querySelectorAll('source');
                  sourceElements.forEach((source, index) => {
                      console.log('ソース要素:', {
                          src: source.src,
                          type: source.type
                      });
                      
                      if (source.src) {
                          if (source.src.includes('.m3u8')) {
                              m3u8Urls.push(source.src);
                          } else if (source.src.includes('.mp3') || 
                                     source.src.includes('.m4a') || 
                                     source.src.includes('.aac') || 
                                     source.src.includes('.wav')) {
                              audioUrls.push(source.src);
                          }
                      }
                  });
                  
                  // ページ内のすべてのJavaScriptオブジェクトを調査
                  for (let key in window) {
                      try {
                          if (typeof window[key] === 'object' && window[key] !== null) {
                              const objStr = JSON.stringify(window[key]);
                              if (objStr.includes('.mp3') || 
                                  objStr.includes('.m4a') || 
                                  objStr.includes('.aac') || 
                                  objStr.includes('.wav') || 
                                  objStr.includes('.m3u8') ||
                                  objStr.includes('audio_url')) {
                                  console.log('オブジェクト内の音声URL候補:', objStr);
                                  
                                  // m3u8URLを抽出
                                  const m3u8Matches = objStr.match(/(https?:\/\/[^"']+\.m3u8)/g);
                                  if (m3u8Matches) {
                                      m3u8Matches.forEach(url => {
                                          if (!m3u8Urls.includes(url)) {
                                              m3u8Urls.push(url);
                                          }
                                      });
                                  }
                                  
                                  // 音声URLを抽出
                                  const audioMatches = objStr.match(/(https?:\/\/[^"']+\.(mp3|m4a|aac|wav))/g);
                                  if (audioMatches) {
                                      audioMatches.forEach(url => {
                                          if (!audioUrls.includes(url)) {
                                              audioUrls.push(url);
                                          }
                                      });
                                  }
                              }
                          }
                      } catch (e) {
                          // 一部のオブジェクトは循環参照などでJSON化できないため無視
                      }
                  }
                  
                  // audio_urlというキーを持つJSONデータを探す
                  const pageSource = document.documentElement.outerHTML;
                  const audioUrlMatches = pageSource.match(/"audio_url":\s*"([^"]+)"/g);
                  if (audioUrlMatches) {
                      audioUrlMatches.forEach(match => {
                          const url = match.split('"audio_url":')[1].trim().replace(/"/g, '').replace(/,.*$/, '');
                          if (url.includes('.m3u8')) {
                              if (!m3u8Urls.includes(url)) {
                                  m3u8Urls.push(url);
                              }
                          } else if (url.includes('.mp3') || url.includes('.aac')) {
                              if (!audioUrls.includes(url)) {
                                  audioUrls.push(url);
                              }
                          }
                      });
                  }
                  
                  return { audioUrls: [...new Set(audioUrls)], m3u8Urls: [...new Set(m3u8Urls)] };
                  """
                  
                  result = driver.execute_script(audio_detection_script)
                  if result:
                      if 'audioUrls' in result and result['audioUrls']:
                          audio_urls.extend(result['audioUrls'])
                      if 'm3u8Urls' in result and result['m3u8Urls']:
                          m3u8_urls.extend(result['m3u8Urls'])
                  
                  # 結果を表示
                  if m3u8_urls:
                      print(f"検出されたm3u8 URL: {m3u8_urls}")
                      print(f"::endgroup::")
                      return m3u8_urls[0]  # 最初のm3u8 URLを返す
                  elif audio_urls:
                      print(f"検出された音声URL: {audio_urls}")
                      print(f"::endgroup::")
                      return audio_urls[0]  # 最初の音声URLを返す
                  
                  # 方法2: ページソースから直接探す
                  print("方法2: ページソースから直接音声URLを探します")
                  page_source = driver.page_source
                  
                  # m3u8ファイルのURLを探す
                  m3u8_pattern = r'(https?://[^"\']+\.m3u8)'
                  m3u8_matches = re.findall(m3u8_pattern, page_source)
                  if m3u8_matches:
                      print(f"ページソースから検出されたm3u8 URL: {m3u8_matches[0]}")
                      print(f"::endgroup::")
                      return m3u8_matches[0]
                  
                  # mp3ファイルのURLを探す
                  mp3_pattern = r'(https?://[^"\']+\.mp3)'
                  mp3_matches = re.findall(mp3_pattern, page_source)
                  if mp3_matches:
                      print(f"ページソースから検出されたMP3 URL: {mp3_matches[0]}")
                      print(f"::endgroup::")
                      return mp3_matches[0]
                  
                  # 方法3: JSONデータからaudio_urlを探す
                  print("方法3: JSONデータからaudio_urlを探します")
                  json_regex = r'"audio_url"\s*:\s*"([^"]+)"'
                  json_matches = re.findall(json_regex, page_source)
                  if json_matches:
                      audio_url = json_matches[0]
                      print(f"JSONデータから検出された音声URL: {audio_url}")
                      print(f"::endgroup::")
                      return audio_url
                  
                  # 方法4: さらに待機して再試行
                  print("方法4: さらに待機して再試行します")
                  time.sleep(5)  # さらに5秒待機
                  
                  # 再度再生ボタンをクリック
                  try:
                      play_buttons = driver.find_elements(By.CSS_SELECTOR, "button[aria-label='再生'], .play-button, .playButton, [class*='play']")
                      if play_buttons:
                          play_buttons[0].click()
                          print("再度再生ボタンをクリックしました")
                          time.sleep(3)  # 再生開始を待つ
                  except Exception as e:
                      print(f"再度の再生ボタンクリックに失敗しました: {str(e)}")
                  
                  # 再度ネットワークリクエストを分析
                  result = driver.execute_script(audio_detection_script)
                  if result:
                      if 'm3u8Urls' in result and result['m3u8Urls']:
                          print(f"再試行後に検出されたm3u8 URL: {result['m3u8Urls'][0]}")
                          print(f"::endgroup::")
                          return result['m3u8Urls'][0]
                      elif 'audioUrls' in result and result['audioUrls']:
                          print(f"再試行後に検出された音声URL: {result['audioUrls'][0]}")
                          print(f"::endgroup::")
                          return result['audioUrls'][0]
                  
                  # 方法5: 特定のVoicy用のパターンを試す
                  print("方法5: Voicy特有のパターンを試します")
                  voicy_patterns = [
                      r'(https?://[^"\']+/audio/[^"\']+)',
                      r'(https?://[^"\']+/media/[^"\']+)',
                      r'(https?://[^"\']+/stream/[^"\']+)',
                      r'(https?://[^"\']+/content/[^"\']+\.m3u8)',
                      r'(https?://[^"\']+/content/[^"\']+\.mp3)'
                  ]
                  
                  for pattern in voicy_patterns:
                      matches = re.findall(pattern, page_source)
                      if matches:
                          print(f"Voicy特有のパターンで検出された音声URL: {matches[0]}")
                          print(f"::endgroup::")
                          return matches[0]
                  
                  print(f"音声URLが見つかりませんでした")
                  print(f"::endgroup::")
                  return None
                  
              except Exception as e:
                  print(f"音声URLの取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None
              finally:
                  if 'driver' in locals() and driver:
                      driver.quit()

          def download_m3u8_to_mp3(m3u8_url, mp3_path, episode_id):
              """m3u8からMP3をダウンロード"""
              print(f"::group::MP3ダウンロード")
              print(f"オーディオURLからMP3をダウンロード中: {m3u8_url}")
              print(f"出力先: {mp3_path}")
              
              try:
                  # URLの拡張子を確認
                  is_m3u8 = '.m3u8' in m3u8_url.lower()
                  is_mp3 = '.mp3' in m3u8_url.lower()
                  
                  # MP3の場合は直接ダウンロード
                  if is_mp3:
                      print(f"MP3ファイルを直接ダウンロードします")
                      try:
                          response = requests.get(m3u8_url, timeout=30)
                          if response.status_code == 200:
                              with open(mp3_path, 'wb') as f:
                                  f.write(response.content)
                              
                              if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                                  print(f"MP3ファイルのダウンロードに成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                  print(f"::endgroup::")
                                  return mp3_path
                              else:
                                  print(f"MP3ファイルが正常にダウンロードされませんでした")
                          else:
                              print(f"MP3ファイルのダウンロードに失敗しました: ステータスコード {response.status_code}")
                      except Exception as e:
                          print(f"MP3ファイルのダウンロード中にエラーが発生しました: {str(e)}")
                  
                  # m3u8ファイルの場合
                  if is_m3u8:
                      # m3u8ファイルの内容を取得
                      response = requests.get(m3u8_url, timeout=30)
                      if response.status_code != 200:
                          print(f"m3u8ファイルの取得に失敗しました: ステータスコード {response.status_code}")
                          print(f"::endgroup::")
                          return None
                      
                      m3u8_content = response.text
                      
                      # m3u8ファイルをデバッグ用に保存
                      m3u8_debug_path = f"{DEBUG_DIR}/playlist_{episode_id}.m3u8"
                      with open(m3u8_debug_path, 'w') as f:
                          f.write(m3u8_content)
                      print(f"m3u8ファイルを保存しました: {m3u8_debug_path}")
                      
                      # セグメントURLを抽出
                      segment_urls = []
                      base_url = '/'.join(m3u8_url.split('/')[:-1]) + '/'
                      
                      for line in m3u8_content.splitlines():
                          if not line.startswith('#') and line.strip():
                              if line.startswith('http'):
                                  segment_urls.append(line)
                              else:
                                  segment_urls.append(base_url + line)
                      
                      print(f"セグメント数: {len(segment_urls)}")
                      if not segment_urls:
                          print(f"セグメントURLが見つかりませんでした")
                          print(f"::endgroup::")
                          return None
                      
                      # セグメントをダウンロード - AACファイルとして保存（JSファイルの実装に合わせる）
                      segment_files = []
                      for i, url in enumerate(segment_urls):
                          segment_path = f"{TEMP_DIR}/segment_{i:03d}.aac"  # .ts から .aac に変更
                          try:
                              segment_response = requests.get(url, timeout=30)
                              if segment_response.status_code == 200:
                                  with open(segment_path, 'wb') as f:
                                      f.write(segment_response.content)
                                  segment_files.append(segment_path)
                              else:
                                  print(f"セグメント {i} のダウンロードに失敗: ステータスコード {segment_response.status_code}")
                          except Exception as e:
                              print(f"セグメント {i} のダウンロード中にエラー: {str(e)}")
                      
                      print(f"ダウンロードしたセグメント数: {len(segment_files)}")
                      
                      if not segment_files:
                          print(f"セグメントのダウンロードに失敗しました")
                          print(f"::endgroup::")
                          return None
                          
                      # JSファイルの実装に合わせて、直接バイナリ結合する方法を最初に試す
                      print("方法0: 直接バイナリ結合（JSファイルの実装に合わせる）")
                      try:
                          with open(mp3_path, 'wb') as outfile:
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          shutil.copyfileobj(infile, outfile)
                          
                          if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"バイナリ結合によるMP3ファイルの作成に成功しました: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              
                              # 一時ファイルを削除
                              for segment in segment_files:
                                  if os.path.exists(segment):
                                      os.remove(segment)
                              
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"バイナリ結合によるMP3ファイルの作成に失敗しました")
                      except Exception as e:
                          print(f"バイナリ結合中にエラーが発生しました: {str(e)}")
                  
                  # 以下は元の実装をフォールバックとして残す
                  
                  # 方法1: 直接FFmpegを使用してURLからMP3に変換
                  print("方法1: 直接FFmpegを使用してURLからMP3に変換")
                  try:
                      cmd1 = [
                          'ffmpeg',
                          '-i', m3u8_url,
                          '-c:a', 'libmp3lame',
                          '-q:a', '2',
                          '-y',
                          mp3_path
                      ]
                      print(f"FFmpegコマンド（方法1）を実行: {' '.join(cmd1)}")
                      result1 = subprocess.run(cmd1, capture_output=True, text=True)
                      
                      if result1.returncode == 0:
                          print(f"MP3ファイルの作成に成功しました: {mp3_path}")
                          if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                              file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                              print(f"MP3ファイル: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              
                              # 一時ファイルを削除
                              if is_m3u8:
                                  for segment in segment_files:
                                      if os.path.exists(segment):
                                          os.remove(segment)
                              
                              print(f"::endgroup::")
                              return mp3_path
                          else:
                              print(f"MP3ファイルが正常に作成されませんでした")
                      else:
                          print(f"FFmpegエラー（方法1）: {result1.stderr}")
                  except Exception as e:
                      print(f"方法1でのMP3変換中にエラーが発生しました: {str(e)}")
                  
                  # m3u8の場合のみ以下の方法を試行
                  if is_m3u8:
                      # 方法2: セグメントファイルを結合してからMP3に変換
                      print("方法2: セグメントファイルを結合してからMP3に変換")
                      try:
                          # セグメントリストファイルを作成
                          segments_list = f"{TEMP_DIR}/segments.txt"
                          with open(segments_list, 'w') as f:
                              for segment in segment_files:
                                  segment_escaped = segment.replace('\\', '\\\\').replace("'", "\\'")
                                  f.write(f"file '{segment_escaped}'\n")
                          
                          # FFmpegでセグメントファイルを結合
                          combined_file = f"{TEMP_DIR}/combined.aac"
                          cmd2 = [
                              'ffmpeg',
                              '-f', 'concat',
                              '-safe', '0',
                              '-i', segments_list,
                              '-c', 'copy',
                              '-y',
                              combined_file
                          ]
                          print(f"FFmpegコマンド（方法2-1）を実行: {' '.join(cmd2)}")
                          result2 = subprocess.run(cmd2, capture_output=True, text=True)
                          
                          if result2.returncode == 0 and os.path.exists(combined_file) and os.path.getsize(combined_file) > 0:
                              # 結合したファイルをMP3に変換
                              cmd3 = [
                                  'ffmpeg',
                                  '-i', combined_file,
                                  '-c:a', 'libmp3lame',
                                  '-q:a', '2',
                                  '-y',
                                  mp3_path
                              ]
                              print(f"FFmpegコマンド（方法2-2）を実行: {' '.join(cmd3)}")
                              result3 = subprocess.run(cmd3, capture_output=True, text=True)
                              
                              if result3.returncode == 0:
                                  print(f"MP3ファイルの作成に成功しました: {mp3_path}")
                                  if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                                      file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                                      print(f"MP3ファイル: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                                      
                                      # 一時ファイルを削除
                                      for segment in segment_files:
                                          if os.path.exists(segment):
                                              os.remove(segment)
                                      if os.path.exists(segments_list):
                                          os.remove(segments_list)
                                      if os.path.exists(combined_file):
                                          os.remove(combined_file)
                                      
                                      print(f"::endgroup::")
                                      return mp3_path
                                  else:
                                      print(f"MP3ファイルが正常に作成されませんでした")
                              else:
                                  print(f"FFmpegエラー（方法2-2）: {result3.stderr}")
                          else:
                              print(f"FFmpegエラー（方法2-1）: {result2.stderr}")
                      except Exception as e:
                          print(f"方法2でのMP3変換中にエラーが発生しました: {str(e)}")
                  
                  print(f"すべての方法でMP3変換に失敗しました")
                  print(f"::endgroup::")
                  return None
              
              except Exception as e:
                  print(f"MP3ダウンロード中に予期しないエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return None

          def download_episode(episode):
              """エピソードをダウンロード"""
              print(f"::group::エピソード {episode['id']} のダウンロード")
              print(f"エピソード情報: {episode}")
              
              # ファイル名の作成（日付_タイトル_ID.mp3）
              episode_date = episode['date']
              episode_title = episode['title']
              episode_id = episode['id']
              
              # ファイル名に使用できない文字を置換
              safe_title = re.sub(r'[\\/*?:"<>|]', '_', episode_title)
              safe_title = safe_title[:50]  # タイトルの長さを制限
              
              # 有料放送かどうかを判断
              is_premium = False
              
              # プレミアムリスナー限定コンテンツかどうかを確認
              try:
                  # URLからエピソードページのHTMLを取得して確認する方法
                  episode_url = episode['url']
                  
                  # ページのHTMLを取得して有料放送かどうかを確認
                  try:
                      import requests
                      from bs4 import BeautifulSoup
                      
                      headers = {
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                      }
                      
                      response = requests.get(episode_url, headers=headers, timeout=10)
                      if response.status_code == 200:
                          soup = BeautifulSoup(response.text, 'html.parser')
                          
                          # 有料放送を示す文言を検索
                          premium_texts = [
                              'こちらの放送はプレミアムリスナーの方のみ聴くことができます',
                              'プレミアムリスナー限定',
                              '過去配信は随時プレミアム放送',
                              'プレミアム放送となっています'
                          ]
                          
                          for text in premium_texts:
                              if soup.find(text=lambda t: t and text in t):
                                  is_premium = True
                                  print(f"プレミアムコンテンツを検出しました: {episode_url}")
                                  break
                          
                          # プレミアムアイコンや特定のクラスも確認
                          premium_icons = soup.find_all(class_=lambda c: c and ('premium' in c.lower() if c else False))
                          if premium_icons:
                              is_premium = True
                              print(f"プレミアムアイコンを検出しました: {episode_url}")
                  except Exception as e:
                      print(f"HTMLの取得・解析中にエラー: {str(e)}")
                      
                  # URLパターンでも確認（バックアップ方法）
                  if "premium" in episode_url.lower() or "/premium/" in episode_url.lower() or "premium=1" in episode_url.lower():
                      is_premium = True
                      print(f"URLからプレミアムコンテンツと判定: {episode_url}")
              except Exception as e:
                  print(f"プレミアムコンテンツ判定中にエラー: {str(e)}")
              
              # 有料放送の場合はファイル名の先頭にアンダーバーを追加
              # ユーザーの要件に従い、episode['date']を削除
              if is_premium:
                  mp3_filename = f"_{safe_title}_{episode_id}.mp3"
              else:
                  mp3_filename = f"{safe_title}_{episode_id}.mp3"
              mp3_path = os.path.join(MP3_DIR, mp3_filename)
              
              # 既にダウンロード済みかチェック
              if os.path.exists(mp3_path) and os.path.getsize(mp3_path) > 0:
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024)
                  print(f"エピソード {episode_id} は既にダウンロード済みです: {mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                  print(f"::endgroup::")
                  return mp3_path
              
              # 音声URLを取得
              audio_url = get_audio_url_selenium(episode['url'])
              if not audio_url:
                  print(f"エピソード {episode_id} の音声URLが取得できませんでした")
                  print(f"::endgroup::")
                  return None
              
              # MP3をダウンロード
              mp3_file = download_m3u8_to_mp3(audio_url, mp3_path, episode_id)
              
              if mp3_file:
                  print(f"エピソード {episode_id} のダウンロードに成功しました: {mp3_path}")
                  print(f"::endgroup::")
                  return mp3_path
              else:
                  print(f"エピソード {episode_id} のダウンロードに失敗しました")
                  print(f"::endgroup::")
                  return None

          def main():
              """メイン処理"""
              print("Voicy MP3ダウンローダーを開始します")
              
              # 必要なディレクトリを作成
              setup_directories()
              
              # エピソード情報を取得
              episodes = get_episodes_info_selenium()
              
              if not episodes:
                  print("エピソードが取得できませんでした。処理を終了します。")
                  return
              
              # 各エピソードをダウンロード
              downloaded_files = []
              for episode in episodes:
                  mp3_file = download_episode(episode)
                  if mp3_file:
                      downloaded_files.append(mp3_file)
              
              # ダウンロード結果を表示
              print("\n=== ダウンロード結果 ===")
              mp3_files = [f for f in os.listdir(MP3_DIR) if f.endswith('.mp3')]
              for i, mp3_file in enumerate(mp3_files, 1):
                  mp3_path = os.path.join(MP3_DIR, mp3_file)
                  file_size_mb = os.path.getsize(mp3_path) / (1024 * 1024) if os.path.exists(mp3_path) else 0
                  
                  # ファイル名から情報を抽出（新しいフォーマットに対応）
                  # 有料放送（アンダーバー始まり）と無料放送の両方に対応
                  if mp3_file.startswith('_'):
                      # 有料放送: _タイトル_ID.mp3
                      match = re.match(r'_(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          title, episode_id = match.groups()
                          print(f"{i}. ID: {episode_id} [プレミアム]")
                          print(f"   タイトル: {title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB\n")
                      else:
                          print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
                  else:
                      # 無料放送: タイトル_ID.mp3
                      match = re.match(r'(.+)_(\d+)\.mp3', mp3_file)
                      if match:
                          title, episode_id = match.groups()
                          print(f"{i}. ID: {episode_id}")
                          print(f"   タイトル: {title}")
                          print(f"   ファイル: {mp3_file}")
                          print(f"   サイズ: {file_size_mb:.2f}MB\n")
                  else:
                      print(f"{i}. {mp3_file} (サイズ: {file_size_mb:.2f}MB)")
              
              print(f"合計: {len(mp3_files)}個のMP3ファイル")
              print("Voicy MP3ダウンローダーを終了します")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Voicy MP3ダウンロードの実行
        run: |
          python voicy_mp3_downloader_v3.py
      
      # アーティファクトアップロード部分を完全に修正
      - name: MP3ファイルリストの作成
        run: |
          mkdir -p mp3_downloads
          find mp3_downloads -name "*.mp3" > mp3_files.txt
          echo "MP3ファイルリスト:"
          cat mp3_files.txt
      
      # 各MP3ファイルを個別にアップロード
      - name: MP3ファイルのアップロード
        run: |
          if [ -s mp3_files.txt ]; then
            while IFS= read -r file; do
              filename=$(basename "$file")
              echo "アップロード: $filename"
              
              # ファイルをGitHubにコミット
              git config --global user.name 'GitHub Actions'
              git config --global user.email 'actions@github.com'
              git add "$file"
              git commit -m "MP3ファイルを追加: $filename" || true
              git push || true
              
              # ファイルをリリースアセットとして添付
              echo "::notice::MP3ファイルをダウンロードしました: $filename"
            done < mp3_files.txt
          else
            echo "アップロードするMP3ファイルがありません"
          fi
      
      # デバッグファイルはコミットせずに保存
      - name: デバッグファイルの保存
        run: |
          mkdir -p debug_files
          echo "デバッグファイル:"
          find debug_files -type f | sort
      
      - name: 処理結果の通知
        run: |
          echo "::notice::Voicy MP3ダウンロードが完了しました"
          echo "::notice::MP3ファイルはリポジトリのmp3_downloadsディレクトリに保存されています"w
