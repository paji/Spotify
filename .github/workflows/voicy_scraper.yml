name: Voicy URL Scraper

on:
  schedule:
    - cron: '31 9 * * *'  # 6時38分に実行
    - cron: '1 21 * * *'  # 18時01分に実行
  workflow_dispatch:  # 手動実行用
# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-url-scraper:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v4
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@latest
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager tqdm
      
      - name: Voicy URL スクレイピングスクリプト作成
        run: |
          cat > voicy_url_scraper.py << 'EOF'
          import os
          import re
          import json
          import time
          import random
          from datetime import datetime, timedelta, timezone

          # JSTタイムゾーンの定義
          JST = timezone(timedelta(hours=9))
          
          def to_jst(dt):
              """
              タイムゾーン情報のないdatetimeオブジェクトをJSTに変換する
              
              Args:
                  dt: 変換するdatetimeオブジェクト
                  
              Returns:
                  datetime: JSTタイムゾーン情報を持つdatetimeオブジェクト
              """
              if dt.tzinfo is None:
                  return dt.replace(tzinfo=JST)
              return dt.astimezone(JST)
          from bs4 import BeautifulSoup
          import traceback
          from tqdm import tqdm
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # 裏・パジちゃんねる
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # チャンネル全エピソードページ

          # 出力ファイル設定
          OUTPUT_DIR = "output"
          OUTPUT_JSON = os.path.join(OUTPUT_DIR, "voicy_episodes.json")
          OUTPUT_URLS_ONLY = os.path.join(OUTPUT_DIR, "voicy_urls_only.json")
          DEBUG_DIR = os.path.join(OUTPUT_DIR, "debug")

          # スクレイピング設定
          MAX_RETRIES = 5  # 最大リトライ回数
          SCROLL_PAUSE_TIME = 1  # スクロール間の待機時間（秒）
          MAX_SCROLL_ATTEMPTS = 2  # 最大スクロール試行回数（約20件のエピソードを取得するため）
          TARGET_EPISODES = 20  # 目標エピソード数

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [OUTPUT_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          def random_sleep(min_seconds=0.5, max_seconds=1.5):
              """ランダムな時間スリープする（サーバー負荷軽減のため）"""
              sleep_time = random.uniform(min_seconds, max_seconds)
              time.sleep(sleep_time)
              return sleep_time

          def load_existing_episodes():
              """
              既存のJSONファイルからエピソード情報を読み込む関数
              
              Returns:
                  tuple: (既存のエピソードリスト, 既存のエピソードIDのセット)
              """
              existing_episodes = []
              existing_episode_ids = set()
              
              if os.path.exists(OUTPUT_JSON):
                  try:
                      with open(OUTPUT_JSON, 'r', encoding='utf-8') as f:
                          existing_episodes = json.load(f)
                          
                      # エピソードIDのセットを作成
                      for episode in existing_episodes:
                          if "id" in episode:
                              existing_episode_ids.add(episode["id"])
                      
                      print(f"既存のJSONファイルから {len(existing_episodes)} 件のエピソード情報を読み込みました。")
                      print(f"重複チェック用に {len(existing_episode_ids)} 件のエピソードIDを準備しました。")
                  except Exception as e:
                      print(f"既存のJSONファイルの読み込み中にエラーが発生しました: {e}")
              else:
                  print(f"既存のJSONファイル {OUTPUT_JSON} が見つかりませんでした。新規作成します。")
              
              return existing_episodes, existing_episode_ids

          def check_premium_content(parent):
              """
              親要素から有料配信かどうかを判定する関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  bool: 有料配信の場合はTrue、無料配信の場合はFalse
              """
              try:
                  # 方法1: Pアイコンを直接検索
                  try:
                      p_icon = parent.find_element(By.CSS_SELECTOR, ".premium-icon, .paid-icon, .p-icon, [class*='premium'], [class*='paid']")
                      if p_icon:
                          return True
                  except NoSuchElementException:
                      pass
                  
                  # 方法2: 「P」テキストを含む要素を検索
                  try:
                      p_text_elements = parent.find_elements(By.XPATH, ".//*[contains(text(), 'P') or contains(text(), 'プレミアム')]")
                      for element in p_text_elements:
                          if element.text.strip() == "P" or "プレミアム" in element.text:
                              return True
                  except:
                      pass
                  
                  # 方法3: 画像やSVGのalt属性やsrc属性を確認
                  try:
                      images = parent.find_elements(By.CSS_SELECTOR, "img, svg")
                      for img in images:
                          alt = img.get_attribute("alt") or ""
                          src = img.get_attribute("src") or ""
                          if "premium" in alt.lower() or "paid" in alt.lower() or "p-icon" in src.lower() or "premium" in src.lower():
                              return True
                  except:
                      pass
                  
                  # 方法4: クラス名に「premium」や「paid」が含まれる要素を探す
                  try:
                      elements = parent.find_elements(By.XPATH, ".//*")
                      for element in elements:
                          class_name = element.get_attribute("class") or ""
                          if "premium" in class_name.lower() or "paid" in class_name.lower():
                              return True
                  except:
                      pass
                  
                  return False
              except:
                  return False
          
          def find_time_elements(parent):
              """
              親要素から時間関連の要素を検索する関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  list: 時間関連の要素のリスト（要素、検索方法、優先度）
              """
              time_elements = []
              
              try:
                  # 1. timeタグを検索（最も信頼性が高い）
                  try:
                      time_tags = parent.find_elements(By.CSS_SELECTOR, "time")
                      for element in time_tags:
                          time_elements.append((element, "time_tag", 10))
                  except:
                      pass
                  
                  # 2. 日付関連のクラス名を持つ要素を検索
                  date_classes = [
                      ".date", ".time", ".datetime", ".timestamp", ".episode-date", 
                      ".published-date", ".release-date", "[class*='date']", "[class*='time']"
                  ]
                  try:
                      for selector in date_classes:
                          elements = parent.find_elements(By.CSS_SELECTOR, selector)
                          for element in elements:
                              time_elements.append((element, f"class_{selector}", 8))
                  except:
                      pass
                  
                  # 3. 日付パターンを含むテキストを持つ要素を検索
                  try:
                      all_elements = parent.find_elements(By.XPATH, ".//*")
                      for element in all_elements:
                          try:
                              text = element.text.strip()
                              if text and (
                                  re.search(r'\d{1,4}[年/\-]\d{1,2}[月/\-]\d{1,2}', text) or  # 年月日パターン
                                  re.search(r'\d{1,2}[月/\-]\d{1,2}', text) or  # 月日パターン
                                  re.search(r'\d+\s*(時間|日|週間|ヶ月|カ月|ヵ月|か月|年)\s*前', text) or  # 相対時間パターン
                                  '今日' in text or '昨日' in text or '一昨日' in text  # 特殊な相対日付
                              ):
                                  time_elements.append((element, "text_pattern", 6))
                          except:
                              pass
                  except:
                      pass
                  
                  # 4. data-*属性を持つ要素を検索
                  try:
                      elements_with_data = parent.find_elements(By.CSS_SELECTOR, "[data-timestamp], [data-date], [data-time], [data-datetime]")
                      for element in elements_with_data:
                          time_elements.append((element, "data_attribute", 9))
                  except:
                      pass
              except:
                  pass
              
              return time_elements
          
          def get_date_from_element_attributes(element):
              """
              要素の属性から日付情報を抽出する関数
              
              Args:
                  element: Seleniumの要素オブジェクト
                  
              Returns:
                  tuple: (datetime オブジェクト, 日付文字列, 信頼性スコア, 抽出方法)
              """
              try:
                  # 1. data-timestamp属性を確認（Unixタイムスタンプ）
                  timestamp = element.get_attribute("data-timestamp")
                  if timestamp and timestamp.isdigit():
                      # Unixタイムスタンプを日時に変換
                      date_obj = datetime.fromtimestamp(int(timestamp), JST)
                      return date_obj, element.text.strip(), 10, "timestamp_attribute"
                  
                  # 2. datetime属性を確認（ISO形式の日時）
                  datetime_attr = element.get_attribute("datetime")
                  if datetime_attr:
                      try:
                          # ISO形式の日時を解析
                          date_obj = to_jst(datetime.fromisoformat(datetime_attr.replace("Z", "+00:00")))
                          return date_obj, element.text.strip(), 9, "datetime_attribute"
                      except ValueError:
                          pass
                  
                  # 3. data-date属性を確認
                  date_attr = element.get_attribute("data-date")
                  if date_attr:
                      try:
                          # 様々な形式を試す
                          for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%Y%m%d"]:
                              try:
                                  date_obj = to_jst(datetime.strptime(date_attr, fmt))
                                  return date_obj, element.text.strip(), 8, "date_attribute"
                              except ValueError:
                                  continue
                      except:
                          pass
                  
                  # 4. その他のdata-*属性を確認
                  for attr_name in ["data-time", "data-datetime", "data-published"]:
                      attr_value = element.get_attribute(attr_name)
                      if attr_value:
                          # parse_date_stringを使用して解析を試みる
                          date_obj = parse_date_string(attr_value)
                          if date_obj:
                              return date_obj, element.text.strip(), 7, f"{attr_name}_attribute"
              except:
                  pass
              
              return None, None, 0, None
          
          def get_date_from_text(text):
              """
              テキストから日付情報を抽出する関数（相対表現の改善版）
              
              Args:
                  text: 日付を表す可能性のあるテキスト
                  
              Returns:
                  tuple: (datetime オブジェクト, 信頼性スコア, 抽出方法)
              """
              if not text:
                  return None, 0, None
              
              # 現在の日時を取得（相対日付計算用）
              now = datetime.now()
              
              try:
                  # 1. 分前の解析（例: 5分前）
                  minute_match = re.search(r'(\d+)\s*分\s*前', text)
                  if minute_match:
                      value = int(minute_match.group(1))
                      return now - timedelta(minutes=value), 8, "minutes_ago"
                  
                  # 2. 時間前の解析（例: 3時間前）
                  hour_match = re.search(r'(\d+)\s*時間\s*前', text)
                  if hour_match:
                      value = int(hour_match.group(1))
                      return now - timedelta(hours=value), 8, "hours_ago"
                  
                  # 3. 日前の解析（例: 3日前）
                  day_match = re.search(r'(\d+)\s*日\s*前', text)
                  if day_match:
                      value = int(day_match.group(1))
                      return now - timedelta(days=value), 8, "days_ago"
                  
                  # 4. 週間前の解析（例: 1週間前）
                  week_match = re.search(r'(\d+)\s*週間\s*前', text)
                  if week_match:
                      value = int(week_match.group(1))
                      return now - timedelta(weeks=value), 7, "weeks_ago"
                  
                  # 5. 月前の解析（例: 2ヶ月前）
                  month_match = re.search(r'(\d+)\s*(ヶ月|カ月|ヵ月|か月)\s*前', text)
                  if month_match:
                      value = int(month_match.group(1))
                      # 月は正確な日数がないので近似値を使用
                      return now - timedelta(days=value * 30), 6, "months_ago"
                  
                  # 6. 年前の解析（例: 1年前）
                  year_match = re.search(r'(\d+)\s*年\s*前', text)
                  if year_match:
                      value = int(year_match.group(1))
                      # 年も近似値を使用
                      return now - timedelta(days=value * 365), 5, "years_ago"
                  
                  # 7. 「今日」「昨日」「一昨日」などの特殊な相対日付
                  if '今日' in text:
                      return now, 8, "today"
                  elif '昨日' in text:
                      return now - timedelta(days=1), 8, "yesterday"
                  elif '一昨日' in text or '2日前' in text:
                      return now - timedelta(days=2), 8, "day_before_yesterday"
                  
                  # 8. 日付フォーマットのパターンを試行
                  date_formats = [
                      # 年月日 時分 形式
                      ("%Y年%m月%d日 %H時%M分", 9, "full_jp_datetime"),
                      ("%Y年%m月%d日 %H:%M", 9, "jp_date_colon_time"),
                      ("%Y/%m/%d %H:%M", 9, "slash_date_colon_time"),
                      ("%Y-%m-%d %H:%M", 9, "hyphen_date_colon_time"),
                      # 年月日のみ
                      ("%Y年%m月%d日", 8, "full_jp_date"),
                      ("%Y/%m/%d", 8, "slash_date"),
                      ("%Y-%m-%d", 8, "hyphen_date"),
                      # 月日 時分 形式
                      ("%m月%d日 %H時%M分", 7, "jp_month_day_time"),
                      ("%m月%d日 %H:%M", 7, "jp_month_day_colon_time"),
                      ("%m/%d %H:%M", 7, "slash_month_day_time"),
                      # 月日のみ
                      ("%m月%d日", 6, "jp_month_day"),
                      ("%m/%d", 6, "slash_month_day")
                  ]
                  
                  for date_format, score, method in date_formats:
                      try:
                          # 時間情報を含まないフォーマットで年が省略されている場合
                          if (len(date_format.split()) > 0 and "年" not in date_format.split()[0] and "/" not in date_format.split()[0] and "-" not in date_format.split()[0]) and \
                             (len(text.split()) > 0 and "年" not in text.split()[0] and "/" not in text.split()[0] and "-" not in text.split()[0]):
                              # 現在の年を使用
                              parsed_date = to_jst(datetime.strptime(text, date_format))
                              return parsed_date.replace(year=now.year), score, method
                          
                          # 完全な日付
                          return to_jst(datetime.strptime(text, date_format)), score, method
                      except (ValueError, IndexError):
                          continue
              except Exception as e:
                  print(f"日付テキスト '{text}' の解析中にエラーが発生しました: {e}")
              
              return None, 0, None
          
          def parse_date_from_element(parent):
              """
              親要素から日付情報を階層的に抽出する改良版関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  tuple: (datetime オブジェクト, 日付文字列, 元の日時表現)
              """
              # 結果を格納する変数
              best_date = None
              best_date_str = None
              best_score = 0
              best_method = None
              original_text = ""
              debug_info = {}
              
              # 1. 時間関連の要素を検索
              time_elements = find_time_elements(parent)
              
              # 元の日時表現を取得
              for element, method, _ in time_elements:
                  if element.text.strip():
                      original_text = element.text.strip()
                      break
              for element, search_method, base_priority in time_elements:
                  # 2.1 要素の属性から日付情報を抽出
                  date_obj, date_str, attr_score, attr_method = get_date_from_element_attributes(element)
                  if date_obj and attr_score > 0:
                      total_score = attr_score + base_priority
                      debug_info[f"{search_method}_{attr_method}"] = {
                          "date": date_obj.isoformat(),
                          "text": date_str,
                          "score": total_score
                      }
                      
                      if total_score > best_score:
                          best_date = date_obj
                          best_date_str = date_str
                          best_score = total_score
                          best_method = f"{search_method}_{attr_method}"
                  
                  # 2.2 要素のテキストから日付情報を抽出
                  try:
                      element_text = element.text.strip()
                      if element_text:
                          text_date, text_score, text_method = get_date_from_text(element_text)
                          if text_date and text_score > 0:
                              total_score = text_score + base_priority
                              debug_info[f"{search_method}_{text_method}"] = {
                                  "date": text_date.isoformat(),
                                  "text": element_text,
                                  "score": total_score
                              }
                              
                              if total_score > best_score:
                                  best_date = text_date
                                  best_date_str = element_text
                                  best_score = total_score
                                  best_method = f"{search_method}_{text_method}"
                  except:
                      pass
              
              # 3. 日付情報が見つからなかった場合、親要素のテキスト全体から抽出を試みる
              if not best_date:
                  try:
                      parent_text = parent.text.strip()
                      if parent_text:
                          # 行ごとに分割して各行で日付を探す
                          lines = parent_text.split('\n')
                          for line in lines:
                              line = line.strip()
                              if line:
                                  text_date, text_score, text_method = get_date_from_text(line)
                                  if text_date and text_score > 0:
                                      debug_info[f"parent_text_{text_method}"] = {
                                          "date": text_date.isoformat(),
                                          "text": line,
                                          "score": text_score
                                      }
                                      
                                      if text_score > best_score:
                                          best_date = text_date
                                          best_date_str = line
                                          best_score = text_score
                                          best_method = f"parent_text_{text_method}"
                  except:
                      pass
              
              # デバッグ情報を出力
              if debug_info:
                  print(f"日付抽出方法: {best_method}, スコア: {best_score}")
              
              return best_date, best_date_str, original_text

          def parse_date_string(date_str):
              """
              日付文字列を解析してdatetimeオブジェクトに変換する関数
              
              Args:
                  date_str: 日付を表す文字列
                  
              Returns:
                  datetime: 解析された日時オブジェクト、解析失敗時はNone
              """
              if not date_str:
                  return None
              
              # 現在の日時を取得（相対日付計算用）
              now = datetime.now(JST)
              
              try:
                  # 1. 分前の解析（例: 5分前）- 最優先
                  minute_match = re.search(r'(\d+)\s*分\s*前', date_str)
                  if minute_match:
                      value = int(minute_match.group(1))
                      return now - timedelta(minutes=value)
                  
                  # 2. 時間前の解析（例: 3時間前）- 次に優先
                  hour_match = re.search(r'(\d+)\s*時間\s*前', date_str)
                  if hour_match:
                      value = int(hour_match.group(1))
                      return now - timedelta(hours=value)
                  
                  # 3. その他の相対日付の解析（例: 3日前、1週間前）
                  relative_match = re.search(r'(\d+)\s*(日|週間|ヶ月|カ月|ヵ月|か月|年)\s*前', date_str)
                  if relative_match:
                      value = int(relative_match.group(1))
                      unit = relative_match.group(2)
                      
                      if unit == '日':
                          return now - timedelta(days=value)
                      elif unit == '週間':
                          return now - timedelta(weeks=value)
                      elif unit in ['ヶ月', 'カ月', 'ヵ月', 'か月']:
                          # 月は正確な日数がないので近似値を使用
                          return now - timedelta(days=value * 30)
                      elif unit == '年':
                          # 年も近似値を使用
                          return now - timedelta(days=value * 365)
                  
                  # 2. 「今日」「昨日」「一昨日」などの特殊な相対日付 - 高優先度
                  if '今日' in date_str:
                      return now
                  elif '昨日' in date_str:
                      return now - timedelta(days=1)
                  elif '一昨日' in date_str or '2日前' in date_str:
                      return now - timedelta(days=2)
                  
                  # 3. 日付フォーマットのパターンを試行
                  date_formats = [
                      # 年月日 時分 形式
                      "%Y年%m月%d日 %H時%M分",
                      "%Y年%m月%d日 %H:%M",
                      "%Y/%m/%d %H:%M",
                      "%Y-%m-%d %H:%M",
                      # 年月日のみ
                      "%Y年%m月%d日",
                      "%Y/%m/%d",
                      "%Y-%m-%d",
                      # 月日 時分 形式
                      "%m月%d日 %H時%M分",
                      "%m月%d日 %H:%M",
                      "%m/%d %H:%M",
                      # 月日のみ
                      "%m月%d日",
                      "%m/%d"
                  ]
                  
                  for date_format in date_formats:
                      try:
                          # 時間情報を含まないフォーマットで年が省略されている場合
                          if (len(date_format.split()) > 0 and "年" not in date_format.split()[0] and "/" not in date_format.split()[0] and "-" not in date_format.split()[0]) and \
                             (len(date_str.split()) > 0 and "年" not in date_str.split()[0] and "/" not in date_str.split()[0] and "-" not in date_str.split()[0]):
                              # 現在の年を使用
                              parsed_date = to_jst(datetime.strptime(date_str, date_format))
                              return parsed_date.replace(year=now.year)
                          
                          # 完全な日付
                          return to_jst(datetime.strptime(date_str, date_format))
                      except (ValueError, IndexError):
                          continue
              
              except Exception as e:
                  print(f"日付の解析中にエラーが発生しました: {e}")
              
              # 解析できなかった場合はNoneを返す
              return None

          def get_episodes_info_selenium():
              """
              Seleniumを使用してVoicyチャンネルのエピソード情報を取得する関数
              
              Returns:
                  list: エピソード情報のリスト
              """
              print(f"Voicyチャンネル {CHANNEL_URL} からエピソード情報を取得します...")
              
              # 既存のエピソード情報を読み込む（IDの重複チェック用のみ）
              _, existing_episode_ids = load_existing_episodes()
              
              episodes = []
              episode_ids_seen = existing_episode_ids.copy()  # 既存のエピソードIDをコピー
              retry_count = 0
              
              print(f"重複チェック用に {len(episode_ids_seen)} 件の既存エピソードIDを読み込みました。")
              
              try:
                  # Chromeオプションの設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument
