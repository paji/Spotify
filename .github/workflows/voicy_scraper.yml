name: Voicy URL Scraper

on:
  schedule:
    - cron: '31 * * * *'  # 毎時31分に実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-url-scraper:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v4
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@latest
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager tqdm
      
      - name: Voicy URL スクレイピングスクリプト作成
        run: |
          cat > voicy_url_scraper.py << 'EOF'
          import os
          import re
          import json
          import time
          import random
          from datetime import datetime, timedelta, timezone

          # JSTタイムゾーンの定義
          JST = timezone(timedelta(hours=9))
          
          def to_jst(dt):
              """
              タイムゾーン情報のないdatetimeオブジェクトをJSTに変換する
              
              Args:
                  dt: 変換するdatetimeオブジェクト
                  
              Returns:
                  datetime: JSTタイムゾーン情報を持つdatetimeオブジェクト
              """
              if dt.tzinfo is None:
                  return dt.replace(tzinfo=JST)
              return dt.astimezone(JST)
          from bs4 import BeautifulSoup
          import traceback
          from tqdm import tqdm
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # 裏・パジちゃんねる
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}/all"  # チャンネル全エピソードページ

          # 出力ファイル設定
          OUTPUT_DIR = "output"
          OUTPUT_JSON = os.path.join(OUTPUT_DIR, "voicy_episodes.json")
          OUTPUT_URLS_ONLY = os.path.join(OUTPUT_DIR, "voicy_urls_only.json")
          DEBUG_DIR = os.path.join(OUTPUT_DIR, "debug")

          # スクレイピング設定
          MAX_RETRIES = 5  # 最大リトライ回数
          SCROLL_PAUSE_TIME = 1  # スクロール間の待機時間（秒）
          MAX_SCROLL_ATTEMPTS = 2  # 最大スクロール試行回数（約20件のエピソードを取得するため）
          TARGET_EPISODES = 20  # 目標エピソード数

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [OUTPUT_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          def random_sleep(min_seconds=0.5, max_seconds=1.5):
              """ランダムな時間スリープする（サーバー負荷軽減のため）"""
              sleep_time = random.uniform(min_seconds, max_seconds)
              time.sleep(sleep_time)
              return sleep_time

          def load_existing_episodes():
              """
              既存のJSONファイルからエピソード情報を読み込む関数
              
              Returns:
                  tuple: (既存のエピソードリスト, 既存のエピソードIDのセット)
              """
              existing_episodes = []
              existing_episode_ids = set()
              
              if os.path.exists(OUTPUT_JSON):
                  try:
                      with open(OUTPUT_JSON, 'r', encoding='utf-8') as f:
                          existing_episodes = json.load(f)
                          
                      # エピソードIDのセットを作成
                      for episode in existing_episodes:
                          if "id" in episode:
                              existing_episode_ids.add(episode["id"])
                      
                      print(f"既存のJSONファイルから {len(existing_episodes)} 件のエピソード情報を読み込みました。")
                      print(f"重複チェック用に {len(existing_episode_ids)} 件のエピソードIDを準備しました。")
                  except Exception as e:
                      print(f"既存のJSONファイルの読み込み中にエラーが発生しました: {e}")
              else:
                  print(f"既存のJSONファイル {OUTPUT_JSON} が見つかりませんでした。新規作成します。")
              
              return existing_episodes, existing_episode_ids

          def check_premium_content(parent):
              """
              親要素から有料配信かどうかを判定する関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  bool: 有料配信の場合はTrue、無料配信の場合はFalse
              """
              try:
                  # 方法1: Pアイコンを直接検索
                  try:
                      p_icon = parent.find_element(By.CSS_SELECTOR, ".premium-icon, .paid-icon, .p-icon, [class*='premium'], [class*='paid']")
                      if p_icon:
                          return True
                  except NoSuchElementException:
                      pass
                  
                  # 方法2: 「P」テキストを含む要素を検索
                  try:
                      p_text_elements = parent.find_elements(By.XPATH, ".//*[contains(text(), 'P') or contains(text(), 'プレミアム')]")
                      for element in p_text_elements:
                          if element.text.strip() == "P" or "プレミアム" in element.text:
                              return True
                  except:
                      pass
                  
                  # 方法3: 画像やSVGのalt属性やsrc属性を確認
                  try:
                      images = parent.find_elements(By.CSS_SELECTOR, "img, svg")
                      for img in images:
                          alt = img.get_attribute("alt") or ""
                          src = img.get_attribute("src") or ""
                          if "premium" in alt.lower() or "paid" in alt.lower() or "p-icon" in src.lower() or "premium" in src.lower():
                              return True
                  except:
                      pass
                  
                  # 方法4: クラス名に「premium」や「paid」が含まれる要素を探す
                  try:
                      elements = parent.find_elements(By.XPATH, ".//*")
                      for element in elements:
                          class_name = element.get_attribute("class") or ""
                          if "premium" in class_name.lower() or "paid" in class_name.lower():
                              return True
                  except:
                      pass
                  
                  return False
              except:
                  return False
          
          def find_time_elements(parent):
              """
              親要素から時間関連の要素を検索する関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  list: 時間関連の要素のリスト（要素、検索方法、優先度）
              """
              time_elements = []
              
              try:
                  # 1. timeタグを検索（最も信頼性が高い）
                  try:
                      time_tags = parent.find_elements(By.CSS_SELECTOR, "time")
                      for element in time_tags:
                          time_elements.append((element, "time_tag", 10))
                  except:
                      pass
                  
                  # 2. 日付関連のクラス名を持つ要素を検索
                  date_classes = [
                      ".date", ".time", ".datetime", ".timestamp", ".episode-date", 
                      ".published-date", ".release-date", "[class*='date']", "[class*='time']"
                  ]
                  try:
                      for selector in date_classes:
                          elements = parent.find_elements(By.CSS_SELECTOR, selector)
                          for element in elements:
                              time_elements.append((element, f"class_{selector}", 8))
                  except:
                      pass
                  
                  # 3. 日付パターンを含むテキストを持つ要素を検索
                  try:
                      all_elements = parent.find_elements(By.XPATH, ".//*")
                      for element in all_elements:
                          try:
                              text = element.text.strip()
                              if text and (
                                  re.search(r'\d{1,4}[年/\-]\d{1,2}[月/\-]\d{1,2}', text) or  # 年月日パターン
                                  re.search(r'\d{1,2}[月/\-]\d{1,2}', text) or  # 月日パターン
                                  re.search(r'\d+\s*(時間|日|週間|ヶ月|カ月|ヵ月|か月|年)\s*前', text) or  # 相対時間パターン
                                  '今日' in text or '昨日' in text or '一昨日' in text  # 特殊な相対日付
                              ):
                                  time_elements.append((element, "text_pattern", 6))
                          except:
                              pass
                  except:
                      pass
                  
                  # 4. data-*属性を持つ要素を検索
                  try:
                      elements_with_data = parent.find_elements(By.CSS_SELECTOR, "[data-timestamp], [data-date], [data-time], [data-datetime]")
                      for element in elements_with_data:
                          time_elements.append((element, "data_attribute", 9))
                  except:
                      pass
              except:
                  pass
              
              return time_elements
          
          def get_date_from_element_attributes(element):
              """
              要素の属性から日付情報を抽出する関数
              
              Args:
                  element: Seleniumの要素オブジェクト
                  
              Returns:
                  tuple: (datetime オブジェクト, 日付文字列, 信頼性スコア, 抽出方法)
              """
              try:
                  # 1. data-timestamp属性を確認（Unixタイムスタンプ）
                  timestamp = element.get_attribute("data-timestamp")
                  if timestamp and timestamp.isdigit():
                      # Unixタイムスタンプを日時に変換
                      date_obj = datetime.fromtimestamp(int(timestamp), JST)
                      return date_obj, element.text.strip(), 10, "timestamp_attribute"
                  
                  # 2. datetime属性を確認（ISO形式の日時）
                  datetime_attr = element.get_attribute("datetime")
                  if datetime_attr:
                      try:
                          # ISO形式の日時を解析
                          date_obj = to_jst(datetime.fromisoformat(datetime_attr.replace("Z", "+00:00")))
                          return date_obj, element.text.strip(), 9, "datetime_attribute"
                      except ValueError:
                          pass
                  
                  # 3. data-date属性を確認
                  date_attr = element.get_attribute("data-date")
                  if date_attr:
                      try:
                          # 様々な形式を試す
                          for fmt in ["%Y-%m-%d", "%Y/%m/%d", "%Y%m%d"]:
                              try:
                                  date_obj = to_jst(datetime.strptime(date_attr, fmt))
                                  return date_obj, element.text.strip(), 8, "date_attribute"
                              except ValueError:
                                  continue
                      except:
                          pass
                  
                  # 4. その他のdata-*属性を確認
                  for attr_name in ["data-time", "data-datetime", "data-published"]:
                      attr_value = element.get_attribute(attr_name)
                      if attr_value:
                          # parse_date_stringを使用して解析を試みる
                          date_obj = parse_date_string(attr_value)
                          if date_obj:
                              return date_obj, element.text.strip(), 7, f"{attr_name}_attribute"
              except:
                  pass
              
              return None, None, 0, None
          
          def get_date_from_text(text):
              """
              テキストから日付情報を抽出する関数（相対表現の改善版）
              
              Args:
                  text: 日付を表す可能性のあるテキスト
                  
              Returns:
                  tuple: (datetime オブジェクト, 信頼性スコア, 抽出方法)
              """
              if not text:
                  return None, 0, None
              
              # 現在の日時を取得（相対日付計算用）
              now = datetime.now()
              
              try:
                  # 1. 分前の解析（例: 5分前）
                  minute_match = re.search(r'(\d+)\s*分\s*前', text)
                  if minute_match:
                      value = int(minute_match.group(1))
                      return now - timedelta(minutes=value), 8, "minutes_ago"
                  
                  # 2. 時間前の解析（例: 3時間前）
                  hour_match = re.search(r'(\d+)\s*時間\s*前', text)
                  if hour_match:
                      value = int(hour_match.group(1))
                      return now - timedelta(hours=value), 8, "hours_ago"
                  
                  # 3. 日前の解析（例: 3日前）
                  day_match = re.search(r'(\d+)\s*日\s*前', text)
                  if day_match:
                      value = int(day_match.group(1))
                      return now - timedelta(days=value), 8, "days_ago"
                  
                  # 4. 週間前の解析（例: 1週間前）
                  week_match = re.search(r'(\d+)\s*週間\s*前', text)
                  if week_match:
                      value = int(week_match.group(1))
                      return now - timedelta(weeks=value), 7, "weeks_ago"
                  
                  # 5. 月前の解析（例: 2ヶ月前）
                  month_match = re.search(r'(\d+)\s*(ヶ月|カ月|ヵ月|か月)\s*前', text)
                  if month_match:
                      value = int(month_match.group(1))
                      # 月は正確な日数がないので近似値を使用
                      return now - timedelta(days=value * 30), 6, "months_ago"
                  
                  # 6. 年前の解析（例: 1年前）
                  year_match = re.search(r'(\d+)\s*年\s*前', text)
                  if year_match:
                      value = int(year_match.group(1))
                      # 年も近似値を使用
                      return now - timedelta(days=value * 365), 5, "years_ago"
                  
                  # 7. 「今日」「昨日」「一昨日」などの特殊な相対日付
                  if '今日' in text:
                      return now, 8, "today"
                  elif '昨日' in text:
                      return now - timedelta(days=1), 8, "yesterday"
                  elif '一昨日' in text or '2日前' in text:
                      return now - timedelta(days=2), 8, "day_before_yesterday"
                  
                  # 8. 日付フォーマットのパターンを試行
                  date_formats = [
                      # 年月日 時分 形式
                      ("%Y年%m月%d日 %H時%M分", 9, "full_jp_datetime"),
                      ("%Y年%m月%d日 %H:%M", 9, "jp_date_colon_time"),
                      ("%Y/%m/%d %H:%M", 9, "slash_date_colon_time"),
                      ("%Y-%m-%d %H:%M", 9, "hyphen_date_colon_time"),
                      # 年月日のみ
                      ("%Y年%m月%d日", 8, "full_jp_date"),
                      ("%Y/%m/%d", 8, "slash_date"),
                      ("%Y-%m-%d", 8, "hyphen_date"),
                      # 月日 時分 形式
                      ("%m月%d日 %H時%M分", 7, "jp_month_day_time"),
                      ("%m月%d日 %H:%M", 7, "jp_month_day_colon_time"),
                      ("%m/%d %H:%M", 7, "slash_month_day_time"),
                      # 月日のみ
                      ("%m月%d日", 6, "jp_month_day"),
                      ("%m/%d", 6, "slash_month_day")
                  ]
                  
                  for date_format, score, method in date_formats:
                      try:
                          # 時間情報を含まないフォーマットで年が省略されている場合
                          if (len(date_format.split()) > 0 and "年" not in date_format.split()[0] and "/" not in date_format.split()[0] and "-" not in date_format.split()[0]) and \
                             (len(text.split()) > 0 and "年" not in text.split()[0] and "/" not in text.split()[0] and "-" not in text.split()[0]):
                              # 現在の年を使用
                              parsed_date = to_jst(datetime.strptime(text, date_format))
                              return parsed_date.replace(year=now.year), score, method
                          
                          # 完全な日付
                          return to_jst(datetime.strptime(text, date_format)), score, method
                      except (ValueError, IndexError):
                          continue
              except Exception as e:
                  print(f"日付テキスト '{text}' の解析中にエラーが発生しました: {e}")
              
              return None, 0, None
          
          def parse_date_from_element(parent):
              """
              親要素から日付情報を階層的に抽出する改良版関数
              
              Args:
                  parent: 親要素（Seleniumの要素オブジェクト）
                  
              Returns:
                  tuple: (datetime オブジェクト, 日付文字列)
              """
              # 結果を格納する変数
              best_date = None
              best_date_str = None
              best_score = 0
              best_method = None
              debug_info = {}
              
              # 1. 時間関連の要素を検索
              time_elements = find_time_elements(parent)
              
              # 2. 各要素から日付情報を抽出
              for element, search_method, base_priority in time_elements:
                  # 2.1 要素の属性から日付情報を抽出
                  date_obj, date_str, attr_score, attr_method = get_date_from_element_attributes(element)
                  if date_obj and attr_score > 0:
                      total_score = attr_score + base_priority
                      debug_info[f"{search_method}_{attr_method}"] = {
                          "date": date_obj.isoformat(),
                          "text": date_str,
                          "score": total_score
                      }
                      
                      if total_score > best_score:
                          best_date = date_obj
                          best_date_str = date_str
                          best_score = total_score
                          best_method = f"{search_method}_{attr_method}"
                  
                  # 2.2 要素のテキストから日付情報を抽出
                  try:
                      element_text = element.text.strip()
                      if element_text:
                          text_date, text_score, text_method = get_date_from_text(element_text)
                          if text_date and text_score > 0:
                              total_score = text_score + base_priority
                              debug_info[f"{search_method}_{text_method}"] = {
                                  "date": text_date.isoformat(),
                                  "text": element_text,
                                  "score": total_score
                              }
                              
                              if total_score > best_score:
                                  best_date = text_date
                                  best_date_str = element_text
                                  best_score = total_score
                                  best_method = f"{search_method}_{text_method}"
                  except:
                      pass
              
              # 3. 日付情報が見つからなかった場合、親要素のテキスト全体から抽出を試みる
              if not best_date:
                  try:
                      parent_text = parent.text.strip()
                      if parent_text:
                          # 行ごとに分割して各行で日付を探す
                          lines = parent_text.split('\n')
                          for line in lines:
                              line = line.strip()
                              if line:
                                  text_date, text_score, text_method = get_date_from_text(line)
                                  if text_date and text_score > 0:
                                      debug_info[f"parent_text_{text_method}"] = {
                                          "date": text_date.isoformat(),
                                          "text": line,
                                          "score": text_score
                                      }
                                      
                                      if text_score > best_score:
                                          best_date = text_date
                                          best_date_str = line
                                          best_score = text_score
                                          best_method = f"parent_text_{text_method}"
                  except:
                      pass
              
              # デバッグ情報を出力
              if debug_info:
                  print(f"日付抽出方法: {best_method}, スコア: {best_score}")
              
              return best_date, best_date_str

          def parse_date_string(date_str):
              """
              日付文字列を解析してdatetimeオブジェクトに変換する関数
              
              Args:
                  date_str: 日付を表す文字列
                  
              Returns:
                  datetime: 解析された日時オブジェクト、解析失敗時はNone
              """
              if not date_str:
                  return None
              
              # 現在の日時を取得（相対日付計算用）
              now = datetime.now(JST)
              
              try:
                  # 1. 分前の解析（例: 5分前）- 最優先
                  minute_match = re.search(r'(\d+)\s*分\s*前', date_str)
                  if minute_match:
                      value = int(minute_match.group(1))
                      return now - timedelta(minutes=value)
                  
                  # 2. 時間前の解析（例: 3時間前）- 次に優先
                  hour_match = re.search(r'(\d+)\s*時間\s*前', date_str)
                  if hour_match:
                      value = int(hour_match.group(1))
                      return now - timedelta(hours=value)
                  
                  # 3. その他の相対日付の解析（例: 3日前、1週間前）
                  relative_match = re.search(r'(\d+)\s*(日|週間|ヶ月|カ月|ヵ月|か月|年)\s*前', date_str)
                  if relative_match:
                      value = int(relative_match.group(1))
                      unit = relative_match.group(2)
                      
                      if unit == '日':
                          return now - timedelta(days=value)
                      elif unit == '週間':
                          return now - timedelta(weeks=value)
                      elif unit in ['ヶ月', 'カ月', 'ヵ月', 'か月']:
                          # 月は正確な日数がないので近似値を使用
                          return now - timedelta(days=value * 30)
                      elif unit == '年':
                          # 年も近似値を使用
                          return now - timedelta(days=value * 365)
                  
                  # 2. 「今日」「昨日」「一昨日」などの特殊な相対日付 - 高優先度
                  if '今日' in date_str:
                      return now
                  elif '昨日' in date_str:
                      return now - timedelta(days=1)
                  elif '一昨日' in date_str or '2日前' in date_str:
                      return now - timedelta(days=2)
                  
                  # 3. 日付フォーマットのパターンを試行
                  date_formats = [
                      # 年月日 時分 形式
                      "%Y年%m月%d日 %H時%M分",
                      "%Y年%m月%d日 %H:%M",
                      "%Y/%m/%d %H:%M",
                      "%Y-%m-%d %H:%M",
                      # 年月日のみ
                      "%Y年%m月%d日",
                      "%Y/%m/%d",
                      "%Y-%m-%d",
                      # 月日 時分 形式
                      "%m月%d日 %H時%M分",
                      "%m月%d日 %H:%M",
                      "%m/%d %H:%M",
                      # 月日のみ
                      "%m月%d日",
                      "%m/%d"
                  ]
                  
                  for date_format in date_formats:
                      try:
                          # 時間情報を含まないフォーマットで年が省略されている場合
                          if (len(date_format.split()) > 0 and "年" not in date_format.split()[0] and "/" not in date_format.split()[0] and "-" not in date_format.split()[0]) and \
                             (len(date_str.split()) > 0 and "年" not in date_str.split()[0] and "/" not in date_str.split()[0] and "-" not in date_str.split()[0]):
                              # 現在の年を使用
                              parsed_date = to_jst(datetime.strptime(date_str, date_format))
                              return parsed_date.replace(year=now.year)
                          
                          # 完全な日付
                          return to_jst(datetime.strptime(date_str, date_format))
                      except (ValueError, IndexError):
                          continue
              
              except Exception as e:
                  print(f"日付の解析中にエラーが発生しました: {e}")
              
              # 解析できなかった場合はNoneを返す
              return None

          def get_episodes_info_selenium():
              """
              Seleniumを使用してVoicyチャンネルのエピソード情報を取得する関数
              
              Returns:
                  list: エピソード情報のリスト
              """
              print(f"Voicyチャンネル {CHANNEL_URL} からエピソード情報を取得します...")
              
              # 既存のエピソード情報を読み込む
              existing_episodes, existing_episode_ids = load_existing_episodes()
              
              episodes = []
              episode_ids_seen = existing_episode_ids.copy()  # 既存のエピソードIDをコピー
              retry_count = 0
              
              print(f"重複チェック用に {len(episode_ids_seen)} 件の既存エピソードIDを読み込みました。")
              
              try:
                  # Chromeオプションの設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  chrome_options.add_argument("--disable-notifications")
                  chrome_options.add_argument("--disable-extensions")
                  chrome_options.add_argument("--disable-infobars")
                  
                  # WebDriverの初期化
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # タイムアウト設定
                  driver.set_page_load_timeout(60)
                  
                  # 最初のページを読み込み
                  driver.get(CHANNEL_URL)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 30).until(
                      EC.presence_of_element_located((By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']"))
                  )
                  
                  # デバッグ用にHTMLを保存
                  with open(os.path.join(DEBUG_DIR, "initial_page.html"), "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  
                  # プログレスバーの初期化（目標エピソード数: 2200）
                  progress = tqdm(total=TARGET_EPISODES, desc="エピソード取得")
                  
                  # オートページローディングのためのスクロール処理
                  scroll_count = 0
                  no_new_episodes_count = 0
                  max_no_new_episodes = 5  # 新しいエピソードが見つからない最大回数
                  
                  while scroll_count < MAX_SCROLL_ATTEMPTS and len(episodes) < TARGET_EPISODES:
                      # 現在のエピソード数を記録
                      current_episode_count = len(episodes)
                      
                      # ページの最下部までスクロール
                      driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                      random_sleep(SCROLL_PAUSE_TIME, SCROLL_PAUSE_TIME + 1)
                      
                      # 新しいコンテンツが読み込まれるのを待機
                      try:
                          WebDriverWait(driver, 5).until(
                              lambda d: d.execute_script("return document.body.scrollHeight") > driver.execute_script("return window.innerHeight + window.pageYOffset")
                          )
                      except:
                          pass
                      
                      # エピソードリンクを取得
                      episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']")
                      
                      # エピソード情報を抽出
                      for link in episode_links:
                          try:
                              href = link.get_attribute("href")
                              # エピソードURLのパターンをチェック
                              match = re.search(r'/channel/\d+/(\d+)$', href)
                              if match:
                                  episode_id = match.group(1)
                                  if episode_id not in episode_ids_seen:
                                      episode_ids_seen.add(episode_id)
                                      
                                      # 親要素を取得してタイトルと日付を探す
                                      parent = link
                                      title_element = None
                                      
                                      for _ in range(5):  # 最大5階層まで親を辿る
                                          try:
                                              parent = parent.find_element(By.XPATH, "..")
                                              try:
                                                  title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                                  if title_element:
                                                      break
                                              except:
                                                  pass
                                          except:
                                              break
                                      
                                      # タイトルを取得（見つからない場合はデフォルト値を使用）
                                      title = title_element.text if title_element else f"エピソード {episode_id}"
                                      
                                      # 日付要素を探す
                                      episode_date = None
                                      date_str = None

                                      # 改良された階層的日時抽出関数を使用
                                      episode_date, date_str = parse_date_from_element(parent)

                                      # 日付が解析できなかった場合は現在の日付を使用
                                      if episode_date is None:
                                          print(f"日付を解析できませんでした: {date_str}")
                                          episode_date = datetime.now(JST)

                                      # 日付の元の表現も保存
                                      original_date_text = ""
                                      for time_element, method, _ in time_elements:
                                          if time_element.text.strip():
                                              original_date_text = time_element.text.strip()
                                              break
                                      
                                      # 日付と時間を含むフォーマットで保存
                                      date_str = episode_date.strftime("%Y-%m-%d %H:%M:%S")
                                      # ISO形式の日付も追加（ソート用）
                                      date_iso = episode_date.isoformat()  # JSTタイムゾーン情報を含む
                                      # 日付の信頼性情報を追加
                                      date_source = "hierarchical_extraction"
                                      
                                      # 有料配信かどうかを判定
                                      is_premium = check_premium_content(parent)
                                      if is_premium:
                                          print(f"有料配信を検出しました: {title}")
                                      
                                      # エピソード情報を追加
                                      episodes.append({
                                          "id": episode_id,
                                          "title": title,
                                          "date": date_str,
                                          "date_iso": date_iso,  # ISO形式の日付を追加
                                          "date_source": date_source,  # 日付の取得方法を記録
                                          "original_date_text": original_date_text,  # 元の日時表現を保存
                                          "is_premium": is_premium,  # 有料配信ステータスを追加
                                          "url": href
                                      })
                                      
                                      # プログレスバーを更新
                                      progress.update(1)
                                      progress.set_description(f"エピソード取得中 ({len(episodes)}/{TARGET_EPISODES})")
                                      
                                      # 定期的に中間結果を保存（100件ごと）
                                      if len(episodes) % 100 == 0:
                                          save_episodes_to_json(existing_episodes + episodes, is_temp=True)
                                          print(f"現在 {len(episodes)} 件の新規エピソードを取得しました。")
                                  else:
                                      # 既に見たエピソードの場合はスキップ
                                      print(f"エピソードID {episode_id} は既に存在するためスキップします。")
                          except StaleElementReferenceException:
                              print("要素が古くなりました。スキップします。")
                              continue
                          except Exception as e:
                              print(f"エピソード情報の抽出中にエラーが発生しました: {e}")
                              continue
                      
                      # スクロールカウントを増やす
                      scroll_count += 1
                      
                      # 新しいエピソードが追加されたかチェック
                      if len(episodes) > current_episode_count:
                          no_new_episodes_count = 0  # リセット
                      else:
                          no_new_episodes_count += 1
                          print(f"新しいエピソードが見つかりませんでした。({no_new_episodes_count}/{max_no_new_episodes})")
                          
                          if no_new_episodes_count >= max_no_new_episodes:
                              print(f"連続 {max_no_new_episodes} 回新しいエピソードが見つかりませんでした。スクレイピングを終了します。")
                              break
                      
                      # 100スクロールごとにステータス表示
                      if scroll_count % 100 == 0:
                          print(f"スクロール回数: {scroll_count}, 取得エピソード数: {len(episodes)}")
                          
                          # ページの高さを取得して表示（デバッグ用）
                          page_height = driver.execute_script("return document.body.scrollHeight")
                          window_height = driver.execute_script("return window.innerHeight")
                          scroll_position = driver.execute_script("return window.pageYOffset")
                          print(f"ページ高さ: {page_height}, ウィンドウ高さ: {window_height}, スクロール位置: {scroll_position}")
                          
                          # 現在のHTMLを保存（デバッグ用）
                          with open(os.path.join(DEBUG_DIR, f"scroll_{scroll_count}.html"), "w", encoding="utf-8") as f:
                              f.write(driver.page_source)
                  
                  # プログレスバーを閉じる
                  progress.close()
                  
                  print(f"合計 {len(episodes)} 件の新規エピソードを取得しました。")
                  print(f"スクロール回数: {scroll_count}")
                  
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {e}")
                  traceback.print_exc()
              finally:
                  if 'driver' in locals() and driver:
                      driver.quit()
              
              # 既存のエピソードと新規エピソードを結合して返す
              return existing_episodes + episodes

          def save_episodes_to_json(episodes, is_temp=False):
              """
              エピソード情報をJSONファイルに保存する関数
              
              Args:
                  episodes: エピソード情報のリスト
                  is_temp: 一時ファイルとして保存するかどうか
              """
              try:
                  output_path = OUTPUT_JSON
                  if is_temp:
                      output_path = os.path.join(OUTPUT_DIR, f"voicy_episodes_temp_{len(episodes)}.json")
                  
                  # 日付でソートするための関数
                  def get_episode_date(episode):
                      """
                      エピソードの日時を取得する関数
                      
                      Args:
                          episode: エピソード情報の辞書
                          
                      Returns:
                          datetime: エピソードの日時（JSTタイムゾーン情報付き）
                      """
                      # まずoriginal_date_textを確認し、相対時間表現を優先的に処理
                      if "original_date_text" in episode and episode["original_date_text"]:
                          original_text = episode["original_date_text"]
                          
                          # 分前の解析（例: 5分前）- 最優先
                          minute_match = re.search(r'(\d+)\s*分\s*前', original_text)
                          if minute_match:
                              value = int(minute_match.group(1))
                              now = datetime.now(JST)
                              return now - timedelta(minutes=value)
                          
                          # 時間前の解析（例: 3時間前）- 次に優先
                          hour_match = re.search(r'(\d+)\s*時間\s*前', original_text)
                          if hour_match:
                              value = int(hour_match.group(1))
                              now = datetime.now(JST)
                              return now - timedelta(hours=value)
                          
                          # 昨日、一昨日の解析 - 高優先度
                          if '昨日' in original_text:
                              now = datetime.now(JST)
                              return now - timedelta(days=1)
                          elif '一昨日' in original_text or '2日前' in original_text:
                              now = datetime.now(JST)
                              return now - timedelta(days=2)
                      
                      # 次にdate_isoを探す（タイムゾーン情報付きのISO形式）
                      if "date_iso" in episode and episode["date_iso"]:
                          try:
                              return to_jst(datetime.fromisoformat(episode["date_iso"]))
                          except Exception as e:
                              print(f"date_iso解析エラー: {e} - {episode['date_iso']}")
                              pass
                      
                      # 次にdateフィールドを試す
                      if "date" in episode and episode["date"]:
                          try:
                              return to_jst(datetime.strptime(episode["date"], "%Y-%m-%d %H:%M:%S"))
                          except Exception as e:
                              print(f"date解析エラー: {e} - {episode['date']}")
                              pass
                      
                      # どちらも失敗した場合は最古の日付を返す
                      return datetime.min
                  
                  # エピソードを配信日時の新しい順に並び替え
                  sorted_episodes = sorted(episodes, key=get_episode_date, reverse=True)
                  
                  # デバッグ出力：ソート結果の上位エピソードとその日時情報を表示
                  print("\n=== ソート結果の上位エピソード ===")
                  for i, episode in enumerate(sorted_episodes[:5]):
                      episode_date = get_episode_date(episode)
                      print(f"{i+1}. {episode['title']} - {episode['original_date_text']} -> {episode_date.isoformat()}")
                  print("===============================\n")
                  with open(output_path, 'w', encoding='utf-8') as f:
                      json.dump(sorted_episodes, f, ensure_ascii=False, indent=2)
                  
                  if is_temp:
                      print(f"一時エピソード情報をJSONファイルに保存しました: {output_path}")
                  else:
                      print(f"エピソード情報をJSONファイルに保存しました: {output_path}")
              except Exception as e:
                  print(f"JSONファイルの保存中にエラーが発生しました: {e}")

          def save_urls_only_to_json(episodes):
              """
              URLのみのリストをJSONファイルに保存する関数
              
              Args:
                  episodes: エピソード情報のリスト
              """
              try:
                  urls_only = [episode["url"] for episode in episodes]
                  with open(OUTPUT_URLS_ONLY, 'w', encoding='utf-8') as f:
                      json.dump(urls_only, f, ensure_ascii=False, indent=2)
                  print(f"URLのみのリストをJSONファイルに保存しました: {OUTPUT_URLS_ONLY}")
              except Exception as e:
                  print(f"URLのみのリストの保存中にエラーが発生しました: {e}")

          def main():
              """メイン関数"""
              print("Voicy URL スクレイパーを開始します...")
              start_time = time.time()
              
              # ディレクトリ設定
              setup_directories()
              
              # エピソード情報を取得
              episodes = get_episodes_info_selenium()
              
              # エピソード情報をJSONファイルに保存
              save_episodes_to_json(episodes)
              
              # URLのみのリストも作成
              save_urls_only_to_json(episodes)
              
              end_time = time.time()
              elapsed_time = end_time - start_time
              hours, remainder = divmod(elapsed_time, 3600)
              minutes, seconds = divmod(remainder, 60)
              
              print(f"処理が完了しました。実行時間: {int(hours)}時間 {int(minutes)}分 {int(seconds)}秒")
              print(f"取得したエピソード数: {len(episodes)}")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: スクリプトを実行
        run: python voicy_url_scraper.py
      
      - name: 結果をアップロード
        uses: actions/upload-artifact@v4
        with:
          name: voicy-episodes-json
          path: |
            output/voicy_episodes.json
            output/voicy_urls_only.json
      
      - name: 結果をコミット
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add output/voicy_episodes.json output/voicy_urls_only.json
          git commit -m "Update Voicy episodes JSON" || echo "No changes to commit"
          git push
