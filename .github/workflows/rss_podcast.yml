name: Podcast RSS Generator

# 書き込み権限を明示的に要求
permissions:
  contents: write

on:
  schedule:
    # UTC基準で指定 (コメントでJST表記)
    - cron: '38 21 * * *'  # 毎日 06:38 JST
    - cron: '8 9 * * *'   # 毎日 18:08 JST
  workflow_dispatch:  # 手動実行用
  push:
    paths:
      - 'docs/podcast/**.mp3'  # podcast フォルダ内のMP3ファイル変更時
      - 'output/voicy_episodes.json' # JSONファイル更新時

jobs:
  generate-rss:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main repository
        uses: actions/checkout@v4
        with:
          # メインブランチのコードとJSONファイルを取得
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          # gh-pagesブランチのMP3ファイルと出力先を取得
          ref: gh-pages
          path: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # 標準ライブラリのみ使用するため依存関係は不要

      - name: Create scripts directory
        run: mkdir -p .github/scripts

      - name: Create Python script
        run: |
          cat > .github/scripts/generate_podcast_rss.py << 'EOF'
          #!/usr/bin/env python
          # -*- coding: utf-8 -*-

          import os
          import glob
          import datetime
          import time
          import re
          import xml.etree.ElementTree as ET
          import urllib.parse
          from xml.sax.saxutils import escape
          # --- datetimeからtimezone, timedeltaをインポート ---
          from datetime import timezone, timedelta
          import json
          import urllib.request

          # --- 定数 ---
          # JSTとUTCのタイムゾーンオブジェクト
          JST_TZ = timezone(timedelta(hours=9))
          UTC_TZ = timezone.utc

          # 基本設定
          # gh-pagesブランチ内のパス (チェックアウト先が 'gh-pages')
          PODCAST_DIR = 'gh-pages/docs/podcast'
          OUTPUT_DIR = 'gh-pages/docs'
          OUTPUT_FILE = os.path.join(OUTPUT_DIR, 'feed.rss')
          # メインブランチのJSONファイルパス (リポジトリルートから)
          JSON_FILE_PATH = 'output/voicy_episodes.json'
          # URL設定 (GitHub Pages)
          BASE_URL = 'https://paji.github.io/Spotify'
          MP3_BASE_URL = f'{BASE_URL}/docs/podcast' # GitHub PagesのURLを使用
          SELF_URL = f'{BASE_URL}/docs/feed.rss' # GitHub PagesのURLを使用

          # ポッドキャスト情報
          PODCAST_TITLE = '裏・パジちゃんねる'
          PODCAST_DESCRIPTION = 'ブロックチェーンやAIなど最新テクノロジーについての考察を毎日配信、濃密情報はプレミアムへ→ https://voicy.jp/channel/2834/all?premium=1  パジの日々の挑戦を記録していきます'
          PODCAST_AUTHOR = 'パジ'
          PODCAST_LINK = 'https://voicy.jp/channel/2834/all?premium=1'
          PODCAST_LANGUAGE = 'ja'
          PODCAST_COPYRIGHT = f'(C) {datetime.datetime.now().year} パジ' # 年を動的に
          PODCAST_WEBMASTER = 'パジ <hajimeataka@gmail.com>'
          PODCAST_TTL = '60'
          PODCAST_EXPLICIT = 'false'
          PODCAST_OWNER_NAME = 'パジ'
          PODCAST_OWNER_EMAIL = 'hajimeataka@gmail.com'
          PODCAST_CATEGORY = 'Technology'
          # GitHub Pages上の画像URL
          PODCAST_IMAGE_URL = f'{BASE_URL}/profile1600.jpeg'

          def get_mp3_metadata(filepath):
              """
              ファイル名からメタデータを抽出し、日付にタイムゾーンを設定する
              """
              filename = os.path.basename(filepath)
              # ファイル名から日付とタイトルを抽出 (例: 2024-03-19_タイトル_6449675.mp3)
              match = re.match(r'(_)?(\d{4}-\d{2}-\d{2})_(.+)\.mp3', filename)

              pub_date_dt = None # タイムゾーン付きdatetimeオブジェクト
              title = os.path.splitext(filename)[0] # デフォルトタイトル
              is_premium = filename.startswith('_')

              if match:
                  is_premium = bool(match.group(1))
                  date_str = match.group(2)
                  title_raw = match.group(3)

                  # タイトルから末尾のIDを除去 (5桁以上の数字)
                  title_parts = title_raw.rsplit('_', 1)
                  if len(title_parts) > 1 and title_parts[1].isdigit() and len(title_parts[1]) >= 5:
                      title = title_parts[0].replace('_', ' ')
                  else:
                      title = title_raw.replace('_', ' ')

                  if is_premium:
                      title = "[Premium] " + title

                  try:
                      # ファイル名の日付文字列をパースし、UTCの正午とする
                      naive_dt = datetime.datetime.strptime(date_str, '%Y-%m-%d')
                      pub_date_dt = naive_dt.replace(hour=12, minute=0, second=0, tzinfo=UTC_TZ)
                  except ValueError:
                      print(f"警告: ファイル名から日付を解析できませんでした: {filename}")
                      pass # pub_date_dt は None のまま

              # ファイル名から日付が取れなかった場合、ファイルの最終更新日時(UTC)を使用
              if pub_date_dt is None:
                  try:
                      file_mtime = os.path.getmtime(filepath)
                      pub_date_dt = datetime.datetime.fromtimestamp(file_mtime, tz=UTC_TZ)
                      print(f"情報: ファイル更新日時を使用: {filename}")
                  except OSError as e:
                      print(f"エラー: ファイル更新日時を取得できませんでした: {filename} - {e}")
                      # どうしても日付が取得できない場合は現在時刻(UTC)を仮に設定
                      pub_date_dt = datetime.datetime.now(UTC_TZ)

              # タイトル整形 (ファイル名マッチしなかった場合用)
              if not match:
                  title_parts = title.rsplit('_', 1)
                  if len(title_parts) > 1 and title_parts[1].isdigit() and len(title_parts[1]) >= 5:
                      title = title_parts[0]
                  if is_premium:
                      title = "[Premium] " + title.replace('_', ' ')
                  else:
                      title = title.replace('_', ' ')

              return {
                  'title': title,
                  'date_dt': pub_date_dt, # タイムゾーン付きdatetimeオブジェクト
                  'filename': filename,
                  'is_premium': is_premium,
                  'filepath': filepath # ファイルパスも保持
              }

          def file_size(filepath):
              """ファイルサイズをバイト単位で返す"""
              try:
                  return os.path.getsize(filepath)
              except OSError as e:
                  print(f"エラー: ファイルサイズを取得できませんでした: {filepath} - {e}")
                  return 0

          def format_rfc822_date(dt):
              """
              タイムゾーン付きdatetimeオブジェクトをRFC 822形式(JST)にフォーマットする
              """
              if not isinstance(dt, datetime.datetime):
                  print(f"エラー: 無効な日付オブジェクトです: {dt}")
                  # フォールバックとして現在時刻を使用
                  dt = datetime.datetime.now(JST_TZ)
              elif dt.tzinfo is None:
                  print(f"警告: タイムゾーン情報がない日付オブジェクトです: {dt}。UTCと仮定します。")
                  dt = dt.replace(tzinfo=UTC_TZ)

              # JSTに変換
              jst_dt = dt.astimezone(JST_TZ)

              # 手動でRFC 822形式（JST +0900）にフォーマット
              weekday = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"][jst_dt.weekday()]
              month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][jst_dt.month - 1]
              return f"{weekday}, {jst_dt.day:02d} {month} {jst_dt.year} {jst_dt.hour:02d}:{jst_dt.minute:02d}:{jst_dt.second:02d} +0900"

          def extract_id_from_filename(filename):
              """ファイル名から末尾の数字ID(5桁以上)を抽出"""
              parts = filename.split('_')
              # 末尾から数字のみの部分を探す
              for part in reversed(parts):
                  part_cleaned = os.path.splitext(part)[0] # 拡張子除去
                  if part_cleaned.isdigit() and len(part_cleaned) >= 5: # 5桁以上の数字
                      return part_cleaned
              return None

          def generate_rss():
              """RSSフィードを生成するメイン関数"""
              rss = ET.Element("rss", {
                  "xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd",
                  "xmlns:atom": "http://www.w3.org/2005/Atom",
                  "version": "2.0"
              })
              channel = ET.SubElement(rss, "channel")

              # --- チャンネル情報設定 ---
              ET.SubElement(channel, "atom:link", {"href": SELF_URL, "rel": "self", "type": "application/rss+xml"})
              ET.SubElement(channel, "title").text = PODCAST_TITLE
              # description内の改行は削除またはスペースに置換
              ET.SubElement(channel, "description").text = PODCAST_DESCRIPTION.replace('\n', ' ')
              ET.SubElement(channel, "link").text = PODCAST_LINK
              ET.SubElement(channel, "language").text = PODCAST_LANGUAGE
              ET.SubElement(channel, "copyright").text = PODCAST_COPYRIGHT
              ET.SubElement(channel, "lastBuildDate").text = format_rfc822_date(datetime.datetime.now(UTC_TZ)) # 最終ビルド日時(JST)
              ET.SubElement(channel, "webMaster").text = PODCAST_WEBMASTER
              ET.SubElement(channel, "ttl").text = PODCAST_TTL
              ET.SubElement(channel, "itunes:explicit").text = PODCAST_EXPLICIT
              ET.SubElement(channel, "itunes:author").text = PODCAST_AUTHOR
              owner = ET.SubElement(channel, "itunes:owner")
              ET.SubElement(owner, "itunes:name").text = PODCAST_OWNER_NAME
              ET.SubElement(owner, "itunes:email").text = PODCAST_OWNER_EMAIL
              ET.SubElement(channel, "itunes:category", {"text": PODCAST_CATEGORY})
              image = ET.SubElement(channel, "image")
              ET.SubElement(image, "url").text = PODCAST_IMAGE_URL
              ET.SubElement(image, "title").text = PODCAST_TITLE
              ET.SubElement(image, "link").text = PODCAST_LINK
              ET.SubElement(channel, "itunes:image", {"href": PODCAST_IMAGE_URL})
              # --- チャンネル情報設定ここまで ---

              # --- MP3ファイルとJSON情報の処理 ---
              mp3_files = glob.glob(os.path.join(PODCAST_DIR, '*.mp3'))
              # 有料配信（ファイル名の先頭が '_'）を除外
              free_mp3_files = [f for f in mp3_files if not os.path.basename(f).startswith('_')]
              print(f"全ファイル数: {len(mp3_files)}")
              print(f"無料配信ファイル数: {len(free_mp3_files)}")

              # MP3ファイルから基本メタデータを取得
              mp3_metadata = [get_mp3_metadata(f) for f in free_mp3_files]

              # voicy_episodes.json からエピソード情報を読み込む
              episode_dates = {}
              try:
                  # GitHub Actionsのワークスペース内のパスから読み込む
                  with open(JSON_FILE_PATH, 'r', encoding='utf-8') as f:
                      voicy_episodes = json.load(f)
                  # IDをキー、日付文字列を値とする辞書を作成
                  episode_dates = {str(episode["id"]): episode["date"] for episode in voicy_episodes if "id" in episode and "date" in episode}
                  print(f"JSONファイル({JSON_FILE_PATH})から{len(episode_dates)}件のエピソード情報を取得しました")
              except FileNotFoundError:
                  print(f"警告: JSONファイルが見つかりません: {JSON_FILE_PATH}")
              except json.JSONDecodeError as e:
                  print(f"エラー: JSONファイルの解析に失敗しました: {JSON_FILE_PATH} - {e}")
              except Exception as e:
                  print(f"エラー: JSONファイルの処理中に予期せぬエラーが発生しました: {e}")

              # メタデータにJSONの日付情報をマージし、ソート用の最終日付を設定
              valid_metadata = []
              for meta in mp3_metadata:
                  if meta['date_dt'] is None: # 日付が取得できなかったものはスキップ
                      print(f"警告: 日付が無効なためスキップします: {meta['filename']}")
                      continue

                  episode_id = extract_id_from_filename(meta['filename'])
                  meta['final_date_dt'] = meta['date_dt'] # デフォルトはファイル由来の日付(UTC)

                  if episode_id and episode_id in episode_dates:
                      try:
                          json_date_str = episode_dates[episode_id]
                          # JSONの日付文字列 (JST) をタイムゾーン付きdatetimeオブジェクトに変換
                          naive_dt = datetime.datetime.strptime(json_date_str, '%Y-%m-%d %H:%M:%S')
                          jst_dt = naive_dt.replace(tzinfo=JST_TZ) # JSTタイムゾーンを付与
                          meta['final_date_dt'] = jst_dt # JSONの日付(JST)を最終日付として採用
                          print(f"ID {episode_id}: JSONの日付 {json_date_str} (JST) を使用")
                      except (ValueError, TypeError) as e:
                          print(f"警告: 日付変換エラー ({episode_id}: {json_date_str}): {e}. ファイル由来の日付を使用します。")
                          # エラー時はファイル由来の日付(UTC)を使用 (final_date_dtは変更しない)
                  else:
                      if episode_id:
                          print(f"情報: ID {episode_id} はJSONに存在しません。ファイル由来の日付を使用します。")
                      else:
                          print(f"情報: ID抽出不可 ({meta['filename']})。ファイル由来の日付を使用します。")
                      # IDがない場合もファイル由来の日付(UTC)を使用 (final_date_dtは変更しない)

                  valid_metadata.append(meta) # 有効なメタデータのみ追加

              # final_date_dt でソート (新しい順)
              valid_metadata.sort(key=lambda x: x['final_date_dt'], reverse=True)

              if valid_metadata:
                  # ソート後の最新の日付をチャンネルのpubDateにも設定
                  latest_pubdate = format_rfc822_date(valid_metadata[0]['final_date_dt'])
                  ET.SubElement(channel, "pubDate").text = latest_pubdate
                  print(f"チャンネルpubDateを設定: {latest_pubdate}")
                  print(f"ソート後の先頭エピソードの日付: {valid_metadata[0]['final_date_dt']} (タイトル: {valid_metadata[0]['title']})")
              else:
                  print("警告: 有効なエピソードが見つかりませんでした。")
                  # エピソードがない場合もpubDateを設定
                  ET.SubElement(channel, "pubDate").text = format_rfc822_date(datetime.datetime.now(UTC_TZ))
              # --- MP3ファイルとJSON情報の処理ここまで ---


              # --- 各エピソードの情報を <item> として追加 ---
              for meta in valid_metadata:
                  filepath = meta['filepath']
                  # URLエンコーディングをファイル名部分にのみ適用
                  encoded_filename = urllib.parse.quote(meta['filename'])
                  file_url = f"{MP3_BASE_URL}/{encoded_filename}"
                  file_size_bytes = str(file_size(filepath))
                  # タイトルと説明文をXMLエスケープ
                  title_text = escape(meta['title'])
                  # description も念のためエスケープ (現状はtitleと同じだが将来的に変更される可能性)
                  description_text = escape(f"Episode: {meta['title']}")

                  item = ET.SubElement(channel, "item")

                  ET.SubElement(item, "title").text = title_text
                  ET.SubElement(item, "description").text = description_text
                  # final_date_dt を RFC 822 (JST) 形式でpubDateに設定
                  ET.SubElement(item, "pubDate").text = format_rfc822_date(meta['final_date_dt'])

                  ET.SubElement(item, "enclosure", {
                      "url": file_url,
                      "length": file_size_bytes,
                      "type": "audio/mpeg"
                  })

                  # itunes specific tags
                  # duration は実際の音声ファイルから取得するのが理想だが、ここでは固定値または取得処理を追加
                  # 例: duration = get_duration(filepath) # get_duration関数を別途実装する必要あり
                  ET.SubElement(item, "itunes:duration").text = "00:30:00" # 仮の長さ（可能であれば取得する）
                  ET.SubElement(item, "itunes:author").text = PODCAST_AUTHOR
                  ET.SubElement(item, "itunes:summary").text = description_text # descriptionと同じで良いか確認
                  ET.SubElement(item, "itunes:explicit").text = PODCAST_EXPLICIT

                  # GUID (Globally Unique Identifier) - ファイルURLを使用 (変更されない限り安定)
                  ET.SubElement(item, "guid", {"isPermaLink": "false"}).text = file_url
              # --- 各エピソードの追加ここまで ---

              # --- XMLファイルの生成と保存 ---
              # XMLツリーをインデント付きで整形 (デバッグ用に可読性を上げる場合)
              # ET.indent(rss, space="  ", level=0) # Python 3.9+

              tree = ET.ElementTree(rss)
              # XML宣言を含めてUTF-8でファイルに書き込み
              try:
                  # 出力ディレクトリが存在しない場合は作成
                  os.makedirs(OUTPUT_DIR, exist_ok=True)
                  with open(OUTPUT_FILE, 'wb') as f:
                      # tree.write(f, encoding='utf-8', xml_declaration=True, method='xml') # method='xml' をつけるとより厳密
                      tree.write(f, encoding='utf-8', xml_declaration=True)
                  print(f"Podcast RSS feed generated successfully: {OUTPUT_FILE}")
              except IOError as e:
                  print(f"エラー: RSSファイルの書き込みに失敗しました: {OUTPUT_FILE} - {e}")
              # --- XMLファイルの生成と保存ここまで ---

              # --- 後処理: .nojekyll とリダイレクトファイルの作成 ---
              try:
                  # .nojekyllファイルを作成 (GitHub PagesでJekyll処理を無効化)
                  nojekyll_path = os.path.join(OUTPUT_DIR, '.nojekyll')
                  if not os.path.exists(nojekyll_path):
                      with open(nojekyll_path, 'w') as f:
                          f.write('# This file disables Jekyll processing')
                      print(f".nojekyllファイルを作成しました: {nojekyll_path}")

                  # rss.xml から feed.rss へのリダイレクト用HTMLファイルを作成
                  # (互換性のため、古いURLにアクセスされた場合用)
                  redirect_path = os.path.join(OUTPUT_DIR, 'rss.xml')
                  # サーバーサイドリダイレクトが望ましいが、静的HTMLで簡易的に実装
                  redirect_html = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="refresh" content="0; url=feed.rss">
  <title>Redirecting to feed.rss</title>
  <link rel="canonical" href="feed.rss"/>
</head>
<body>
  <p>This page has moved. You will be redirected to <a href="feed.rss">the new location (feed.rss)</a> automatically.</p>
</body>
</html>"""
                  with open(redirect_path, 'w', encoding='utf-8') as f:
                      f.write(redirect_html)
                  print(f"リダイレクトファイルを作成しました: {redirect_path}")

              except IOError as e:
                  print(f"エラー: 後処理ファイルの作成中にエラーが発生しました: {e}")
              # --- 後処理ここまで ---

          if __name__ == "__main__":
              print(f"実行開始: {datetime.datetime.now(JST_TZ)}")
              generate_rss()
              print(f"実行完了: {datetime.datetime.now(JST_TZ)}")
          EOF

      - name: Generate RSS feed
        run: |
          chmod +x .github/scripts/generate_podcast_rss.py
          python .github/scripts/generate_podcast_rss.py

      - name: Commit and push changes to gh-pages branch
        run: |
          cd gh-pages
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions-bot@github.com" # より一般的なボット用メールアドレス

          # 生成されたファイルと後処理ファイルをステージング
          git add docs/feed.rss docs/rss.xml docs/.nojekyll

          # 変更があった場合のみコミット＆プッシュ
          if ! git diff --staged --quiet; then
            echo "変更を検出しました。コミットとプッシュを実行します。"
            # コミットメッセージを改善
            commit_message="自動更新: Podcast RSS feed ($(date -u +'%Y-%m-%d %H:%M:%SZ
