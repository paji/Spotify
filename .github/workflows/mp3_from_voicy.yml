name: Voicy MP3 Downloader

on:
  schedule:
    - cron: '0 * * * *'  # 毎時実行
  workflow_dispatch:  # 手動実行用

# 明示的に権限を設定
permissions:
  contents: write
  actions: write

jobs:
  voicy-mp3-download:
    runs-on: ubuntu-latest
    
    steps:
      - name: チェックアウト
        uses: actions/checkout@v3
      
      - name: Python 3.10 セットアップ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Chrome ブラウザのセットアップ
        uses: browser-actions/setup-chrome@v1
      
      - name: FFmpegのインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
      
      - name: 依存関係のインストール
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 selenium webdriver-manager
      
      - name: Voicy MP3ダウンロードスクリプト作成
        run: |
          cat > voicy_mp3_downloader_v3.py << 'EOF'
          import os
          import re
          import json
          import requests
          import subprocess
          from datetime import datetime
          from bs4 import BeautifulSoup
          import traceback
          import time
          import shutil
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.chrome.service import Service
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from webdriver_manager.chrome import ChromeDriverManager

          # Voicyチャンネル情報
          CHANNEL_ID = "2834"  # パジ郎チャンネル
          CHANNEL_URL = f"https://voicy.jp/channel/{CHANNEL_ID}"  # チャンネルトップページ

          # ダウンロードする最新エピソード数
          MAX_EPISODES = 3

          # ディレクトリ設定
          MP3_DIR = "mp3_downloads"
          TEMP_DIR = "temp_segments"
          DEBUG_DIR = "debug_files"

          def setup_directories():
              """必要なディレクトリを作成"""
              for directory in [MP3_DIR, TEMP_DIR, DEBUG_DIR]:
                  os.makedirs(directory, exist_ok=True)
                  print(f"ディレクトリを確認/作成しました: {directory}")

          # MP3ファイルを結合する修正版関数
          def concat_mp3_files(mp3_segments, output_mp3_path, temp_dir=TEMP_DIR):
              """
              MP3ファイルを結合する関数
              
              Args:
                  mp3_segments: MP3セグメントファイルのリスト
                  output_mp3_path: 出力先のMP3ファイルパス
                  temp_dir: 一時ファイル用ディレクトリ
              
              Returns:
                  bool: 成功した場合はTrue、失敗した場合はFalse
              """
              if not mp3_segments:
                  print("結合するMP3セグメントがありません")
                  return False
              
              # 絶対パスに変換
              mp3_segments = [os.path.abspath(segment) for segment in mp3_segments if os.path.exists(segment)]
              output_mp3_path = os.path.abspath(output_mp3_path)
              
              if not mp3_segments:
                  print("有効なMP3セグメントが見つかりません")
                  return False
              
              # MP3セグメントリストファイルを作成
              mp3_segments_list = os.path.join(os.path.abspath(temp_dir), "mp3_segments.txt")
              
              try:
                  # 方法1: ffmpegのconcatフィルターを使用
                  with open(mp3_segments_list, 'w') as f:
                      for segment in mp3_segments:
                          # 絶対パスを使用し、エスケープ処理を追加
                          # バックスラッシュのエスケープを修正
                          segment_escaped = segment.replace('\\', '\\\\')
                          segment_escaped = segment_escaped.replace("'", "\\'")
                          segment_escaped = segment_escaped.replace(" ", "\\ ")
                          f.write(f"file '{segment_escaped}'\n")
                  
                  print(f"MP3セグメントリストファイルを作成しました: {mp3_segments_list}")
                  print(f"リストファイルの内容:")
                  with open(mp3_segments_list, 'r') as f:
                      print(f.read())
                  
                  # ffmpegコマンドを実行
                  cmd = [
                      'ffmpeg',
                      '-f', 'concat',
                      '-safe', '0',
                      '-i', mp3_segments_list,
                      '-c', 'copy',
                      '-y',
                      output_mp3_path
                  ]
                  
                  print(f"FFmpegコマンドを実行: {' '.join(cmd)}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"MP3ファイルの結合に成功しました: {output_mp3_path}")
                      if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                          file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                          print(f"結合されたMP3ファイル: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                          return True
                      else:
                          print(f"MP3ファイルが正常に作成されませんでした")
                          return False
                  else:
                      print(f"FFmpegエラー: {result.stderr}")
                      
                      # 方法2: 代替方法としてcatコマンドを使用
                      print("代替方法を試行: catコマンドを使用してMP3ファイルを結合")
                      try:
                          with open(output_mp3_path, 'wb') as outfile:
                              for segment in mp3_segments:
                                  if os.path.exists(segment):
                                      with open(segment, 'rb') as infile:
                                          shutil.copyfileobj(infile, outfile)
                          
                          if os.path.exists(output_mp3_path) and os.path.getsize(output_mp3_path) > 0:
                              file_size_mb = os.path.getsize(output_mp3_path) / (1024 * 1024)
                              print(f"catコマンドによるMP3ファイルの結合に成功しました: {output_mp3_path} (サイズ: {file_size_mb:.2f}MB)")
                              return True
                          else:
                              print(f"catコマンドによるMP3ファイルの結合に失敗しました")
                              return False
                      except Exception as e:
                          print(f"catコマンドによるMP3ファイル結合中にエラーが発生しました: {str(e)}")
                          return False
              
              except Exception as e:
                  print(f"MP3ファイル結合中にエラーが発生しました: {str(e)}")
                  return False
              finally:
                  # 一時ファイルの削除
                  if os.path.exists(mp3_segments_list):
                      os.remove(mp3_segments_list)
              
              return False

          def get_episodes_info_selenium():
              """Seleniumを使用してVoicyから最新のエピソード情報を取得"""
              print(f"::group::Voicyエピソード情報取得（Selenium）")
              print(f"Seleniumを使用してVoicyチャンネルから最新{MAX_EPISODES}件のエピソード情報を取得中...")
              print(f"URL: {CHANNEL_URL}")
              
              try:
                  # Chromeのオプション設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")  # ヘッドレスモード
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                  
                  # WebDriverの初期化 (webdriver_managerを使用)
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  driver.get(CHANNEL_URL)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # ページをスクロールして全てのコンテンツを読み込む
                  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                  time.sleep(3)
                  
                  # ページのHTMLをデバッグ用に保存
                  debug_html_path = f"{DEBUG_DIR}/channel_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"チャンネルページのHTMLを保存しました: {debug_html_path}")
                  
                  # エピソードリンクを取得
                  episode_links = driver.find_elements(By.CSS_SELECTOR, "a[href*='/channel/'][href*='/']")
                  
                  episodes = []
                  episode_ids_seen = set()
                  
                  for link in episode_links:
                      href = link.get_attribute("href")
                      if href and "/channel/" in href and href != CHANNEL_URL:
                          # エピソードIDを抽出
                          match = re.search(r'/channel/\d+/(\d+)', href)
                          if match:
                              episode_id = match.group(1)
                              if episode_id not in episode_ids_seen:
                                  episode_ids_seen.add(episode_id)
                                  
                                  # エピソードのタイトルを取得
                                  title_element = None
                                  try:
                                      # 親要素を辿ってタイトル要素を探す
                                      parent = link.find_element(By.XPATH, "./..")
                                      title_element = parent.find_element(By.CSS_SELECTOR, "h2, h3, .title, .episode-title")
                                  except:
                                      try:
                                          # リンク自体にタイトルが含まれている場合
                                          title_element = link
                                      except:
                                          pass
                                  
                                  title = title_element.text if title_element else f"エピソード {episode_id}"
                                  
                                  # 日付情報を取得
                                  date_str = None
                                  try:
                                      # 日付要素を探す
                                      date_element = parent.find_element(By.CSS_SELECTOR, "time, .date, .episode-date")
                                      date_str = date_element.text
                                  except:
                                      # 日付が見つからない場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  # 日付文字列から日付オブジェクトを作成
                                  try:
                                      # 様々な日付形式に対応
                                      date_formats = [
                                          "%Y-%m-%d",
                                          "%Y年%m月%d日",
                                          "%Y/%m/%d",
                                          "%m月%d日",  # 年がない場合は現在の年を使用
                                          "%m/%d",     # 年がない場合は現在の年を使用
                                      ]
                                      
                                      episode_date = None
                                      for date_format in date_formats:
                                          try:
                                              if "年" in date_str and date_format == "%m月%d日":
                                                  # 「2023年3月1日」のような形式
                                                  continue
                                              
                                              if "月" in date_str and "年" not in date_str and date_format == "%m月%d日":
                                                  # 「3月1日」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              elif "/" in date_str and len(date_str.split("/")) == 2 and date_format == "%m/%d":
                                                  # 「3/1」のような形式（年がない）
                                                  parsed_date = datetime.strptime(date_str, date_format)
                                                  current_year = datetime.now().year
                                                  episode_date = parsed_date.replace(year=current_year)
                                                  break
                                              else:
                                                  episode_date = datetime.strptime(date_str, date_format)
                                                  break
                                          except ValueError:
                                              continue
                                      
                                      if episode_date is None:
                                          # どの形式にも合致しない場合は現在の日付を使用
                                          episode_date = datetime.now()
                                      
                                      date_str = episode_date.strftime("%Y-%m-%d")
                                  except Exception as e:
                                      # 日付の解析に失敗した場合は現在の日付を使用
                                      date_str = datetime.now().strftime("%Y-%m-%d")
                                  
                                  episodes.append({
                                      "id": episode_id,
                                      "title": title,
                                      "url": href,
                                      "date": date_str,
                                      "isPremium": False  # 初期値はFalse、後で判定
                                  })
                                  
                                  if len(episodes) >= MAX_EPISODES:
                                      break
                  
                  driver.quit()
                  
                  if episodes:
                      print(f"{len(episodes)}件のエピソードを取得しました:")
                      for i, episode in enumerate(episodes, 1):
                          print(f"{i}. ID: {episode['id']}, タイトル: {episode['title']}, 日付: {episode['date']}, URL: {episode['url']}")
                      
                      print(f"::endgroup::")
                      return episodes
                  else:
                      print(f"エピソードが見つかりませんでした")
                      print(f"::endgroup::")
                      return []
                  
              except Exception as e:
                  print(f"エピソード情報の取得中にエラーが発生しました: {str(e)}")
                  traceback.print_exc()
                  print(f"::endgroup::")
                  return []

          def check_if_premium(episode_url, driver=None):
              """エピソードが有料（プレミアムリスナー限定）かどうかを確認する"""
              print(f"エピソードが有料放送かどうかを確認中: {episode_url}")
              
              should_close_driver = False
              try:
                  if driver is None:
                      # Chromeのオプション設定
                      chrome_options = Options()
                      chrome_options.add_argument("--headless")  # ヘッドレスモード
                      chrome_options.add_argument("--no-sandbox")
                      chrome_options.add_argument("--disable-dev-shm-usage")
                      chrome_options.add_argument("--disable-gpu")
                      chrome_options.add_argument("--window-size=1920,1080")
                      chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                      
                      # WebDriverの初期化
                      service = Service(ChromeDriverManager().install())
                      driver = webdriver.Chrome(service=service, options=chrome_options)
                      should_close_driver = True
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  
                  # ページが読み込まれるまで待機
                  WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # 少し待機してJavaScriptが実行されるのを待つ
                  time.sleep(2)
                  
                  # プレミアムリスナー限定のコンテンツであるかを確認するキーワード
                  premium_keywords = [
                      "プレミアムリスナー限定",
                      "プレミアム限定",
                      "有料放送",
                      "premium-only",
                      "premium only",
                      "限定コンテンツ"
                  ]
                  
                  # ページソースを取得
                  page_source = driver.page_source
                  
                  # キーワードを検索
                  is_premium = any(keyword in page_source for keyword in premium_keywords)
                  
                  # プレミアムバッジや特定のクラス名を持つ要素を探す
                  try:
                      premium_elements = driver.find_elements(By.CSS_SELECTOR, 
                                                     ".premium, .premium-badge, .premium-content, [class*='premium']")
                      if premium_elements:
                          is_premium = True
                  except:
                      pass
                  
                  # ロックアイコンやプレミアムアイコンを探す
                  try:
                      lock_icons = driver.find_elements(By.CSS_SELECTOR, 
                                                "[class*='lock'], [class*='paid'], svg[class*='lock']")
                      if lock_icons:
                          is_premium = True
                  except:
                      pass
                  
                  if is_premium:
                      print(f"エピソードは有料放送（プレミアムリスナー限定）です")
                  else:
                      print(f"エピソードは無料放送です")
                  
                  return is_premium
                  
              except Exception as e:
                  print(f"有料放送の確認中にエラーが発生しました: {str(e)}")
                  # エラーが発生した場合は無料放送と判定
                  return False
              finally:
                  # 新しく作成したドライバーのみ閉じる
                  if should_close_driver and driver:
                      driver.quit()

          def get_audio_url_selenium(episode_url, check_premium=True):
              """Seleniumを使用してエピソードページから音声URLを取得"""
              print(f"::group::音声URL取得（Selenium）")
              print(f"エピソードページから音声URLを取得中: {episode_url}")
              
              try:
                  # Chromeのオプション設定
                  chrome_options = Options()
                  chrome_options.add_argument("--headless")  # ヘッドレスモード
                  chrome_options.add_argument("--no-sandbox")
                  chrome_options.add_argument("--disable-dev-shm-usage")
                  chrome_options.add_argument("--disable-gpu")
                  chrome_options.add_argument("--window-size=1920,1080")
                  chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                  
                  # ネットワークリクエストを監視するためのCDPセッションを設定
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=chrome_options)
                  
                  # ネットワークリクエストを監視するためのJavaScriptを実行
                  driver.execute_cdp_cmd("Network.enable", {})
                  
                  # エピソードページにアクセス
                  driver.get(episode_url)
                  
                  # ページが完全に読み込まれるまで待機
                  WebDriverWait(driver, 20).until(
                      EC.presence_of_element_located((By.TAG_NAME, "body"))
                  )
                  
                  # JavaScriptが実行されるまで少し待機
                  time.sleep(5)
                  
                  # プレミアムコンテンツかどうかをチェック
                  is_premium = False
                  if check_premium:
                      is_premium = check_if_premium(episode_url, driver)
                  
                  # ページのHTMLをデバッグ用に保存
                  episode_id = episode_url.split('/')[-1]
                  debug_html_path = f"{DEBUG_DIR}/episode_{episode_id}_page.html"
                  with open(debug_html_path, "w", encoding="utf-8") as f:
                      f.write(driver.page_source)
                  print(f"エピソードページのHTMLを保存しました: {debug_html_path}")
                  
                  # 再生ボタンを探して押す
                  try:
                      play_button = WebDriverWait(driver, 10).until(
                          EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='再生'], .play-button, .playButton"))
                      )
                      play_button.click()
                      print("再生ボタンをクリックしました")
                      time.sleep(3)  # 再生開始を待つ
                  except Exception as e:
                      print(f"再生ボタンのクリックに失敗しました: {str(e)}")
                      print("再生ボタンが見つからない場合は、既に再生中かもしれません")
                  
                  # 音声URLを探す方法を強化（JSファイルの実装を参考に）
                  audio_urls = []
                  m3u8_urls = []
                  
                  # 方法1: ネットワークリクエストを詳細に分析するためのコードを実行
                  print("ネットワークリクエストを分析中...")
                  audio_detection_script = """
                  // 既存のネットワークリクエストを確認
                  const resources = performance.getEntriesByType('resource');
                  const audioUrls = [];
                  const m3u8Urls = [];
                  
                  resources.forEach(resource => {
                      if (resource.name.includes('.mp3') || 
                          resource.name.includes('.m4a') || 
                          resource.name.includes('.aac') || 
                          resource.name.includes('.wav') || 
                          resource.name.includes('.m3u8') ||
                          resource.name.includes('audio') || 
                          resource.name.includes('media')) {
                          console.log('メディアリソース検出:', resource.name);
                          if (resource.name.includes('.m3u8')) {
                              m3u8Urls.push(resource.name);
                          } else if (resource.name.includes('.mp3') || 
                                     resource.name.includes('.m4a') || 
                                     resource.name.includes('.aac') || 
                                     resource.name.includes('.wav')) {
                              audioUrls.push(resource.name);
                          }
                      }
                  });
                  
                  // オーディオ要素を確認
                  const audioElements = document.querySelectorAll('audio');
                  audioElements.forEach((audio, index) => {
                      console.log('オーディオ要素:', {
                          src: audio.src,
                          currentSrc: audio.currentSrc,
                          paused: audio.paused
                      });
                      
                      if (audio.src) {
                          if (audio.src.includes('.m3u8')) {
                              m3u8Urls.push(audio.src);
                          } else if (audio.src.includes('.mp3') || 
                                     audio.src.includes('.m4a') || 
                                     audio.src.includes('.aac') || 
                                     audio.src.includes('.wav')) {
                              audioUrls.push(audio.src);
                          }
                      }
                      
                      if (audio.currentSrc) {
                          if (audio.currentSrc.includes('.m3u8')) {
                              m3u8Urls.push(audio.currentSrc);
                          } else if (audio.currentSrc.includes('.mp3') || 
                                     audio.currentSrc.includes('.m4a') || 
                                     audio.currentSrc.includes('.aac') || 
                                     audio.currentSrc.includes('.wav')) {
                              audioUrls.push(audio.currentSrc);
                          }
                      }
                  });
                  
                  // video要素も確認
                  const videoElements = document.querySelectorAll('video');
                  videoElements.forEach((video, index) => {
                      console.log('ビデオ要素:', {
                          src: video.src,
                          currentSrc: video.currentSrc,
                          paused: video.paused
                      });
                      
                      if (video.src) {
                          if (video.src.includes('.m3u8')) {
                              m3u8Urls.push(video.src);
                          }
                      }
                      
                      if (video.currentSrc) {
                          if (video.currentSrc.includes('.m3u8')) {
                              m3u8Urls.push(video.currentSrc);
                          }
                      }
                  });
                  
                  // source要素も確認
                  const sourceElements = document.querySelectorAll('source');
                  sourceElements.forEach((source, index) => {
                      console.log('ソース要素:', {
                          src: source.src,
                          type: source.type
                      });
                      
                      if (source.src) {
                          if (source.src.includes('.m3u8')) {
                              m3u8Urls.push(source.src);
                          } else if (source.src.includes('.mp3') || 
                                     source.src.includes('.m4a') || 
                                     source.src.includes('.aac') || 
                                     source.src.includes('.wav')) {
                              audioUrls.push(source.src);
                          }
                      }
                  });
                  
                  // ページ内のすべてのJavaScriptオブジェクトを調査
                  for (let key in window) {
                      try {
                          if (typeof window[key] === 'object' && window[key] !== null) {
                              const objStr = JSON.stringify(window[key]);
                              if (objStr.includes('.mp3') || 
                                  objStr.includes('.m4a') || 
                                  objStr.includes('.aac') || 
                                  objStr.includes('.wav') || 
                                  objStr.includes('.m3u8') ||
                                  objStr.includes('audio_url')) {
                                  console.log('オブジェクト内の音声URL候補:', objStr);
                                  
                                  // m3u8URLを抽出
                                  const m3u8Matches = objStr.match(/(https?:\/\/[^"']+\.m3u8)/g);
                                  if (m3u8Matches) {
                                      m3u8Matches.forEach(url => {
                                          if (!m3u8Urls.includes(url)) {
                                              m3u
